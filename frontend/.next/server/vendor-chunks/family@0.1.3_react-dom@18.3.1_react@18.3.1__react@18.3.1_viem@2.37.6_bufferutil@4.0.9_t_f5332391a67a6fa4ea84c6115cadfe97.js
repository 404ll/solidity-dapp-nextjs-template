"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97";
exports.ids = ["vendor-chunks/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/family-accounts-connector-BEWV2sFJ.js":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/family-accounts-connector-BEWV2sFJ.js ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ CommunicationTypes),\n/* harmony export */   E: () => (/* binding */ EthereumProviderConnectionTimeoutError),\n/* harmony export */   F: () => (/* binding */ FamilyAccountsSdk),\n/* harmony export */   S: () => (/* binding */ SessionStatus),\n/* harmony export */   a: () => (/* binding */ SdkStatus),\n/* harmony export */   b: () => (/* binding */ SessionCreateResult),\n/* harmony export */   c: () => (/* binding */ createFamilyAccountsClient),\n/* harmony export */   d: () => (/* binding */ EthereumProvider),\n/* harmony export */   e: () => (/* binding */ familyAccountsConnector),\n/* harmony export */   f: () => (/* binding */ familyAccountsCustomActions),\n/* harmony export */   i: () => (/* binding */ invariant),\n/* harmony export */   p: () => (/* binding */ production)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.37.6_bufferutil@4.0.9_typescript@5.9.2_utf-8-validate@5.0.10_zod@3.22.4/node_modules/viem/_esm/utils/address/getAddress.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.37.6_bufferutil@4.0.9_typescript@5.9.2_utf-8-validate@5.0.10_zod@3.22.4/node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.37.6_bufferutil@4.0.9_typescript@5.9.2_utf-8-validate@5.0.10_zod@3.22.4/node_modules/viem/_esm/clients/transports/custom.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.37.6_bufferutil@4.0.9_typescript@5.9.2_utf-8-validate@5.0.10_zod@3.22.4/node_modules/viem/_esm/clients/decorators/public.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.37.6_bufferutil@4.0.9_typescript@5.9.2_utf-8-validate@5.0.10_zod@3.22.4/node_modules/viem/_esm/errors/rpc.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.37.6_bufferutil@4.0.9_typescript@5.9.2_utf-8-validate@5.0.10_zod@3.22.4/node_modules/viem/_esm/utils/promise/withTimeout.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.37.6_bufferutil@4.0.9_typescript@5.9.2_utf-8-validate@5.0.10_zod@3.22.4/node_modules/viem/_esm/utils/promise/withRetry.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem */ \"(ssr)/./node_modules/.pnpm/viem@2.37.6_bufferutil@4.0.9_typescript@5.9.2_utf-8-validate@5.0.10_zod@3.22.4/node_modules/viem/_esm/utils/encoding/toHex.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n\n\n\nconst isString = (input) => {\n  return typeof input === \"string\";\n};\n\nclass CausedError extends Error {\n  cause;\n  constructor(message, options) {\n    super(message, options);\n    if (options?.cause) {\n      this.cause = options.cause;\n      this.message = `${this.message}\nCAUSE: ${this.cause.message}`;\n      if (typeof this.cause.stack === \"string\") {\n        this.stack = (this.stack ?? \"\") + \"\\nCAUSE: \" + this.cause.stack;\n      }\n    }\n  }\n}\n\nclass Deferred {\n  promise;\n  resolve;\n  reject;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst minutesToMs = (minutes) => minutes * 6e4;\nconst secondsToMs = (seconds) => seconds * 1e3;\nconst msToSeconds = (ms) => ms / 1e3;\n\nclass InvariantError extends CausedError {\n  constructor(message, options) {\n    super(`InvariantError: ${message}`, options);\n  }\n}\nfunction invariant(condition, message, cause) {\n  if (!condition) {\n    throw new InvariantError(message, { cause });\n  }\n}\n\nfunction assertError(error) {\n  if (!(error instanceof Error)) {\n    throw new InvariantError(\n      `Invalid error type. Received ${typeof error}, expected instance of Error`\n    );\n  }\n}\n\nfunction never(message, options) {\n  throw new InvariantError(message, options);\n}\n\nvar SessionStatus;\n(function (SessionStatus) {\n    SessionStatus[\"AUTHENTICATED\"] = \"AUTHENTICATED\";\n    SessionStatus[\"NOT_AUTHENTICATED\"] = \"NOT_AUTHENTICATED\";\n})(SessionStatus || (SessionStatus = {}));\n\nvar CommunicationTypes;\n(function (CommunicationTypes) {\n    /**\n     * Session\n     */\n    CommunicationTypes[\"sessionInit\"] = \"sessionInit\";\n    CommunicationTypes[\"sessionGetCurrent\"] = \"sessionGetCurrent\";\n    CommunicationTypes[\"sessionClear\"] = \"sessionClear\";\n    /**\n     * Ethereum\n     */\n    CommunicationTypes[\"ethereumJsonRpcRequest\"] = \"ethereumJsonRpcRequest\";\n    CommunicationTypes[\"ethereumJsonRpcRequiresApproval\"] = \"ethereumJsonRpcRequiresApproval\";\n})(CommunicationTypes || (CommunicationTypes = {}));\n\nvar SubscriptionTypes;\n(function (SubscriptionTypes) {\n    /**\n     * Session related\n     */\n    SubscriptionTypes[\"sessionChanged\"] = \"sessionChanged\";\n    /**\n     * Network related\n     */\n    SubscriptionTypes[\"ethereumNetworkChanged\"] = \"ethereumNetworkChanged\";\n    /**\n     * Modal related\n     */\n    SubscriptionTypes[\"modalOpen\"] = \"modalOpen\";\n    SubscriptionTypes[\"modalClose\"] = \"modalClose\";\n    SubscriptionTypes[\"modalUpdate\"] = \"modalUpdate\";\n})(SubscriptionTypes || (SubscriptionTypes = {}));\n\nvar PopupCommunicationTypes;\n(function (PopupCommunicationTypes) {\n    PopupCommunicationTypes[\"authStart\"] = \"authStart\";\n    PopupCommunicationTypes[\"rpcRequest\"] = \"rpcRequest\";\n})(PopupCommunicationTypes || (PopupCommunicationTypes = {}));\n\nclass State {\n    static setExecutorWindow = (_window) => {\n        window.____fa_wrapper = {\n            window: _window,\n            origin: window.____fa_wrapper?.origin,\n        };\n    };\n    static getExecutorWindow = () => {\n        if (!window.____fa_wrapper?.window) {\n            throw new Error('You must call `connect` to start up the sdk-web-elements');\n        }\n        return window.____fa_wrapper.window;\n    };\n    static setExecutorOrigin = (origin) => {\n        const instance = window.____fa_wrapper;\n        if (instance) {\n            instance.origin = origin;\n            return;\n        }\n        window.____fa_wrapper = {\n            origin,\n            window: window.____fa_wrapper?.window,\n        };\n    };\n    static getExecutorOrigin = () => {\n        if (!window.____fa_wrapper?.origin) {\n            throw new Error('You must call `connect` to start up the sdk-web-elements');\n        }\n        return window.____fa_wrapper.origin;\n    };\n}\n\nlet postRobot = null;\n/**\n * We do not import `post-robot` right away as it would cause SSR issues given `post-robot` requires access to `window` right away\n */\nconst initPostRobot = async () => {\n    postRobot = await __webpack_require__.e(/*! import() */ \"vendor-chunks/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97\").then(__webpack_require__.bind(__webpack_require__, /*! ./index-DD_kndDs.js */ \"(ssr)/./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/index-DD_kndDs.js\")).then(function (n) { return n.i; });\n};\nconst getPostRobot = () => {\n    invariant(postRobot, 'You need to init post robot first');\n    return postRobot;\n};\n\nconst DEFAULT_PROXY_TIMEOUT$1 = minutesToMs(1);\nconst proxy = async (request, config) => {\n    if (typeof window === 'undefined') {\n        throw new Error(\"Can't proxy in a non browser environment\");\n    }\n    const data = 'data' in request ? request.data : undefined;\n    const event = await getPostRobot().send(State.getExecutorWindow(), request.type, data, {\n        timeout: config?.timeout ?? DEFAULT_PROXY_TIMEOUT$1,\n    });\n    return event.data;\n};\nconst listeners = new Map();\n/**\n * Subscribe to a specific event\n * Supports multiple subscriptions to the same event\n * see https://github.com/krakenjs/post-robot/issues/48\n */\nconst subscribe = (type, callback) => {\n    if (typeof window === 'undefined') {\n        throw new Error(\"Can't subscribe in a non browser environment\");\n    }\n    if (listeners.has(type)) {\n        listeners.get(type)?.callbacks.push(callback);\n    }\n    else {\n        const listener = getPostRobot().on(type, { window: State.getExecutorWindow() }, (event) => {\n            listeners.get(type)?.callbacks.forEach((c) => c(event.data));\n            return Promise.resolve();\n        });\n        listeners.set(type, { listener, callbacks: [callback] });\n    }\n    return () => {\n        const listenerInfo = listeners.get(type);\n        if (!listenerInfo) {\n            return;\n        }\n        const newCallbacks = listenerInfo.callbacks.filter((c) => c !== callback);\n        if (newCallbacks.length === 0) {\n            listenerInfo.listener.cancel();\n            listeners.delete(type);\n        }\n        else {\n            listenerInfo.callbacks = newCallbacks;\n        }\n    };\n};\n\nconst getMasterIframeUrl = () => {\n    return State.getExecutorOrigin() + '/injected/master';\n};\n\nclass IntegratedClientModalController {\n    unsubscribe;\n    autoHeight = false;\n    constructor(container, iframe) {\n        const modalOpenUnsubscribe = subscribe(SubscriptionTypes.modalOpen, ({ height }) => {\n            document.body.style.setProperty('overflow', 'hidden', 'important');\n            // avoid scrollbar jumping when hidden is applied\n            document.body.style.setProperty('padding-right', '15px', 'important');\n            container.style.setProperty('display', 'flex');\n            if (this.autoHeight)\n                iframe.style.setProperty('height', height.toString() + 'px');\n        });\n        const modalCloseUnsubscribe = subscribe(SubscriptionTypes.modalClose, () => {\n            document.body.style.removeProperty('overflow');\n            document.body.style.removeProperty('padding-right');\n            container.style.setProperty('display', 'none');\n        });\n        const modalUpdateUnsubscribe = subscribe(SubscriptionTypes.modalUpdate, ({ height }) => {\n            if (this.autoHeight)\n                iframe.style.setProperty('height', height.toString() + 'px');\n        });\n        this.unsubscribe = () => {\n            modalOpenUnsubscribe();\n            modalCloseUnsubscribe();\n            modalUpdateUnsubscribe();\n        };\n    }\n    disconnect() {\n        this.unsubscribe();\n    }\n}\n\nconst IFRAME_ID = 'family-accounts-master-iframe';\nconst CONNECTION_TIMEOUT$1 = 20000;\nlet modalController = null;\nconst createElements = ({ fullscreen } = {}) => {\n    if (fullscreen) {\n        const container = document.createElement('div');\n        container.style.display = 'none';\n        container.style.position = 'fixed';\n        container.style.inset = '0';\n        container.style.zIndex = '2147483647';\n        const iframe = document.createElement('iframe');\n        iframe.style.all = 'initial';\n        iframe.style.border = '0';\n        iframe.style.margin = '0';\n        iframe.style.padding = '0';\n        iframe.style.position = 'absolute';\n        iframe.style.top = '0';\n        iframe.style.left = '0';\n        iframe.style.width = '100vw';\n        iframe.style.height = '100vh';\n        iframe.style.borderRadius = '0';\n        iframe.id = IFRAME_ID;\n        iframe.src = getMasterIframeUrl();\n        container.appendChild(iframe);\n        return { container, iframe };\n    }\n    else {\n        const container = document.createElement('div');\n        container.style.display = 'none';\n        container.style.alignItems = 'center';\n        container.style.justifyContent = 'center';\n        container.style.position = 'fixed';\n        container.style.top = '0';\n        container.style.left = '0';\n        container.style.width = '100vw';\n        container.style.height = '100vh';\n        container.style.zIndex = '2147483647';\n        const backdrop = document.createElement('div');\n        backdrop.style.position = 'absolute';\n        backdrop.style.inset = '0';\n        backdrop.style.backgroundColor = 'rgba(0,0,0,0.5)';\n        backdrop.style.zIndex = '-1';\n        const iframe = document.createElement('iframe');\n        iframe.style.borderRadius = '10px';\n        iframe.style.boxShadow = '0 0 10px 0 rgba(0,0,0,0.5)';\n        iframe.id = IFRAME_ID;\n        iframe.src = getMasterIframeUrl();\n        container.appendChild(backdrop);\n        container.appendChild(iframe);\n        return { container, iframe };\n    }\n};\n/**\n * Injects the sdk-web-executor so the sdk-web-elements can call the web-elements\n */\nconst connect = ({ environment }) => {\n    const connected = isConnected();\n    // do nothing if already connected\n    if (connected) {\n        return null;\n    }\n    return new Promise((resolve, reject) => {\n        let fulfilled = false;\n        // if it takes longer then CONNECTION_TIMEOUT seconds error!\n        const timeout = setTimeout(() => {\n            fulfilled = true;\n            reject(`The sdk-web-elements failed to connect within ${msToSeconds(CONNECTION_TIMEOUT$1)} seconds, please contact support.`);\n        }, CONNECTION_TIMEOUT$1);\n        const origin = environment.webElementsAppUrl;\n        State.setExecutorOrigin(origin);\n        const { container, iframe } = createElements({\n            fullscreen: true,\n        });\n        iframe.onload = () => {\n            if (fulfilled) {\n                return;\n            }\n            fulfilled = true;\n            clearTimeout(timeout);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            State.setExecutorWindow(iframe.contentWindow);\n            modalController = new IntegratedClientModalController(container, iframe);\n            resolve();\n        };\n        // we need to init post-robot before appending iframe\n        // to make sure listeners are properly setup\n        void initPostRobot().then(() => {\n            document.body.appendChild(container);\n        });\n    });\n};\nconst isConnected = () => {\n    const connector = document.getElementById(IFRAME_ID);\n    return !!connector && !!modalController;\n};\n/**\n * Removes the injected sdk-web-executor\n */\nconst disconnect = () => {\n    const connected = isConnected();\n    // do nothing if not connected\n    if (!connected) {\n        return;\n    }\n    const connector = document.getElementById(IFRAME_ID);\n    invariant(connector, 'The connector is not defined');\n    invariant(modalController, 'The modal controller is not defined');\n    modalController.disconnect();\n    connector.remove();\n};\n\nconst DEVICE_LOCAL_STORAGE_KEY = 'family_accounts__device_id';\nconst getDeviceId = () => localStorage.getItem(DEVICE_LOCAL_STORAGE_KEY);\nconst setDeviceId = (deviceId) => localStorage.setItem(DEVICE_LOCAL_STORAGE_KEY, deviceId);\nconst SESSION_KEY_LOCAL_STORAGE_KEY = 'family_accounts__session_key';\nconst getSessionKey = () => {\n    return localStorage.getItem(SESSION_KEY_LOCAL_STORAGE_KEY);\n};\nconst setSessionKey = (sessionKey) => {\n    return localStorage.setItem(SESSION_KEY_LOCAL_STORAGE_KEY, sessionKey);\n};\nconst removeSessionKey = () => {\n    return localStorage.removeItem(SESSION_KEY_LOCAL_STORAGE_KEY);\n};\n\nconst production = {\n    name: 'production',\n    webElementsAppUrl: 'https://app.family.co',\n};\n\nconst DEFAULT_PROXY_TIMEOUT = minutesToMs(1);\nconst calculatePopupPosition = (width, height) => {\n    const left = window.screenX + (window.outerWidth - width) / 2;\n    const top = window.screenY + (window.outerHeight - height) / 2;\n    return {\n        left,\n        top,\n    };\n};\nconst getPopupSize = (size) => {\n    switch (size) {\n        case PopupSize.MEDIUM:\n            return {\n                width: 444,\n                height: 586,\n            };\n        case PopupSize.INHERITED:\n            return {\n                width: window.outerWidth,\n                height: window.outerHeight,\n            };\n    }\n};\nvar PopupSize;\n(function (PopupSize) {\n    PopupSize[\"MEDIUM\"] = \"MEDIUM\";\n    PopupSize[\"INHERITED\"] = \"INHERITED\";\n})(PopupSize || (PopupSize = {}));\nconst openPopup = (url, name, size = PopupSize.MEDIUM) => {\n    const { width, height } = getPopupSize(size);\n    const { top, left } = calculatePopupPosition(width, height);\n    const options = `width=${width},height=${height},left=${left},top=${top},menubar=no,toolbar=no,location=no,status=no`;\n    return window.open(url, name, options);\n};\nconst proxyPopup = async (popup, request, config) => {\n    const data = 'data' in request ? request.data : undefined;\n    const event = await getPostRobot().send(popup, request.type, data, {\n        timeout: config?.timeout ?? DEFAULT_PROXY_TIMEOUT,\n    });\n    return event.data;\n};\n\nlet connectionChangeListeners = [];\nvar SdkStatus;\n(function (SdkStatus) {\n    SdkStatus[SdkStatus[\"DISCONNECTED\"] = 0] = \"DISCONNECTED\";\n    SdkStatus[SdkStatus[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    SdkStatus[SdkStatus[\"CONNECTED\"] = 2] = \"CONNECTED\";\n})(SdkStatus || (SdkStatus = {}));\nlet sdkStatus = SdkStatus.DISCONNECTED;\nconst requireConnectedSdk = () => {\n    if (sdkStatus !== SdkStatus.CONNECTED) {\n        throw new Error('Family Accounts is not connected. Make sure to call FamilyAccountsSdk.connect() first.');\n    }\n};\nvar SessionCreateResult;\n(function (SessionCreateResult) {\n    /**\n     * User successfully authenticated\n     */\n    SessionCreateResult[\"SUCCESS\"] = \"SUCCESS\";\n    /**\n     * User cancelled popup by closing it or by timeout\n     */\n    SessionCreateResult[\"USER_CANCELLED\"] = \"USER_CANCELLED\";\n    /**\n     * Popup was blocked by the browser\n     */\n    SessionCreateResult[\"BROWSER_BLOCKED\"] = \"BROWSER_BLOCKED\";\n})(SessionCreateResult || (SessionCreateResult = {}));\nconst FamilyAccountsSdk = {\n    async connect(config = { environment: production }) {\n        if (sdkStatus === SdkStatus.CONNECTED) {\n            throw new Error('Family Accounts is already connected. Do not call FamilyAccountsSdk.connect() more than once.');\n        }\n        if (sdkStatus === SdkStatus.CONNECTING) {\n            throw new Error('Family Accounts is already connecting. Do not call FamilyAccountsSdk.connect() more than once.');\n        }\n        sdkStatus = SdkStatus.CONNECTING;\n        await connect(config);\n        await this.session.init();\n        sdkStatus = SdkStatus.CONNECTED;\n        connectionChangeListeners.forEach((listener) => listener(true));\n    },\n    isConnected: () => sdkStatus === SdkStatus.CONNECTED,\n    isConnecting: () => sdkStatus === SdkStatus.CONNECTING,\n    async disconnect() {\n        if (sdkStatus !== SdkStatus.CONNECTED) {\n            throw new Error('Family accounts is not connected');\n        }\n        const currentSession = await this.session.getCurrent();\n        if (currentSession.status === SessionStatus.AUTHENTICATED) {\n            await this.session.clear();\n        }\n        disconnect();\n        sdkStatus = SdkStatus.DISCONNECTED;\n        connectionChangeListeners.forEach((listener) => listener(false));\n        return Promise.resolve();\n    },\n    onConnectionChange: (callback) => {\n        connectionChangeListeners.push(callback);\n        return () => {\n            connectionChangeListeners = connectionChangeListeners.filter((listener) => listener !== callback);\n        };\n    },\n    session: {\n        create: async () => {\n            requireConnectedSdk();\n            const popup = openPopup(`${State.getExecutorOrigin()}/popup/auth`, 'FamilyAccountsAuthentication');\n            if (!popup) {\n                return {\n                    status: SessionCreateResult.BROWSER_BLOCKED,\n                };\n            }\n            try {\n                const response = await proxyPopup(popup, {\n                    type: PopupCommunicationTypes.authStart,\n                }, {\n                    // note: popup has own timeout, this is purely to keep the event alive\n                    timeout: minutesToMs(10),\n                });\n                setSessionKey(response.clientSessionKey);\n                setDeviceId(response.deviceId);\n                return {\n                    status: SessionCreateResult.SUCCESS,\n                    deviceId: response.deviceId,\n                    clientSessionKey: response.clientSessionKey,\n                    idToken: response.idToken,\n                    wallet: {\n                        address: response.wallet.address,\n                    },\n                };\n            }\n            catch {\n                // quite likely a timeout, window was closed or user rejected connection\n                return {\n                    status: SessionCreateResult.USER_CANCELLED,\n                };\n            }\n        },\n        // TODO: Remove `init` from the public API\n        init: () => {\n            const deviceId = getDeviceId();\n            const clientSessionKey = getSessionKey();\n            return proxy({\n                type: CommunicationTypes.sessionInit,\n                data: {\n                    deviceId,\n                    clientSessionKey,\n                },\n            });\n        },\n        getCurrent: () => {\n            requireConnectedSdk();\n            return proxy({\n                type: CommunicationTypes.sessionGetCurrent,\n            });\n        },\n        onChange: (callback) => {\n            requireConnectedSdk();\n            return subscribe(SubscriptionTypes.sessionChanged, callback);\n        },\n        clear: () => {\n            requireConnectedSdk();\n            removeSessionKey();\n            return proxy({\n                type: CommunicationTypes.sessionClear,\n            });\n        },\n    },\n    ethereum: {\n        onNetworkChange: (callback) => {\n            requireConnectedSdk();\n            return subscribe(SubscriptionTypes.ethereumNetworkChanged, callback);\n        },\n    },\n};\n\nconst isIntersectionObserverV2Supported = () => 'IntersectionObserverEntry' in window && 'isVisible' in IntersectionObserverEntry.prototype;\n\n// A list of methods that potentially require user approval\n// If it's a well known method we can handle without user approval\n// But to meet Safari requirements we need to get the first decision point in a non-blocking way\n// Make sure it's in sync with `APPROVAL_REQUIRED_METHODS` from `JsonRpcService`\nconst POTENTIALLY_APPROVAL_REQUIRED_METHODS = [\n    'personal_sign',\n    'eth_sendTransaction',\n    'eth_signTypedData_v4',\n    'wallet_addEthereumChain',\n    'family_switchAccounts',\n];\nclass RpcError extends Error {\n    code;\n    message;\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        this.message = message;\n    }\n    static userRejectedRequest(message) {\n        return new RpcError(4001, message);\n    }\n    static unauthorized(message) {\n        return new RpcError(4100, message);\n    }\n}\nclass LocalRpcHandler {\n    args;\n    constructor(args) {\n        this.args = args;\n    }\n    async handle() {\n        switch (this.args.method) {\n            case 'eth_requestAccounts':\n                return this.handleRequestAccounts();\n            default: {\n                never('Unsupported method');\n            }\n        }\n    }\n    async handleRequestAccounts() {\n        try {\n            const session = await FamilyAccountsSdk.session.getCurrent();\n            if (session.status === SessionStatus.AUTHENTICATED) {\n                return [session.wallet.address];\n            }\n            const createdSession = await FamilyAccountsSdk.session.create();\n            switch (createdSession.status) {\n                case SessionCreateResult.SUCCESS:\n                    return [createdSession.wallet.address];\n                case SessionCreateResult.BROWSER_BLOCKED:\n                    throw RpcError.userRejectedRequest('Browser blocked Family Accounts authentication popup');\n                case SessionCreateResult.USER_CANCELLED:\n                    throw RpcError.userRejectedRequest('User cancelled authentication request');\n            }\n        }\n        catch (error) {\n            // if the error already looks like a rpc error then throw it\n            if (error instanceof Error && 'code' in error) {\n                throw error;\n            }\n            // most likely can't happen\n            throw RpcError.userRejectedRequest('Unknown reason');\n        }\n    }\n}\nclass MasterIframeRpcHandler {\n    args;\n    // The default post message timeout is 10 seconds\n    DEFAULT_RPC_CALL_TIMEOUT = secondsToMs(10);\n    DEFAULT_RPC_SIGN_TIMEOUT = minutesToMs(10);\n    constructor(args) {\n        this.args = args;\n    }\n    async handle() {\n        const timeout = POTENTIALLY_APPROVAL_REQUIRED_METHODS.includes(this.args.method)\n            ? // if its sending a transaction make the timeout very\n                // long as they may get a approval modal displayed\n                // and if so have a `forever` time to approval it\n                this.DEFAULT_RPC_SIGN_TIMEOUT\n            : this.DEFAULT_RPC_CALL_TIMEOUT;\n        try {\n            const result = await proxy({\n                type: CommunicationTypes.ethereumJsonRpcRequest,\n                data: this.args,\n            }, {\n                timeout,\n            });\n            invariant(result !== undefined, 'The JSON RPC result should not be undefined');\n            return result;\n        }\n        catch (error) {\n            // if the error already looks like a rpc error then throw it\n            if (error instanceof Error && 'code' in error) {\n                throw error;\n            }\n            // most likely can't happen\n            throw RpcError.userRejectedRequest('Unknown reason');\n        }\n    }\n}\n/**\n * A handler for rpc request in case intersection observer is not supported\n * Note: It's build in a way to work with safari popup blocker in mind where popups are blocked if they are happen in a Promise\n */\nclass PopupModalRpcHandler {\n    args;\n    // if it takes longer to detect if approval is required (e.g. simulation time intensive)\n    // we would then treat it as approval required to not block the UI\n    APPROVAL_REQUIRED_TIMEOUT = 300;\n    constructor(args) {\n        this.args = args;\n    }\n    handle() {\n        let requestRequiresApproval = null;\n        // note: can't use async/await here as will block popup modal on Safari\n        void requiresUserApproval(this.args).then((result) => {\n            requestRequiresApproval = result;\n        });\n        const deferred = new Deferred();\n        // note: set timeout is allowed by Safari to open popups\n        setTimeout(async () => {\n            // user approval is not required so we can handle it in the master iframe\n            if (requestRequiresApproval === false) {\n                new MasterIframeRpcHandler(this.args).handle().then(deferred.resolve, deferred.reject);\n                return;\n            }\n            const popup = openPopup(`${State.getExecutorOrigin()}/popup/rpc`, 'FamilyAccountsRpc', PopupSize.INHERITED);\n            if (!popup) {\n                deferred.reject(RpcError.userRejectedRequest('Popup blocked'));\n                return;\n            }\n            const clientSessionKey = getSessionKey();\n            const deviceId = getDeviceId();\n            if (!clientSessionKey || !deviceId) {\n                deferred.reject(RpcError.unauthorized('User not authorized'));\n                return;\n            }\n            try {\n                const result = await proxyPopup(popup, {\n                    type: PopupCommunicationTypes.rpcRequest,\n                    data: {\n                        request: this.args,\n                        clientSessionKey,\n                        deviceId,\n                    },\n                }, {\n                    // note: popup has own timeout, this is purely to keep the event alive\n                    timeout: minutesToMs(10),\n                });\n                deferred.resolve(result);\n            }\n            catch (error) {\n                assertError(error);\n                // if the error already looks like a rpc error then throw it\n                if (error instanceof Error && 'code' in error) {\n                    deferred.reject(error);\n                    return;\n                }\n                // quite likely a timeout, window was closed or user rejected connection\n                deferred.reject(RpcError.userRejectedRequest('Popup was closed by the user'));\n            }\n        }, this.APPROVAL_REQUIRED_TIMEOUT);\n        return deferred.promise;\n    }\n}\nconst requiresUserApproval = async (args) => {\n    try {\n        return await proxy({\n            type: CommunicationTypes.ethereumJsonRpcRequiresApproval,\n            data: args,\n        });\n    }\n    catch (error) {\n        // if the error already looks like a rpc error then throw it\n        if (error instanceof Error && 'code' in error) {\n            throw error;\n        }\n        // most likely can't happen\n        throw RpcError.userRejectedRequest('Unknown reason');\n    }\n};\nfunction getRpcRequestHandler(args) {\n    if (args.method === 'eth_requestAccounts') {\n        return new LocalRpcHandler(args);\n    }\n    if (isIntersectionObserverV2Supported()) {\n        // note: master iframe will reject requests if intersection observer is not supported\n        return new MasterIframeRpcHandler(args);\n    }\n    if (!POTENTIALLY_APPROVAL_REQUIRED_METHODS.includes(args.method)) {\n        return new MasterIframeRpcHandler(args);\n    }\n    return new PopupModalRpcHandler(args);\n}\n\nconst CONNECTION_TIMEOUT = secondsToMs(5);\nclass EthereumProviderConnectionTimeoutError extends Error {\n    constructor() {\n        super('EIP1193 provider connection timeout. Make sure to call `FamilyAccountsSdk.connect()` before using the provider.');\n    }\n}\n/**\n * This follows the EIP - https://eips.ethereum.org/EIPS/eip-1193\n */\nclass EthereumProvider {\n    _eventEmitter = new events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n    _accountsChangedUnsubscriptionCallback = null;\n    _networkChangedUnsubscriptionCallback = null;\n    _connectUnsubscriptionCallback = null;\n    _disconnectUnsubscriptionCallback = null;\n    _config;\n    constructor(options) {\n        this._config = options;\n    }\n    log(...args) {\n        if (this._config?.debug) {\n            // eslint-disable-next-line no-console\n            console.log(...args);\n        }\n    }\n    /**\n     * @returns true if the provider is connected and ready to process requests\n     */\n    isConnected() {\n        return FamilyAccountsSdk.isConnected();\n    }\n    /**\n     * JSONRPC request\n     * @param args The request arguments\n     */\n    // return type is loose as we don't want to type all the possible return types given it's a proxy\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request(args) {\n        await this.waitForConnection();\n        const requestHandler = getRpcRequestHandler({\n            method: args.method,\n            // normalize params to be an array\n            params: Array.isArray(args.params) ? args.params : [args.params],\n        });\n        return requestHandler.handle();\n    }\n    /**\n     * JSONRPC request\n     * @param method The request jsonrpc method\n     * @param params The request parameters\n     * @deprecated Please use `request` instead.\n     */\n    async send(method, params) {\n        return this.request({ method, params });\n    }\n    on(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener) {\n        // we don't support `message` event\n        if (eventName === 'message') {\n            return this;\n        }\n        this.log('on', eventName);\n        if (this._eventEmitter.listenerCount(eventName) === 0) {\n            switch (eventName) {\n                case 'accountsChanged':\n                    void this.subscribeToAccountChangeEvent().catch((...args) => this.log('accountsChanged', args));\n                    break;\n                case 'chainChanged':\n                    void this.subscribeToNetworkChangeEvent();\n                    break;\n                case 'connect':\n                    void this.subscribeToConnectEvent().catch((...args) => this.log('connect', args));\n                    break;\n                case 'disconnect':\n                    void this.subscribeToDisconnectEvent().catch((...args) => this.log('disconnect', args));\n                    break;\n            }\n        }\n        this._eventEmitter.on(eventName, listener);\n        return this;\n    }\n    /**\n     * Remove the provider event emitters\n     * @param eventName The event name\n     * @param listener The listener to callback\n     */\n    removeListener(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener) {\n        // we don't support `message` event\n        if (eventName === 'message') {\n            return this;\n        }\n        this._eventEmitter.removeListener(eventName, listener);\n        if (this._eventEmitter.listenerCount(eventName) === 0) {\n            switch (eventName) {\n                case 'accountsChanged':\n                    void this.unsubscribeFromAccountChangeEvent().catch((...args) => this.log('accountsChanged', args));\n                    break;\n                case 'chainChanged':\n                    void this.unsubscribeFromNetworkChangeEvent();\n                    break;\n                case 'connect':\n                    void this.unsubscribeFromConnectEvent().catch((...args) => this.log('connect', args));\n                    break;\n                case 'disconnect':\n                    void this.unsubscribeFromDisconnectEvent().catch((...args) => this.log('disconnect', args));\n                    break;\n            }\n        }\n        return this;\n    }\n    subscribeToNetworkChangeEvent() {\n        invariant(!this._networkChangedUnsubscriptionCallback, 'Already subscribed to network change event');\n        this._networkChangedUnsubscriptionCallback = FamilyAccountsSdk.ethereum.onNetworkChange((newValue) => {\n            this._eventEmitter.emit('chainChanged', newValue.chainId);\n        });\n    }\n    unsubscribeFromNetworkChangeEvent() {\n        invariant(this._networkChangedUnsubscriptionCallback, 'Not subscribed to network change event');\n        this._networkChangedUnsubscriptionCallback();\n        this._networkChangedUnsubscriptionCallback = null;\n    }\n    async subscribeToAccountChangeEvent() {\n        await this.waitForConnection();\n        invariant(!this._accountsChangedUnsubscriptionCallback, 'Already subscribed to account change event');\n        let prevConnectedAccount = null;\n        // to avoid race condition issues with immediate unsubscribing we should not wait for session promise and immediately attach listener\n        // otherwise there is a short amount of time when `this._accountsChangedUnsubscriptionCallback` is not assigned but `unsubscribeFromAccountChangeEvent` called\n        void FamilyAccountsSdk.session.getCurrent().then((currentSession) => {\n            prevConnectedAccount =\n                currentSession.status === SessionStatus.AUTHENTICATED\n                    ? currentSession.wallet.address\n                    : null;\n        });\n        this._accountsChangedUnsubscriptionCallback = FamilyAccountsSdk.session.onChange((newValue) => {\n            const newConnectedAccount = newValue.status === SessionStatus.AUTHENTICATED ? newValue.wallet.address : null;\n            // session change affects more than just the account\n            // ONLY emit the event if the account changes\n            if (prevConnectedAccount !== newConnectedAccount) {\n                this._eventEmitter.emit('accountsChanged', newConnectedAccount === null ? [] : [newConnectedAccount]);\n                prevConnectedAccount = newConnectedAccount;\n            }\n        });\n    }\n    async unsubscribeFromAccountChangeEvent() {\n        await this.waitForConnection();\n        invariant(this._accountsChangedUnsubscriptionCallback, 'Not subscribed to account change event');\n        this._accountsChangedUnsubscriptionCallback();\n        this._accountsChangedUnsubscriptionCallback = null;\n    }\n    async subscribeToConnectEvent() {\n        await this.waitForConnection();\n        invariant(!this._connectUnsubscriptionCallback, 'Already subscribed to connect event');\n        this._connectUnsubscriptionCallback = FamilyAccountsSdk.onConnectionChange(async (isConnected) => {\n            if (isConnected) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const chainId = await this.request({ method: 'eth_chainId' });\n                if (!isString(chainId))\n                    return; // Invalid chainId\n                invariant(isString(chainId), 'Invalid chainId');\n                this._eventEmitter.emit('connect', {\n                    chainId,\n                });\n            }\n        });\n    }\n    async unsubscribeFromConnectEvent() {\n        await this.waitForConnection();\n        invariant(this._connectUnsubscriptionCallback, 'Not subscribed to connect event');\n        this._connectUnsubscriptionCallback();\n        this._connectUnsubscriptionCallback = null;\n    }\n    async subscribeToDisconnectEvent() {\n        await this.waitForConnection();\n        invariant(!this._disconnectUnsubscriptionCallback, 'Already subscribed to disconnect event');\n        this._disconnectUnsubscriptionCallback = FamilyAccountsSdk.onConnectionChange((isConnected) => {\n            if (!isConnected) {\n                this._eventEmitter.emit('disconnect');\n            }\n        });\n    }\n    async unsubscribeFromDisconnectEvent() {\n        await this.waitForConnection();\n        invariant(this._disconnectUnsubscriptionCallback, 'Not subscribed to account disconnect event');\n        this._disconnectUnsubscriptionCallback();\n        this._disconnectUnsubscriptionCallback = null;\n    }\n    /**\n     * Wait for the provider to be connected\n     * This is done to make provider compatible with `wagmi` `injected` connector that tries to attach events before the provider is connected\n     */\n    async waitForConnection() {\n        if (FamilyAccountsSdk.isConnected()) {\n            return;\n        }\n        // sdk is connecting, wait for it to finish\n        if (FamilyAccountsSdk.isConnecting()) {\n            const deferred = new Deferred();\n            const unsubscribe = FamilyAccountsSdk.onConnectionChange((isConnected) => {\n                if (isConnected) {\n                    deferred.resolve();\n                }\n            });\n            const { timeout } = await Promise.race([\n                deferred.promise.then(() => ({ timeout: false })),\n                delay(CONNECTION_TIMEOUT).then(() => ({ timeout: true })),\n            ]);\n            unsubscribe();\n            if (timeout) {\n                throw new EthereumProviderConnectionTimeoutError();\n            }\n            return;\n        }\n        const { timeout } = await Promise.race([\n            FamilyAccountsSdk.connect(this._config?.options).then(() => ({ timeout: false })),\n            delay(CONNECTION_TIMEOUT).then(() => ({ timeout: true })),\n        ]);\n        if (timeout) {\n            throw new EthereumProviderConnectionTimeoutError();\n        }\n    }\n}\n\nconst familyAccountsCustomActions = (client) => ({\n    getIdToken: async () => {\n        const currentSession = await FamilyAccountsSdk.session.getCurrent();\n        if (currentSession.status !== SessionStatus.AUTHENTICATED) {\n            return null;\n        }\n        return currentSession.idToken;\n    },\n    switchAccounts: async () => {\n        const addresses = await client.request({ method: 'family_switchAccounts', params: [] }, { retryCount: 0 });\n        return addresses.map((address) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address));\n    },\n    disconnect: async () => {\n        await client.request({\n            method: 'wallet_revokePermissions',\n            params: [\n                {\n                    eth_accounts: {},\n                },\n            ],\n        }, { retryCount: 0 });\n    },\n});\nconst createFamilyAccountsClient = async () => {\n    const currentSession = await FamilyAccountsSdk.session.getCurrent();\n    invariant(currentSession.status === SessionStatus.AUTHENTICATED, 'Account must be connected to create a Family Accounts client.');\n    const client = (0,viem__WEBPACK_IMPORTED_MODULE_2__.createWalletClient)({\n        account: currentSession.wallet.address,\n        transport: (0,viem__WEBPACK_IMPORTED_MODULE_3__.custom)(new EthereumProvider()),\n    })\n        .extend(viem__WEBPACK_IMPORTED_MODULE_4__.publicActions)\n        .extend(familyAccountsCustomActions);\n    return client;\n};\n\nconst version$1 = '2.16.5';\n\nconst getVersion = () => `@wagmi/core@${version$1}`;\n\nvar __classPrivateFieldGet = ( false) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BaseError_instances, _BaseError_walk;\nclass BaseError extends Error {\n    get docsBaseUrl() {\n        return 'https://wagmi.sh/core';\n    }\n    get version() {\n        return getVersion();\n    }\n    constructor(shortMessage, options = {}) {\n        super();\n        _BaseError_instances.add(this);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'WagmiCoreError'\n        });\n        const details = options.cause instanceof BaseError\n            ? options.cause.details\n            : options.cause?.message\n                ? options.cause.message\n                : options.details;\n        const docsPath = options.cause instanceof BaseError\n            ? options.cause.docsPath || options.docsPath\n            : options.docsPath;\n        this.message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(options.metaMessages ? [...options.metaMessages, ''] : []),\n            ...(docsPath\n                ? [\n                    `Docs: ${this.docsBaseUrl}${docsPath}.html${options.docsSlug ? `#${options.docsSlug}` : ''}`,\n                ]\n                : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: ${this.version}`,\n        ].join('\\n');\n        if (options.cause)\n            this.cause = options.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = options.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return __classPrivateFieldGet(this, _BaseError_instances, \"m\", _BaseError_walk).call(this, this, fn);\n    }\n}\n_BaseError_instances = new WeakSet(), _BaseError_walk = function _BaseError_walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err.cause)\n        return __classPrivateFieldGet(this, _BaseError_instances, \"m\", _BaseError_walk).call(this, err.cause, fn);\n    return err;\n};\n\nclass ChainNotConfiguredError extends BaseError {\n    constructor() {\n        super('Chain not configured.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ChainNotConfiguredError'\n        });\n    }\n}\n\nclass ProviderNotFoundError extends BaseError {\n    constructor() {\n        super('Provider not found.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ProviderNotFoundError'\n        });\n    }\n}\n\nfunction createConnector(createConnectorFn) {\n    return createConnectorFn;\n}\n\ninjected.type = 'injected';\nfunction injected(parameters = {}) {\n    const { shimDisconnect = true, unstable_shimAsyncInject } = parameters;\n    function getTarget() {\n        const target = parameters.target;\n        if (typeof target === 'function') {\n            const result = target();\n            if (result)\n                return result;\n        }\n        if (typeof target === 'object')\n            return target;\n        if (typeof target === 'string')\n            return {\n                ...(targetMap[target] ?? {\n                    id: target,\n                    name: `${target[0].toUpperCase()}${target.slice(1)}`,\n                    provider: `is${target[0].toUpperCase()}${target.slice(1)}`,\n                }),\n            };\n        return {\n            id: 'injected',\n            name: 'Injected',\n            provider(window) {\n                return window?.ethereum;\n            },\n        };\n    }\n    let accountsChanged;\n    let chainChanged;\n    let connect;\n    let disconnect;\n    return createConnector((config) => ({\n        get icon() {\n            return getTarget().icon;\n        },\n        get id() {\n            return getTarget().id;\n        },\n        get name() {\n            return getTarget().name;\n        },\n        /** @deprecated */\n        get supportsSimulation() {\n            return true;\n        },\n        type: injected.type,\n        async setup() {\n            const provider = await this.getProvider();\n            // Only start listening for events if `target` is set, otherwise `injected()` will also receive events\n            if (provider?.on && parameters.target) {\n                if (!connect) {\n                    connect = this.onConnect.bind(this);\n                    provider.on('connect', connect);\n                }\n                // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n                // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n            }\n        },\n        async connect({ chainId, isReconnecting } = {}) {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            let accounts = [];\n            if (isReconnecting)\n                accounts = await this.getAccounts().catch(() => []);\n            else if (shimDisconnect) {\n                // Attempt to show another prompt for selecting account if `shimDisconnect` flag is enabled\n                try {\n                    const permissions = await provider.request({\n                        method: 'wallet_requestPermissions',\n                        params: [{ eth_accounts: {} }],\n                    });\n                    accounts = permissions[0]?.caveats?.[0]?.value?.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n                    // `'wallet_requestPermissions'` can return a different order of accounts than `'eth_accounts'`\n                    // switch to `'eth_accounts'` ordering if more than one account is connected\n                    // https://github.com/wevm/wagmi/issues/4140\n                    if (accounts.length > 0) {\n                        const sortedAccounts = await this.getAccounts();\n                        accounts = sortedAccounts;\n                    }\n                }\n                catch (err) {\n                    const error = err;\n                    // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n                    // Only bubble up error if user rejects request\n                    if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError.code)\n                        throw new viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError(error);\n                    // Or prompt is already open\n                    if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.ResourceUnavailableRpcError.code)\n                        throw error;\n                }\n            }\n            try {\n                if (!accounts?.length && !isReconnecting) {\n                    const requestedAccounts = await provider.request({\n                        method: 'eth_requestAccounts',\n                    });\n                    accounts = requestedAccounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n                }\n                // Manage EIP-1193 event listeners\n                // https://eips.ethereum.org/EIPS/eip-1193#events\n                if (connect) {\n                    provider.removeListener('connect', connect);\n                    connect = undefined;\n                }\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n                // Switch to chain if provided\n                let currentChainId = await this.getChainId();\n                if (chainId && currentChainId !== chainId) {\n                    const chain = await this.switchChain({ chainId }).catch((error) => {\n                        if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError.code)\n                            throw error;\n                        return { id: currentChainId };\n                    });\n                    currentChainId = chain?.id ?? currentChainId;\n                }\n                // Remove disconnected shim if it exists\n                if (shimDisconnect)\n                    await config.storage?.removeItem(`${this.id}.disconnected`);\n                // Add connected shim if no target exists\n                if (!parameters.target)\n                    await config.storage?.setItem('injected.connected', true);\n                return { accounts, chainId: currentChainId };\n            }\n            catch (err) {\n                const error = err;\n                if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError.code)\n                    throw new viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError(error);\n                if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.ResourceUnavailableRpcError.code)\n                    throw new viem__WEBPACK_IMPORTED_MODULE_5__.ResourceUnavailableRpcError(error);\n                throw error;\n            }\n        },\n        async disconnect() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            // Manage EIP-1193 event listeners\n            if (chainChanged) {\n                provider.removeListener('chainChanged', chainChanged);\n                chainChanged = undefined;\n            }\n            if (disconnect) {\n                provider.removeListener('disconnect', disconnect);\n                disconnect = undefined;\n            }\n            if (!connect) {\n                connect = this.onConnect.bind(this);\n                provider.on('connect', connect);\n            }\n            // Experimental support for MetaMask disconnect\n            // https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-2.md\n            try {\n                // Adding timeout as not all wallets support this method and can hang\n                // https://github.com/wevm/wagmi/issues/4064\n                await (0,viem__WEBPACK_IMPORTED_MODULE_6__.withTimeout)(() => \n                // TODO: Remove explicit type for viem@3\n                provider.request({\n                    // `'wallet_revokePermissions'` added in `viem@2.10.3`\n                    method: 'wallet_revokePermissions',\n                    params: [{ eth_accounts: {} }],\n                }), { timeout: 100 });\n            }\n            catch { }\n            // Add shim signalling connector is disconnected\n            if (shimDisconnect) {\n                await config.storage?.setItem(`${this.id}.disconnected`, true);\n            }\n            if (!parameters.target)\n                await config.storage?.removeItem('injected.connected');\n        },\n        async getAccounts() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            const accounts = await provider.request({ method: 'eth_accounts' });\n            return accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x));\n        },\n        async getChainId() {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            const hexChainId = await provider.request({ method: 'eth_chainId' });\n            return Number(hexChainId);\n        },\n        async getProvider() {\n            if (typeof window === 'undefined')\n                return undefined;\n            let provider;\n            const target = getTarget();\n            if (typeof target.provider === 'function')\n                provider = target.provider(window);\n            else if (typeof target.provider === 'string')\n                provider = findProvider(window, target.provider);\n            else\n                provider = target.provider;\n            // Some wallets do not conform to EIP-1193 (e.g. Trust Wallet)\n            // https://github.com/wevm/wagmi/issues/3526#issuecomment-1912683002\n            if (provider && !provider.removeListener) {\n                // Try using `off` handler if it exists, otherwise noop\n                if ('off' in provider && typeof provider.off === 'function')\n                    provider.removeListener =\n                        provider.off;\n                else\n                    provider.removeListener = () => { };\n            }\n            return provider;\n        },\n        async isAuthorized() {\n            try {\n                const isDisconnected = shimDisconnect &&\n                    // If shim exists in storage, connector is disconnected\n                    (await config.storage?.getItem(`${this.id}.disconnected`));\n                if (isDisconnected)\n                    return false;\n                // Don't allow injected connector to connect if no target is set and it hasn't already connected\n                // (e.g. flag in storage is not set). This prevents a targetless injected connector from connecting\n                // automatically whenever there is a targeted connector configured.\n                if (!parameters.target) {\n                    const connected = await config.storage?.getItem('injected.connected');\n                    if (!connected)\n                        return false;\n                }\n                const provider = await this.getProvider();\n                if (!provider) {\n                    if (unstable_shimAsyncInject !== undefined &&\n                        unstable_shimAsyncInject !== false) {\n                        // If no provider is found, check for async injection\n                        // https://github.com/wevm/references/issues/167\n                        // https://github.com/MetaMask/detect-provider\n                        const handleEthereum = async () => {\n                            if (typeof window !== 'undefined')\n                                window.removeEventListener('ethereum#initialized', handleEthereum);\n                            const provider = await this.getProvider();\n                            return !!provider;\n                        };\n                        const timeout = typeof unstable_shimAsyncInject === 'number'\n                            ? unstable_shimAsyncInject\n                            : 1_000;\n                        const res = await Promise.race([\n                            ...(typeof window !== 'undefined'\n                                ? [\n                                    new Promise((resolve) => window.addEventListener('ethereum#initialized', () => resolve(handleEthereum()), { once: true })),\n                                ]\n                                : []),\n                            new Promise((resolve) => setTimeout(() => resolve(handleEthereum()), timeout)),\n                        ]);\n                        if (res)\n                            return true;\n                    }\n                    throw new ProviderNotFoundError();\n                }\n                // Use retry strategy as some injected wallets (e.g. MetaMask) fail to\n                // immediately resolve JSON-RPC requests on page load.\n                const accounts = await (0,viem__WEBPACK_IMPORTED_MODULE_7__.withRetry)(() => this.getAccounts());\n                return !!accounts.length;\n            }\n            catch {\n                return false;\n            }\n        },\n        async switchChain({ addEthereumChainParameter, chainId }) {\n            const provider = await this.getProvider();\n            if (!provider)\n                throw new ProviderNotFoundError();\n            const chain = config.chains.find((x) => x.id === chainId);\n            if (!chain)\n                throw new viem__WEBPACK_IMPORTED_MODULE_5__.SwitchChainError(new ChainNotConfiguredError());\n            const promise = new Promise((resolve) => {\n                const listener = ((data) => {\n                    if ('chainId' in data && data.chainId === chainId) {\n                        config.emitter.off('change', listener);\n                        resolve();\n                    }\n                });\n                config.emitter.on('change', listener);\n            });\n            try {\n                await Promise.all([\n                    provider\n                        .request({\n                        method: 'wallet_switchEthereumChain',\n                        params: [{ chainId: (0,viem__WEBPACK_IMPORTED_MODULE_8__.numberToHex)(chainId) }],\n                    })\n                        // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n                        // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n                        // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n                        // this callback or an externally emitted `'chainChanged'` event.\n                        // https://github.com/MetaMask/metamask-extension/issues/24247\n                        .then(async () => {\n                        const currentChainId = await this.getChainId();\n                        if (currentChainId === chainId)\n                            config.emitter.emit('change', { chainId });\n                    }),\n                    promise,\n                ]);\n                return chain;\n            }\n            catch (err) {\n                const error = err;\n                // Indicates chain is not added to provider\n                if (error.code === 4902 ||\n                    // Unwrapping for MetaMask Mobile\n                    // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n                    error\n                        ?.data?.originalError?.code === 4902) {\n                    try {\n                        const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};\n                        let blockExplorerUrls;\n                        if (addEthereumChainParameter?.blockExplorerUrls)\n                            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;\n                        else if (blockExplorer)\n                            blockExplorerUrls = [\n                                blockExplorer.url,\n                                ...Object.values(blockExplorers).map((x) => x.url),\n                            ];\n                        let rpcUrls;\n                        if (addEthereumChainParameter?.rpcUrls?.length)\n                            rpcUrls = addEthereumChainParameter.rpcUrls;\n                        else\n                            rpcUrls = [chain.rpcUrls.default?.http[0] ?? ''];\n                        const addEthereumChain = {\n                            blockExplorerUrls,\n                            chainId: (0,viem__WEBPACK_IMPORTED_MODULE_8__.numberToHex)(chainId),\n                            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                            iconUrls: addEthereumChainParameter?.iconUrls,\n                            nativeCurrency: addEthereumChainParameter?.nativeCurrency ??\n                                chain.nativeCurrency,\n                            rpcUrls,\n                        };\n                        await Promise.all([\n                            provider\n                                .request({\n                                method: 'wallet_addEthereumChain',\n                                params: [addEthereumChain],\n                            })\n                                .then(async () => {\n                                const currentChainId = await this.getChainId();\n                                if (currentChainId === chainId)\n                                    config.emitter.emit('change', { chainId });\n                                else\n                                    throw new viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError(new Error('User rejected switch after adding network.'));\n                            }),\n                            promise,\n                        ]);\n                        return chain;\n                    }\n                    catch (error) {\n                        throw new viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError(error);\n                    }\n                }\n                if (error.code === viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError.code)\n                    throw new viem__WEBPACK_IMPORTED_MODULE_5__.UserRejectedRequestError(error);\n                throw new viem__WEBPACK_IMPORTED_MODULE_5__.SwitchChainError(error);\n            }\n        },\n        async onAccountsChanged(accounts) {\n            // Disconnect if there are no accounts\n            if (accounts.length === 0)\n                this.onDisconnect();\n            // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n            else if (config.emitter.listenerCount('connect')) {\n                const chainId = (await this.getChainId()).toString();\n                this.onConnect({ chainId });\n                // Remove disconnected shim if it exists\n                if (shimDisconnect)\n                    await config.storage?.removeItem(`${this.id}.disconnected`);\n            }\n            // Regular change event\n            else\n                config.emitter.emit('change', {\n                    accounts: accounts.map((x) => (0,viem__WEBPACK_IMPORTED_MODULE_1__.getAddress)(x)),\n                });\n        },\n        onChainChanged(chain) {\n            const chainId = Number(chain);\n            config.emitter.emit('change', { chainId });\n        },\n        async onConnect(connectInfo) {\n            const accounts = await this.getAccounts();\n            if (accounts.length === 0)\n                return;\n            const chainId = Number(connectInfo.chainId);\n            config.emitter.emit('connect', { accounts, chainId });\n            // Manage EIP-1193 event listeners\n            const provider = await this.getProvider();\n            if (provider) {\n                if (connect) {\n                    provider.removeListener('connect', connect);\n                    connect = undefined;\n                }\n                if (!accountsChanged) {\n                    accountsChanged = this.onAccountsChanged.bind(this);\n                    provider.on('accountsChanged', accountsChanged);\n                }\n                if (!chainChanged) {\n                    chainChanged = this.onChainChanged.bind(this);\n                    provider.on('chainChanged', chainChanged);\n                }\n                if (!disconnect) {\n                    disconnect = this.onDisconnect.bind(this);\n                    provider.on('disconnect', disconnect);\n                }\n            }\n        },\n        async onDisconnect(error) {\n            const provider = await this.getProvider();\n            // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n            // https://github.com/MetaMask/providers/pull/120\n            if (error && error.code === 1013) {\n                if (provider && !!(await this.getAccounts()).length)\n                    return;\n            }\n            // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically\n            // only called when the wallet is disconnected through the wallet's interface, meaning the wallet\n            // actually disconnected and we don't need to simulate it.\n            config.emitter.emit('disconnect');\n            // Manage EIP-1193 event listeners\n            if (provider) {\n                if (chainChanged) {\n                    provider.removeListener('chainChanged', chainChanged);\n                    chainChanged = undefined;\n                }\n                if (disconnect) {\n                    provider.removeListener('disconnect', disconnect);\n                    disconnect = undefined;\n                }\n                if (!connect) {\n                    connect = this.onConnect.bind(this);\n                    provider.on('connect', connect);\n                }\n            }\n        },\n    }));\n}\nconst targetMap = {\n    coinbaseWallet: {\n        id: 'coinbaseWallet',\n        name: 'Coinbase Wallet',\n        provider(window) {\n            if (window?.coinbaseWalletExtension)\n                return window.coinbaseWalletExtension;\n            return findProvider(window, 'isCoinbaseWallet');\n        },\n    },\n    metaMask: {\n        id: 'metaMask',\n        name: 'MetaMask',\n        provider(window) {\n            return findProvider(window, (provider) => {\n                if (!provider.isMetaMask)\n                    return false;\n                // Brave tries to make itself look like MetaMask\n                // Could also try RPC `web3_clientVersion` if following is unreliable\n                if (provider.isBraveWallet && !provider._events && !provider._state)\n                    return false;\n                // Other wallets that try to look like MetaMask\n                const flags = [\n                    'isApexWallet',\n                    'isAvalanche',\n                    'isBitKeep',\n                    'isBlockWallet',\n                    'isKuCoinWallet',\n                    'isMathWallet',\n                    'isOkxWallet',\n                    'isOKExWallet',\n                    'isOneInchIOSWallet',\n                    'isOneInchAndroidWallet',\n                    'isOpera',\n                    'isPhantom',\n                    'isPortal',\n                    'isRabby',\n                    'isTokenPocket',\n                    'isTokenary',\n                    'isUniswapWallet',\n                    'isZerion',\n                ];\n                for (const flag of flags)\n                    if (provider[flag])\n                        return false;\n                return true;\n            });\n        },\n    },\n    phantom: {\n        id: 'phantom',\n        name: 'Phantom',\n        provider(window) {\n            if (window?.phantom?.ethereum)\n                return window.phantom?.ethereum;\n            return findProvider(window, 'isPhantom');\n        },\n    },\n};\nfunction findProvider(window, select) {\n    function isProvider(provider) {\n        if (typeof select === 'function')\n            return select(provider);\n        if (typeof select === 'string')\n            return provider[select];\n        return true;\n    }\n    const ethereum = window.ethereum;\n    if (ethereum?.providers)\n        return ethereum.providers.find((provider) => isProvider(provider));\n    if (ethereum && isProvider(ethereum))\n        return ethereum;\n    return undefined;\n}\n\nconst Logo = 'data:image/png;base64,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';\n\nvar version = \"0.1.3\";\n\nconst familyAccountsConnector = (options) => {\n    const provider = new EthereumProvider(options);\n    return injected({\n        // note: we don't support `wallet_requestPermissions` at this point\n        shimDisconnect: false,\n        target() {\n            return {\n                id: 'familyAccountsProvider',\n                name: 'Family Accounts',\n                provider,\n                icon: Logo,\n            };\n        },\n    });\n};\nfamilyAccountsConnector.version = version;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFtaWx5QDAuMS4zX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfdmllbUAyLjM3LjZfYnVmZmVydXRpbEA0LjAuOV90X2Y1MzMyMzkxYTY3YTZmYTRlYTg0YzYxMTVjYWRmZTk3L25vZGVfbW9kdWxlcy9mYW1pbHkvbGliL2ZhbWlseS1hY2NvdW50cy1jb25uZWN0b3ItQkVXVjJzRkouanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJMO0FBQ3JKOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMERBQTBEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHVCQUF1QjtBQUM1RTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOztBQUUrVCIsInNvdXJjZXMiOlsiL1VzZXJzL2VsZW1lbi9zb2xpZGl0eS9zb2xpZGl0eS1uZXh0LWpzLXRlbXBsYXRlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9mYW1pbHlAMC4xLjNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV92aWVtQDIuMzcuNl9idWZmZXJ1dGlsQDQuMC45X3RfZjUzMzIzOTFhNjdhNmZhNGVhODRjNjExNWNhZGZlOTcvbm9kZV9tb2R1bGVzL2ZhbWlseS9saWIvZmFtaWx5LWFjY291bnRzLWNvbm5lY3Rvci1CRVdWMnNGSi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBZGRyZXNzLCBjcmVhdGVXYWxsZXRDbGllbnQsIGN1c3RvbSwgcHVibGljQWN0aW9ucywgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yLCBSZXNvdXJjZVVuYXZhaWxhYmxlUnBjRXJyb3IsIHdpdGhUaW1lb3V0LCB3aXRoUmV0cnksIFN3aXRjaENoYWluRXJyb3IsIG51bWJlclRvSGV4IH0gZnJvbSAndmllbSc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuXG5jb25zdCBpc1N0cmluZyA9IChpbnB1dCkgPT4ge1xuICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiO1xufTtcblxuY2xhc3MgQ2F1c2VkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNhdXNlO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnM/LmNhdXNlKSB7XG4gICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcbiAgICAgIHRoaXMubWVzc2FnZSA9IGAke3RoaXMubWVzc2FnZX1cbkNBVVNFOiAke3RoaXMuY2F1c2UubWVzc2FnZX1gO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNhdXNlLnN0YWNrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSAodGhpcy5zdGFjayA/PyBcIlwiKSArIFwiXFxuQ0FVU0U6IFwiICsgdGhpcy5jYXVzZS5zdGFjaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRGVmZXJyZWQge1xuICBwcm9taXNlO1xuICByZXNvbHZlO1xuICByZWplY3Q7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBkZWxheSA9IChtcykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuY29uc3QgbWludXRlc1RvTXMgPSAobWludXRlcykgPT4gbWludXRlcyAqIDZlNDtcbmNvbnN0IHNlY29uZHNUb01zID0gKHNlY29uZHMpID0+IHNlY29uZHMgKiAxZTM7XG5jb25zdCBtc1RvU2Vjb25kcyA9IChtcykgPT4gbXMgLyAxZTM7XG5cbmNsYXNzIEludmFyaWFudEVycm9yIGV4dGVuZHMgQ2F1c2VkRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoYEludmFyaWFudEVycm9yOiAke21lc3NhZ2V9YCwgb3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UsIGNhdXNlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKG1lc3NhZ2UsIHsgY2F1c2UgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXJyb3IoZXJyb3IpIHtcbiAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IoXG4gICAgICBgSW52YWxpZCBlcnJvciB0eXBlLiBSZWNlaXZlZCAke3R5cGVvZiBlcnJvcn0sIGV4cGVjdGVkIGluc3RhbmNlIG9mIEVycm9yYFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmV2ZXIobWVzc2FnZSwgb3B0aW9ucykge1xuICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IobWVzc2FnZSwgb3B0aW9ucyk7XG59XG5cbnZhciBTZXNzaW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChTZXNzaW9uU3RhdHVzKSB7XG4gICAgU2Vzc2lvblN0YXR1c1tcIkFVVEhFTlRJQ0FURURcIl0gPSBcIkFVVEhFTlRJQ0FURURcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1wiTk9UX0FVVEhFTlRJQ0FURURcIl0gPSBcIk5PVF9BVVRIRU5USUNBVEVEXCI7XG59KShTZXNzaW9uU3RhdHVzIHx8IChTZXNzaW9uU3RhdHVzID0ge30pKTtcblxudmFyIENvbW11bmljYXRpb25UeXBlcztcbihmdW5jdGlvbiAoQ29tbXVuaWNhdGlvblR5cGVzKSB7XG4gICAgLyoqXG4gICAgICogU2Vzc2lvblxuICAgICAqL1xuICAgIENvbW11bmljYXRpb25UeXBlc1tcInNlc3Npb25Jbml0XCJdID0gXCJzZXNzaW9uSW5pdFwiO1xuICAgIENvbW11bmljYXRpb25UeXBlc1tcInNlc3Npb25HZXRDdXJyZW50XCJdID0gXCJzZXNzaW9uR2V0Q3VycmVudFwiO1xuICAgIENvbW11bmljYXRpb25UeXBlc1tcInNlc3Npb25DbGVhclwiXSA9IFwic2Vzc2lvbkNsZWFyXCI7XG4gICAgLyoqXG4gICAgICogRXRoZXJldW1cbiAgICAgKi9cbiAgICBDb21tdW5pY2F0aW9uVHlwZXNbXCJldGhlcmV1bUpzb25ScGNSZXF1ZXN0XCJdID0gXCJldGhlcmV1bUpzb25ScGNSZXF1ZXN0XCI7XG4gICAgQ29tbXVuaWNhdGlvblR5cGVzW1wiZXRoZXJldW1Kc29uUnBjUmVxdWlyZXNBcHByb3ZhbFwiXSA9IFwiZXRoZXJldW1Kc29uUnBjUmVxdWlyZXNBcHByb3ZhbFwiO1xufSkoQ29tbXVuaWNhdGlvblR5cGVzIHx8IChDb21tdW5pY2F0aW9uVHlwZXMgPSB7fSkpO1xuXG52YXIgU3Vic2NyaXB0aW9uVHlwZXM7XG4oZnVuY3Rpb24gKFN1YnNjcmlwdGlvblR5cGVzKSB7XG4gICAgLyoqXG4gICAgICogU2Vzc2lvbiByZWxhdGVkXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uVHlwZXNbXCJzZXNzaW9uQ2hhbmdlZFwiXSA9IFwic2Vzc2lvbkNoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBOZXR3b3JrIHJlbGF0ZWRcbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb25UeXBlc1tcImV0aGVyZXVtTmV0d29ya0NoYW5nZWRcIl0gPSBcImV0aGVyZXVtTmV0d29ya0NoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBNb2RhbCByZWxhdGVkXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uVHlwZXNbXCJtb2RhbE9wZW5cIl0gPSBcIm1vZGFsT3BlblwiO1xuICAgIFN1YnNjcmlwdGlvblR5cGVzW1wibW9kYWxDbG9zZVwiXSA9IFwibW9kYWxDbG9zZVwiO1xuICAgIFN1YnNjcmlwdGlvblR5cGVzW1wibW9kYWxVcGRhdGVcIl0gPSBcIm1vZGFsVXBkYXRlXCI7XG59KShTdWJzY3JpcHRpb25UeXBlcyB8fCAoU3Vic2NyaXB0aW9uVHlwZXMgPSB7fSkpO1xuXG52YXIgUG9wdXBDb21tdW5pY2F0aW9uVHlwZXM7XG4oZnVuY3Rpb24gKFBvcHVwQ29tbXVuaWNhdGlvblR5cGVzKSB7XG4gICAgUG9wdXBDb21tdW5pY2F0aW9uVHlwZXNbXCJhdXRoU3RhcnRcIl0gPSBcImF1dGhTdGFydFwiO1xuICAgIFBvcHVwQ29tbXVuaWNhdGlvblR5cGVzW1wicnBjUmVxdWVzdFwiXSA9IFwicnBjUmVxdWVzdFwiO1xufSkoUG9wdXBDb21tdW5pY2F0aW9uVHlwZXMgfHwgKFBvcHVwQ29tbXVuaWNhdGlvblR5cGVzID0ge30pKTtcblxuY2xhc3MgU3RhdGUge1xuICAgIHN0YXRpYyBzZXRFeGVjdXRvcldpbmRvdyA9IChfd2luZG93KSA9PiB7XG4gICAgICAgIHdpbmRvdy5fX19fZmFfd3JhcHBlciA9IHtcbiAgICAgICAgICAgIHdpbmRvdzogX3dpbmRvdyxcbiAgICAgICAgICAgIG9yaWdpbjogd2luZG93Ll9fX19mYV93cmFwcGVyPy5vcmlnaW4sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBzdGF0aWMgZ2V0RXhlY3V0b3JXaW5kb3cgPSAoKSA9PiB7XG4gICAgICAgIGlmICghd2luZG93Ll9fX19mYV93cmFwcGVyPy53aW5kb3cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgY2FsbCBgY29ubmVjdGAgdG8gc3RhcnQgdXAgdGhlIHNkay13ZWItZWxlbWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2luZG93Ll9fX19mYV93cmFwcGVyLndpbmRvdztcbiAgICB9O1xuICAgIHN0YXRpYyBzZXRFeGVjdXRvck9yaWdpbiA9IChvcmlnaW4pID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB3aW5kb3cuX19fX2ZhX3dyYXBwZXI7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgaW5zdGFuY2Uub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5fX19fZmFfd3JhcHBlciA9IHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHdpbmRvdzogd2luZG93Ll9fX19mYV93cmFwcGVyPy53aW5kb3csXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBzdGF0aWMgZ2V0RXhlY3V0b3JPcmlnaW4gPSAoKSA9PiB7XG4gICAgICAgIGlmICghd2luZG93Ll9fX19mYV93cmFwcGVyPy5vcmlnaW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgY2FsbCBgY29ubmVjdGAgdG8gc3RhcnQgdXAgdGhlIHNkay13ZWItZWxlbWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2luZG93Ll9fX19mYV93cmFwcGVyLm9yaWdpbjtcbiAgICB9O1xufVxuXG5sZXQgcG9zdFJvYm90ID0gbnVsbDtcbi8qKlxuICogV2UgZG8gbm90IGltcG9ydCBgcG9zdC1yb2JvdGAgcmlnaHQgYXdheSBhcyBpdCB3b3VsZCBjYXVzZSBTU1IgaXNzdWVzIGdpdmVuIGBwb3N0LXJvYm90YCByZXF1aXJlcyBhY2Nlc3MgdG8gYHdpbmRvd2AgcmlnaHQgYXdheVxuICovXG5jb25zdCBpbml0UG9zdFJvYm90ID0gYXN5bmMgKCkgPT4ge1xuICAgIHBvc3RSb2JvdCA9IGF3YWl0IGltcG9ydCgnLi9pbmRleC1ERF9rbmREcy5qcycpLnRoZW4oZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4uaTsgfSk7XG59O1xuY29uc3QgZ2V0UG9zdFJvYm90ID0gKCkgPT4ge1xuICAgIGludmFyaWFudChwb3N0Um9ib3QsICdZb3UgbmVlZCB0byBpbml0IHBvc3Qgcm9ib3QgZmlyc3QnKTtcbiAgICByZXR1cm4gcG9zdFJvYm90O1xufTtcblxuY29uc3QgREVGQVVMVF9QUk9YWV9USU1FT1VUJDEgPSBtaW51dGVzVG9NcygxKTtcbmNvbnN0IHByb3h5ID0gYXN5bmMgKHJlcXVlc3QsIGNvbmZpZykgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwcm94eSBpbiBhIG5vbiBicm93c2VyIGVudmlyb25tZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gJ2RhdGEnIGluIHJlcXVlc3QgPyByZXF1ZXN0LmRhdGEgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCBnZXRQb3N0Um9ib3QoKS5zZW5kKFN0YXRlLmdldEV4ZWN1dG9yV2luZG93KCksIHJlcXVlc3QudHlwZSwgZGF0YSwge1xuICAgICAgICB0aW1lb3V0OiBjb25maWc/LnRpbWVvdXQgPz8gREVGQVVMVF9QUk9YWV9USU1FT1VUJDEsXG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50LmRhdGE7XG59O1xuY29uc3QgbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBTdWJzY3JpYmUgdG8gYSBzcGVjaWZpYyBldmVudFxuICogU3VwcG9ydHMgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc2FtZSBldmVudFxuICogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmFrZW5qcy9wb3N0LXJvYm90L2lzc3Vlcy80OFxuICovXG5jb25zdCBzdWJzY3JpYmUgPSAodHlwZSwgY2FsbGJhY2spID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3Vic2NyaWJlIGluIGEgbm9uIGJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lcnMuaGFzKHR5cGUpKSB7XG4gICAgICAgIGxpc3RlbmVycy5nZXQodHlwZSk/LmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gZ2V0UG9zdFJvYm90KCkub24odHlwZSwgeyB3aW5kb3c6IFN0YXRlLmdldEV4ZWN1dG9yV2luZG93KCkgfSwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZ2V0KHR5cGUpPy5jYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gYyhldmVudC5kYXRhKSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0ZW5lcnMuc2V0KHR5cGUsIHsgbGlzdGVuZXIsIGNhbGxiYWNrczogW2NhbGxiYWNrXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJJbmZvID0gbGlzdGVuZXJzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lckluZm8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdDYWxsYmFja3MgPSBsaXN0ZW5lckluZm8uY2FsbGJhY2tzLmZpbHRlcigoYykgPT4gYyAhPT0gY2FsbGJhY2spO1xuICAgICAgICBpZiAobmV3Q2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbGlzdGVuZXJJbmZvLmxpc3RlbmVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVySW5mby5jYWxsYmFja3MgPSBuZXdDYWxsYmFja3M7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgZ2V0TWFzdGVySWZyYW1lVXJsID0gKCkgPT4ge1xuICAgIHJldHVybiBTdGF0ZS5nZXRFeGVjdXRvck9yaWdpbigpICsgJy9pbmplY3RlZC9tYXN0ZXInO1xufTtcblxuY2xhc3MgSW50ZWdyYXRlZENsaWVudE1vZGFsQ29udHJvbGxlciB7XG4gICAgdW5zdWJzY3JpYmU7XG4gICAgYXV0b0hlaWdodCA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgaWZyYW1lKSB7XG4gICAgICAgIGNvbnN0IG1vZGFsT3BlblVuc3Vic2NyaWJlID0gc3Vic2NyaWJlKFN1YnNjcmlwdGlvblR5cGVzLm1vZGFsT3BlbiwgKHsgaGVpZ2h0IH0pID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2V0UHJvcGVydHkoJ292ZXJmbG93JywgJ2hpZGRlbicsICdpbXBvcnRhbnQnKTtcbiAgICAgICAgICAgIC8vIGF2b2lkIHNjcm9sbGJhciBqdW1waW5nIHdoZW4gaGlkZGVuIGlzIGFwcGxpZWRcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuc2V0UHJvcGVydHkoJ3BhZGRpbmctcmlnaHQnLCAnMTVweCcsICdpbXBvcnRhbnQnKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdmbGV4Jyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvSGVpZ2h0KVxuICAgICAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5zZXRQcm9wZXJ0eSgnaGVpZ2h0JywgaGVpZ2h0LnRvU3RyaW5nKCkgKyAncHgnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZGFsQ2xvc2VVbnN1YnNjcmliZSA9IHN1YnNjcmliZShTdWJzY3JpcHRpb25UeXBlcy5tb2RhbENsb3NlLCAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdvdmVyZmxvdycpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgncGFkZGluZy1yaWdodCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZGFsVXBkYXRlVW5zdWJzY3JpYmUgPSBzdWJzY3JpYmUoU3Vic2NyaXB0aW9uVHlwZXMubW9kYWxVcGRhdGUsICh7IGhlaWdodCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvSGVpZ2h0KVxuICAgICAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5zZXRQcm9wZXJ0eSgnaGVpZ2h0JywgaGVpZ2h0LnRvU3RyaW5nKCkgKyAncHgnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBtb2RhbE9wZW5VbnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgbW9kYWxDbG9zZVVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBtb2RhbFVwZGF0ZVVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG5cbmNvbnN0IElGUkFNRV9JRCA9ICdmYW1pbHktYWNjb3VudHMtbWFzdGVyLWlmcmFtZSc7XG5jb25zdCBDT05ORUNUSU9OX1RJTUVPVVQkMSA9IDIwMDAwO1xubGV0IG1vZGFsQ29udHJvbGxlciA9IG51bGw7XG5jb25zdCBjcmVhdGVFbGVtZW50cyA9ICh7IGZ1bGxzY3JlZW4gfSA9IHt9KSA9PiB7XG4gICAgaWYgKGZ1bGxzY3JlZW4pIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuaW5zZXQgPSAnMCc7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS56SW5kZXggPSAnMjE0NzQ4MzY0Nyc7XG4gICAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBpZnJhbWUuc3R5bGUuYWxsID0gJ2luaXRpYWwnO1xuICAgICAgICBpZnJhbWUuc3R5bGUuYm9yZGVyID0gJzAnO1xuICAgICAgICBpZnJhbWUuc3R5bGUubWFyZ2luID0gJzAnO1xuICAgICAgICBpZnJhbWUuc3R5bGUucGFkZGluZyA9ICcwJztcbiAgICAgICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgaWZyYW1lLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgaWZyYW1lLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgICAgIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgICBpZnJhbWUuc3R5bGUuYm9yZGVyUmFkaXVzID0gJzAnO1xuICAgICAgICBpZnJhbWUuaWQgPSBJRlJBTUVfSUQ7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBnZXRNYXN0ZXJJZnJhbWVVcmwoKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIHJldHVybiB7IGNvbnRhaW5lciwgaWZyYW1lIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5qdXN0aWZ5Q29udGVudCA9ICdjZW50ZXInO1xuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS56SW5kZXggPSAnMjE0NzQ4MzY0Nyc7XG4gICAgICAgIGNvbnN0IGJhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJhY2tkcm9wLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgYmFja2Ryb3Auc3R5bGUuaW5zZXQgPSAnMCc7XG4gICAgICAgIGJhY2tkcm9wLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDAuNSknO1xuICAgICAgICBiYWNrZHJvcC5zdHlsZS56SW5kZXggPSAnLTEnO1xuICAgICAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgaWZyYW1lLnN0eWxlLmJvcmRlclJhZGl1cyA9ICcxMHB4JztcbiAgICAgICAgaWZyYW1lLnN0eWxlLmJveFNoYWRvdyA9ICcwIDAgMTBweCAwIHJnYmEoMCwwLDAsMC41KSc7XG4gICAgICAgIGlmcmFtZS5pZCA9IElGUkFNRV9JRDtcbiAgICAgICAgaWZyYW1lLnNyYyA9IGdldE1hc3RlcklmcmFtZVVybCgpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYmFja2Ryb3ApO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgcmV0dXJuIHsgY29udGFpbmVyLCBpZnJhbWUgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBJbmplY3RzIHRoZSBzZGstd2ViLWV4ZWN1dG9yIHNvIHRoZSBzZGstd2ViLWVsZW1lbnRzIGNhbiBjYWxsIHRoZSB3ZWItZWxlbWVudHNcbiAqL1xuY29uc3QgY29ubmVjdCA9ICh7IGVudmlyb25tZW50IH0pID0+IHtcbiAgICBjb25zdCBjb25uZWN0ZWQgPSBpc0Nvbm5lY3RlZCgpO1xuICAgIC8vIGRvIG5vdGhpbmcgaWYgYWxyZWFkeSBjb25uZWN0ZWRcbiAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgZnVsZmlsbGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGlmIGl0IHRha2VzIGxvbmdlciB0aGVuIENPTk5FQ1RJT05fVElNRU9VVCBzZWNvbmRzIGVycm9yIVxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBmdWxmaWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVqZWN0KGBUaGUgc2RrLXdlYi1lbGVtZW50cyBmYWlsZWQgdG8gY29ubmVjdCB3aXRoaW4gJHttc1RvU2Vjb25kcyhDT05ORUNUSU9OX1RJTUVPVVQkMSl9IHNlY29uZHMsIHBsZWFzZSBjb250YWN0IHN1cHBvcnQuYCk7XG4gICAgICAgIH0sIENPTk5FQ1RJT05fVElNRU9VVCQxKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gZW52aXJvbm1lbnQud2ViRWxlbWVudHNBcHBVcmw7XG4gICAgICAgIFN0YXRlLnNldEV4ZWN1dG9yT3JpZ2luKG9yaWdpbik7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyLCBpZnJhbWUgfSA9IGNyZWF0ZUVsZW1lbnRzKHtcbiAgICAgICAgICAgIGZ1bGxzY3JlZW46IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bGZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgU3RhdGUuc2V0RXhlY3V0b3JXaW5kb3coaWZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgICAgICAgbW9kYWxDb250cm9sbGVyID0gbmV3IEludGVncmF0ZWRDbGllbnRNb2RhbENvbnRyb2xsZXIoY29udGFpbmVyLCBpZnJhbWUpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGluaXQgcG9zdC1yb2JvdCBiZWZvcmUgYXBwZW5kaW5nIGlmcmFtZVxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgbGlzdGVuZXJzIGFyZSBwcm9wZXJseSBzZXR1cFxuICAgICAgICB2b2lkIGluaXRQb3N0Um9ib3QoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuY29uc3QgaXNDb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgY29uc3QgY29ubmVjdG9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoSUZSQU1FX0lEKTtcbiAgICByZXR1cm4gISFjb25uZWN0b3IgJiYgISFtb2RhbENvbnRyb2xsZXI7XG59O1xuLyoqXG4gKiBSZW1vdmVzIHRoZSBpbmplY3RlZCBzZGstd2ViLWV4ZWN1dG9yXG4gKi9cbmNvbnN0IGRpc2Nvbm5lY3QgPSAoKSA9PiB7XG4gICAgY29uc3QgY29ubmVjdGVkID0gaXNDb25uZWN0ZWQoKTtcbiAgICAvLyBkbyBub3RoaW5nIGlmIG5vdCBjb25uZWN0ZWRcbiAgICBpZiAoIWNvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3RvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKElGUkFNRV9JRCk7XG4gICAgaW52YXJpYW50KGNvbm5lY3RvciwgJ1RoZSBjb25uZWN0b3IgaXMgbm90IGRlZmluZWQnKTtcbiAgICBpbnZhcmlhbnQobW9kYWxDb250cm9sbGVyLCAnVGhlIG1vZGFsIGNvbnRyb2xsZXIgaXMgbm90IGRlZmluZWQnKTtcbiAgICBtb2RhbENvbnRyb2xsZXIuZGlzY29ubmVjdCgpO1xuICAgIGNvbm5lY3Rvci5yZW1vdmUoKTtcbn07XG5cbmNvbnN0IERFVklDRV9MT0NBTF9TVE9SQUdFX0tFWSA9ICdmYW1pbHlfYWNjb3VudHNfX2RldmljZV9pZCc7XG5jb25zdCBnZXREZXZpY2VJZCA9ICgpID0+IGxvY2FsU3RvcmFnZS5nZXRJdGVtKERFVklDRV9MT0NBTF9TVE9SQUdFX0tFWSk7XG5jb25zdCBzZXREZXZpY2VJZCA9IChkZXZpY2VJZCkgPT4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oREVWSUNFX0xPQ0FMX1NUT1JBR0VfS0VZLCBkZXZpY2VJZCk7XG5jb25zdCBTRVNTSU9OX0tFWV9MT0NBTF9TVE9SQUdFX0tFWSA9ICdmYW1pbHlfYWNjb3VudHNfX3Nlc3Npb25fa2V5JztcbmNvbnN0IGdldFNlc3Npb25LZXkgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNFU1NJT05fS0VZX0xPQ0FMX1NUT1JBR0VfS0VZKTtcbn07XG5jb25zdCBzZXRTZXNzaW9uS2V5ID0gKHNlc3Npb25LZXkpID0+IHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oU0VTU0lPTl9LRVlfTE9DQUxfU1RPUkFHRV9LRVksIHNlc3Npb25LZXkpO1xufTtcbmNvbnN0IHJlbW92ZVNlc3Npb25LZXkgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNFU1NJT05fS0VZX0xPQ0FMX1NUT1JBR0VfS0VZKTtcbn07XG5cbmNvbnN0IHByb2R1Y3Rpb24gPSB7XG4gICAgbmFtZTogJ3Byb2R1Y3Rpb24nLFxuICAgIHdlYkVsZW1lbnRzQXBwVXJsOiAnaHR0cHM6Ly9hcHAuZmFtaWx5LmNvJyxcbn07XG5cbmNvbnN0IERFRkFVTFRfUFJPWFlfVElNRU9VVCA9IG1pbnV0ZXNUb01zKDEpO1xuY29uc3QgY2FsY3VsYXRlUG9wdXBQb3NpdGlvbiA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IHdpbmRvdy5zY3JlZW5YICsgKHdpbmRvdy5vdXRlcldpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICBjb25zdCB0b3AgPSB3aW5kb3cuc2NyZWVuWSArICh3aW5kb3cub3V0ZXJIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3AsXG4gICAgfTtcbn07XG5jb25zdCBnZXRQb3B1cFNpemUgPSAoc2l6ZSkgPT4ge1xuICAgIHN3aXRjaCAoc2l6ZSkge1xuICAgICAgICBjYXNlIFBvcHVwU2l6ZS5NRURJVU06XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiA0NDQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1ODYsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFBvcHVwU2l6ZS5JTkhFUklURUQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cub3V0ZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5vdXRlckhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgfVxufTtcbnZhciBQb3B1cFNpemU7XG4oZnVuY3Rpb24gKFBvcHVwU2l6ZSkge1xuICAgIFBvcHVwU2l6ZVtcIk1FRElVTVwiXSA9IFwiTUVESVVNXCI7XG4gICAgUG9wdXBTaXplW1wiSU5IRVJJVEVEXCJdID0gXCJJTkhFUklURURcIjtcbn0pKFBvcHVwU2l6ZSB8fCAoUG9wdXBTaXplID0ge30pKTtcbmNvbnN0IG9wZW5Qb3B1cCA9ICh1cmwsIG5hbWUsIHNpemUgPSBQb3B1cFNpemUuTUVESVVNKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBnZXRQb3B1cFNpemUoc2l6ZSk7XG4gICAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IGNhbGN1bGF0ZVBvcHVwUG9zaXRpb24od2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGB3aWR0aD0ke3dpZHRofSxoZWlnaHQ9JHtoZWlnaHR9LGxlZnQ9JHtsZWZ0fSx0b3A9JHt0b3B9LG1lbnViYXI9bm8sdG9vbGJhcj1ubyxsb2NhdGlvbj1ubyxzdGF0dXM9bm9gO1xuICAgIHJldHVybiB3aW5kb3cub3Blbih1cmwsIG5hbWUsIG9wdGlvbnMpO1xufTtcbmNvbnN0IHByb3h5UG9wdXAgPSBhc3luYyAocG9wdXAsIHJlcXVlc3QsIGNvbmZpZykgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSAnZGF0YScgaW4gcmVxdWVzdCA/IHJlcXVlc3QuZGF0YSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBldmVudCA9IGF3YWl0IGdldFBvc3RSb2JvdCgpLnNlbmQocG9wdXAsIHJlcXVlc3QudHlwZSwgZGF0YSwge1xuICAgICAgICB0aW1lb3V0OiBjb25maWc/LnRpbWVvdXQgPz8gREVGQVVMVF9QUk9YWV9USU1FT1VULFxuICAgIH0pO1xuICAgIHJldHVybiBldmVudC5kYXRhO1xufTtcblxubGV0IGNvbm5lY3Rpb25DaGFuZ2VMaXN0ZW5lcnMgPSBbXTtcbnZhciBTZGtTdGF0dXM7XG4oZnVuY3Rpb24gKFNka1N0YXR1cykge1xuICAgIFNka1N0YXR1c1tTZGtTdGF0dXNbXCJESVNDT05ORUNURURcIl0gPSAwXSA9IFwiRElTQ09OTkVDVEVEXCI7XG4gICAgU2RrU3RhdHVzW1Nka1N0YXR1c1tcIkNPTk5FQ1RJTkdcIl0gPSAxXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIFNka1N0YXR1c1tTZGtTdGF0dXNbXCJDT05ORUNURURcIl0gPSAyXSA9IFwiQ09OTkVDVEVEXCI7XG59KShTZGtTdGF0dXMgfHwgKFNka1N0YXR1cyA9IHt9KSk7XG5sZXQgc2RrU3RhdHVzID0gU2RrU3RhdHVzLkRJU0NPTk5FQ1RFRDtcbmNvbnN0IHJlcXVpcmVDb25uZWN0ZWRTZGsgPSAoKSA9PiB7XG4gICAgaWYgKHNka1N0YXR1cyAhPT0gU2RrU3RhdHVzLkNPTk5FQ1RFRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbWlseSBBY2NvdW50cyBpcyBub3QgY29ubmVjdGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBGYW1pbHlBY2NvdW50c1Nkay5jb25uZWN0KCkgZmlyc3QuJyk7XG4gICAgfVxufTtcbnZhciBTZXNzaW9uQ3JlYXRlUmVzdWx0O1xuKGZ1bmN0aW9uIChTZXNzaW9uQ3JlYXRlUmVzdWx0KSB7XG4gICAgLyoqXG4gICAgICogVXNlciBzdWNjZXNzZnVsbHkgYXV0aGVudGljYXRlZFxuICAgICAqL1xuICAgIFNlc3Npb25DcmVhdGVSZXN1bHRbXCJTVUNDRVNTXCJdID0gXCJTVUNDRVNTXCI7XG4gICAgLyoqXG4gICAgICogVXNlciBjYW5jZWxsZWQgcG9wdXAgYnkgY2xvc2luZyBpdCBvciBieSB0aW1lb3V0XG4gICAgICovXG4gICAgU2Vzc2lvbkNyZWF0ZVJlc3VsdFtcIlVTRVJfQ0FOQ0VMTEVEXCJdID0gXCJVU0VSX0NBTkNFTExFRFwiO1xuICAgIC8qKlxuICAgICAqIFBvcHVwIHdhcyBibG9ja2VkIGJ5IHRoZSBicm93c2VyXG4gICAgICovXG4gICAgU2Vzc2lvbkNyZWF0ZVJlc3VsdFtcIkJST1dTRVJfQkxPQ0tFRFwiXSA9IFwiQlJPV1NFUl9CTE9DS0VEXCI7XG59KShTZXNzaW9uQ3JlYXRlUmVzdWx0IHx8IChTZXNzaW9uQ3JlYXRlUmVzdWx0ID0ge30pKTtcbmNvbnN0IEZhbWlseUFjY291bnRzU2RrID0ge1xuICAgIGFzeW5jIGNvbm5lY3QoY29uZmlnID0geyBlbnZpcm9ubWVudDogcHJvZHVjdGlvbiB9KSB7XG4gICAgICAgIGlmIChzZGtTdGF0dXMgPT09IFNka1N0YXR1cy5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFtaWx5IEFjY291bnRzIGlzIGFscmVhZHkgY29ubmVjdGVkLiBEbyBub3QgY2FsbCBGYW1pbHlBY2NvdW50c1Nkay5jb25uZWN0KCkgbW9yZSB0aGFuIG9uY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNka1N0YXR1cyA9PT0gU2RrU3RhdHVzLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFtaWx5IEFjY291bnRzIGlzIGFscmVhZHkgY29ubmVjdGluZy4gRG8gbm90IGNhbGwgRmFtaWx5QWNjb3VudHNTZGsuY29ubmVjdCgpIG1vcmUgdGhhbiBvbmNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHNka1N0YXR1cyA9IFNka1N0YXR1cy5DT05ORUNUSU5HO1xuICAgICAgICBhd2FpdCBjb25uZWN0KGNvbmZpZyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi5pbml0KCk7XG4gICAgICAgIHNka1N0YXR1cyA9IFNka1N0YXR1cy5DT05ORUNURUQ7XG4gICAgICAgIGNvbm5lY3Rpb25DaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHRydWUpKTtcbiAgICB9LFxuICAgIGlzQ29ubmVjdGVkOiAoKSA9PiBzZGtTdGF0dXMgPT09IFNka1N0YXR1cy5DT05ORUNURUQsXG4gICAgaXNDb25uZWN0aW5nOiAoKSA9PiBzZGtTdGF0dXMgPT09IFNka1N0YXR1cy5DT05ORUNUSU5HLFxuICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmIChzZGtTdGF0dXMgIT09IFNka1N0YXR1cy5DT05ORUNURUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFtaWx5IGFjY291bnRzIGlzIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5nZXRDdXJyZW50KCk7XG4gICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbi5zdGF0dXMgPT09IFNlc3Npb25TdGF0dXMuQVVUSEVOVElDQVRFRCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXNzaW9uLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzY29ubmVjdCgpO1xuICAgICAgICBzZGtTdGF0dXMgPSBTZGtTdGF0dXMuRElTQ09OTkVDVEVEO1xuICAgICAgICBjb25uZWN0aW9uQ2hhbmdlTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihmYWxzZSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSxcbiAgICBvbkNvbm5lY3Rpb25DaGFuZ2U6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25uZWN0aW9uQ2hhbmdlTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29ubmVjdGlvbkNoYW5nZUxpc3RlbmVycyA9IGNvbm5lY3Rpb25DaGFuZ2VMaXN0ZW5lcnMuZmlsdGVyKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNlc3Npb246IHtcbiAgICAgICAgY3JlYXRlOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXF1aXJlQ29ubmVjdGVkU2RrKCk7XG4gICAgICAgICAgICBjb25zdCBwb3B1cCA9IG9wZW5Qb3B1cChgJHtTdGF0ZS5nZXRFeGVjdXRvck9yaWdpbigpfS9wb3B1cC9hdXRoYCwgJ0ZhbWlseUFjY291bnRzQXV0aGVudGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghcG9wdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFNlc3Npb25DcmVhdGVSZXN1bHQuQlJPV1NFUl9CTE9DS0VELFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJveHlQb3B1cChwb3B1cCwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBQb3B1cENvbW11bmljYXRpb25UeXBlcy5hdXRoU3RhcnQsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiBwb3B1cCBoYXMgb3duIHRpbWVvdXQsIHRoaXMgaXMgcHVyZWx5IHRvIGtlZXAgdGhlIGV2ZW50IGFsaXZlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG1pbnV0ZXNUb01zKDEwKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXRTZXNzaW9uS2V5KHJlc3BvbnNlLmNsaWVudFNlc3Npb25LZXkpO1xuICAgICAgICAgICAgICAgIHNldERldmljZUlkKHJlc3BvbnNlLmRldmljZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFNlc3Npb25DcmVhdGVSZXN1bHQuU1VDQ0VTUyxcbiAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQ6IHJlc3BvbnNlLmRldmljZUlkLFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRTZXNzaW9uS2V5OiByZXNwb25zZS5jbGllbnRTZXNzaW9uS2V5LFxuICAgICAgICAgICAgICAgICAgICBpZFRva2VuOiByZXNwb25zZS5pZFRva2VuLFxuICAgICAgICAgICAgICAgICAgICB3YWxsZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlc3BvbnNlLndhbGxldC5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgLy8gcXVpdGUgbGlrZWx5IGEgdGltZW91dCwgd2luZG93IHdhcyBjbG9zZWQgb3IgdXNlciByZWplY3RlZCBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBTZXNzaW9uQ3JlYXRlUmVzdWx0LlVTRVJfQ0FOQ0VMTEVELFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBgaW5pdGAgZnJvbSB0aGUgcHVibGljIEFQSVxuICAgICAgICBpbml0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXZpY2VJZCA9IGdldERldmljZUlkKCk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRTZXNzaW9uS2V5ID0gZ2V0U2Vzc2lvbktleSgpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3h5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDb21tdW5pY2F0aW9uVHlwZXMuc2Vzc2lvbkluaXQsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50U2Vzc2lvbktleSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEN1cnJlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVpcmVDb25uZWN0ZWRTZGsoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm94eSh7XG4gICAgICAgICAgICAgICAgdHlwZTogQ29tbXVuaWNhdGlvblR5cGVzLnNlc3Npb25HZXRDdXJyZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlOiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHJlcXVpcmVDb25uZWN0ZWRTZGsoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmUoU3Vic2NyaXB0aW9uVHlwZXMuc2Vzc2lvbkNoYW5nZWQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6ICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVpcmVDb25uZWN0ZWRTZGsoKTtcbiAgICAgICAgICAgIHJlbW92ZVNlc3Npb25LZXkoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm94eSh7XG4gICAgICAgICAgICAgICAgdHlwZTogQ29tbXVuaWNhdGlvblR5cGVzLnNlc3Npb25DbGVhcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgZXRoZXJldW06IHtcbiAgICAgICAgb25OZXR3b3JrQ2hhbmdlOiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHJlcXVpcmVDb25uZWN0ZWRTZGsoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmUoU3Vic2NyaXB0aW9uVHlwZXMuZXRoZXJldW1OZXR3b3JrQ2hhbmdlZCwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgIH0sXG59O1xuXG5jb25zdCBpc0ludGVyc2VjdGlvbk9ic2VydmVyVjJTdXBwb3J0ZWQgPSAoKSA9PiAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeScgaW4gd2luZG93ICYmICdpc1Zpc2libGUnIGluIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkucHJvdG90eXBlO1xuXG4vLyBBIGxpc3Qgb2YgbWV0aG9kcyB0aGF0IHBvdGVudGlhbGx5IHJlcXVpcmUgdXNlciBhcHByb3ZhbFxuLy8gSWYgaXQncyBhIHdlbGwga25vd24gbWV0aG9kIHdlIGNhbiBoYW5kbGUgd2l0aG91dCB1c2VyIGFwcHJvdmFsXG4vLyBCdXQgdG8gbWVldCBTYWZhcmkgcmVxdWlyZW1lbnRzIHdlIG5lZWQgdG8gZ2V0IHRoZSBmaXJzdCBkZWNpc2lvbiBwb2ludCBpbiBhIG5vbi1ibG9ja2luZyB3YXlcbi8vIE1ha2Ugc3VyZSBpdCdzIGluIHN5bmMgd2l0aCBgQVBQUk9WQUxfUkVRVUlSRURfTUVUSE9EU2AgZnJvbSBgSnNvblJwY1NlcnZpY2VgXG5jb25zdCBQT1RFTlRJQUxMWV9BUFBST1ZBTF9SRVFVSVJFRF9NRVRIT0RTID0gW1xuICAgICdwZXJzb25hbF9zaWduJyxcbiAgICAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gICAgJ2V0aF9zaWduVHlwZWREYXRhX3Y0JyxcbiAgICAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICdmYW1pbHlfc3dpdGNoQWNjb3VudHMnLFxuXTtcbmNsYXNzIFJwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvZGU7XG4gICAgbWVzc2FnZTtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBzdGF0aWMgdXNlclJlamVjdGVkUmVxdWVzdChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnBjRXJyb3IoNDAwMSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXRpYyB1bmF1dGhvcml6ZWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJwY0Vycm9yKDQxMDAsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNsYXNzIExvY2FsUnBjSGFuZGxlciB7XG4gICAgYXJncztcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmFyZ3MubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlICdldGhfcmVxdWVzdEFjY291bnRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXF1ZXN0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBuZXZlcignVW5zdXBwb3J0ZWQgbWV0aG9kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmVxdWVzdEFjY291bnRzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IEZhbWlseUFjY291bnRzU2RrLnNlc3Npb24uZ2V0Q3VycmVudCgpO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RhdHVzID09PSBTZXNzaW9uU3RhdHVzLkFVVEhFTlRJQ0FURUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3Nlc3Npb24ud2FsbGV0LmFkZHJlc3NdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3JlYXRlZFNlc3Npb24gPSBhd2FpdCBGYW1pbHlBY2NvdW50c1Nkay5zZXNzaW9uLmNyZWF0ZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChjcmVhdGVkU2Vzc2lvbi5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNlc3Npb25DcmVhdGVSZXN1bHQuU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVkU2Vzc2lvbi53YWxsZXQuYWRkcmVzc107XG4gICAgICAgICAgICAgICAgY2FzZSBTZXNzaW9uQ3JlYXRlUmVzdWx0LkJST1dTRVJfQkxPQ0tFRDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUnBjRXJyb3IudXNlclJlamVjdGVkUmVxdWVzdCgnQnJvd3NlciBibG9ja2VkIEZhbWlseSBBY2NvdW50cyBhdXRoZW50aWNhdGlvbiBwb3B1cCcpO1xuICAgICAgICAgICAgICAgIGNhc2UgU2Vzc2lvbkNyZWF0ZVJlc3VsdC5VU0VSX0NBTkNFTExFRDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUnBjRXJyb3IudXNlclJlamVjdGVkUmVxdWVzdCgnVXNlciBjYW5jZWxsZWQgYXV0aGVudGljYXRpb24gcmVxdWVzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGVycm9yIGFscmVhZHkgbG9va3MgbGlrZSBhIHJwYyBlcnJvciB0aGVuIHRocm93IGl0XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAnY29kZScgaW4gZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1vc3QgbGlrZWx5IGNhbid0IGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgUnBjRXJyb3IudXNlclJlamVjdGVkUmVxdWVzdCgnVW5rbm93biByZWFzb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIE1hc3RlcklmcmFtZVJwY0hhbmRsZXIge1xuICAgIGFyZ3M7XG4gICAgLy8gVGhlIGRlZmF1bHQgcG9zdCBtZXNzYWdlIHRpbWVvdXQgaXMgMTAgc2Vjb25kc1xuICAgIERFRkFVTFRfUlBDX0NBTExfVElNRU9VVCA9IHNlY29uZHNUb01zKDEwKTtcbiAgICBERUZBVUxUX1JQQ19TSUdOX1RJTUVPVVQgPSBtaW51dGVzVG9NcygxMCk7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBQT1RFTlRJQUxMWV9BUFBST1ZBTF9SRVFVSVJFRF9NRVRIT0RTLmluY2x1ZGVzKHRoaXMuYXJncy5tZXRob2QpXG4gICAgICAgICAgICA/IC8vIGlmIGl0cyBzZW5kaW5nIGEgdHJhbnNhY3Rpb24gbWFrZSB0aGUgdGltZW91dCB2ZXJ5XG4gICAgICAgICAgICAgICAgLy8gbG9uZyBhcyB0aGV5IG1heSBnZXQgYSBhcHByb3ZhbCBtb2RhbCBkaXNwbGF5ZWRcbiAgICAgICAgICAgICAgICAvLyBhbmQgaWYgc28gaGF2ZSBhIGBmb3JldmVyYCB0aW1lIHRvIGFwcHJvdmFsIGl0XG4gICAgICAgICAgICAgICAgdGhpcy5ERUZBVUxUX1JQQ19TSUdOX1RJTUVPVVRcbiAgICAgICAgICAgIDogdGhpcy5ERUZBVUxUX1JQQ19DQUxMX1RJTUVPVVQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm94eSh7XG4gICAgICAgICAgICAgICAgdHlwZTogQ29tbXVuaWNhdGlvblR5cGVzLmV0aGVyZXVtSnNvblJwY1JlcXVlc3QsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5hcmdzLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGludmFyaWFudChyZXN1bHQgIT09IHVuZGVmaW5lZCwgJ1RoZSBKU09OIFJQQyByZXN1bHQgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZXJyb3IgYWxyZWFkeSBsb29rcyBsaWtlIGEgcnBjIGVycm9yIHRoZW4gdGhyb3cgaXRcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgY2FuJ3QgaGFwcGVuXG4gICAgICAgICAgICB0aHJvdyBScGNFcnJvci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCdVbmtub3duIHJlYXNvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGhhbmRsZXIgZm9yIHJwYyByZXF1ZXN0IGluIGNhc2UgaW50ZXJzZWN0aW9uIG9ic2VydmVyIGlzIG5vdCBzdXBwb3J0ZWRcbiAqIE5vdGU6IEl0J3MgYnVpbGQgaW4gYSB3YXkgdG8gd29yayB3aXRoIHNhZmFyaSBwb3B1cCBibG9ja2VyIGluIG1pbmQgd2hlcmUgcG9wdXBzIGFyZSBibG9ja2VkIGlmIHRoZXkgYXJlIGhhcHBlbiBpbiBhIFByb21pc2VcbiAqL1xuY2xhc3MgUG9wdXBNb2RhbFJwY0hhbmRsZXIge1xuICAgIGFyZ3M7XG4gICAgLy8gaWYgaXQgdGFrZXMgbG9uZ2VyIHRvIGRldGVjdCBpZiBhcHByb3ZhbCBpcyByZXF1aXJlZCAoZS5nLiBzaW11bGF0aW9uIHRpbWUgaW50ZW5zaXZlKVxuICAgIC8vIHdlIHdvdWxkIHRoZW4gdHJlYXQgaXQgYXMgYXBwcm92YWwgcmVxdWlyZWQgdG8gbm90IGJsb2NrIHRoZSBVSVxuICAgIEFQUFJPVkFMX1JFUVVJUkVEX1RJTUVPVVQgPSAzMDA7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBoYW5kbGUoKSB7XG4gICAgICAgIGxldCByZXF1ZXN0UmVxdWlyZXNBcHByb3ZhbCA9IG51bGw7XG4gICAgICAgIC8vIG5vdGU6IGNhbid0IHVzZSBhc3luYy9hd2FpdCBoZXJlIGFzIHdpbGwgYmxvY2sgcG9wdXAgbW9kYWwgb24gU2FmYXJpXG4gICAgICAgIHZvaWQgcmVxdWlyZXNVc2VyQXBwcm92YWwodGhpcy5hcmdzKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3RSZXF1aXJlc0FwcHJvdmFsID0gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgLy8gbm90ZTogc2V0IHRpbWVvdXQgaXMgYWxsb3dlZCBieSBTYWZhcmkgdG8gb3BlbiBwb3B1cHNcbiAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyB1c2VyIGFwcHJvdmFsIGlzIG5vdCByZXF1aXJlZCBzbyB3ZSBjYW4gaGFuZGxlIGl0IGluIHRoZSBtYXN0ZXIgaWZyYW1lXG4gICAgICAgICAgICBpZiAocmVxdWVzdFJlcXVpcmVzQXBwcm92YWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbmV3IE1hc3RlcklmcmFtZVJwY0hhbmRsZXIodGhpcy5hcmdzKS5oYW5kbGUoKS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9wdXAgPSBvcGVuUG9wdXAoYCR7U3RhdGUuZ2V0RXhlY3V0b3JPcmlnaW4oKX0vcG9wdXAvcnBjYCwgJ0ZhbWlseUFjY291bnRzUnBjJywgUG9wdXBTaXplLklOSEVSSVRFRCk7XG4gICAgICAgICAgICBpZiAoIXBvcHVwKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KFJwY0Vycm9yLnVzZXJSZWplY3RlZFJlcXVlc3QoJ1BvcHVwIGJsb2NrZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xpZW50U2Vzc2lvbktleSA9IGdldFNlc3Npb25LZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGRldmljZUlkID0gZ2V0RGV2aWNlSWQoKTtcbiAgICAgICAgICAgIGlmICghY2xpZW50U2Vzc2lvbktleSB8fCAhZGV2aWNlSWQpIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoUnBjRXJyb3IudW5hdXRob3JpemVkKCdVc2VyIG5vdCBhdXRob3JpemVkJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJveHlQb3B1cChwb3B1cCwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBQb3B1cENvbW11bmljYXRpb25UeXBlcy5ycGNSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRTZXNzaW9uS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiBwb3B1cCBoYXMgb3duIHRpbWVvdXQsIHRoaXMgaXMgcHVyZWx5IHRvIGtlZXAgdGhlIGV2ZW50IGFsaXZlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IG1pbnV0ZXNUb01zKDEwKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVycm9yIGFscmVhZHkgbG9va3MgbGlrZSBhIHJwYyBlcnJvciB0aGVuIHRocm93IGl0XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcXVpdGUgbGlrZWx5IGEgdGltZW91dCwgd2luZG93IHdhcyBjbG9zZWQgb3IgdXNlciByZWplY3RlZCBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KFJwY0Vycm9yLnVzZXJSZWplY3RlZFJlcXVlc3QoJ1BvcHVwIHdhcyBjbG9zZWQgYnkgdGhlIHVzZXInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuQVBQUk9WQUxfUkVRVUlSRURfVElNRU9VVCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbn1cbmNvbnN0IHJlcXVpcmVzVXNlckFwcHJvdmFsID0gYXN5bmMgKGFyZ3MpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJveHkoe1xuICAgICAgICAgICAgdHlwZTogQ29tbXVuaWNhdGlvblR5cGVzLmV0aGVyZXVtSnNvblJwY1JlcXVpcmVzQXBwcm92YWwsXG4gICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIGlmIHRoZSBlcnJvciBhbHJlYWR5IGxvb2tzIGxpa2UgYSBycGMgZXJyb3IgdGhlbiB0aHJvdyBpdFxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAnY29kZScgaW4gZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vc3QgbGlrZWx5IGNhbid0IGhhcHBlblxuICAgICAgICB0aHJvdyBScGNFcnJvci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCdVbmtub3duIHJlYXNvbicpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRScGNSZXF1ZXN0SGFuZGxlcihhcmdzKSB7XG4gICAgaWYgKGFyZ3MubWV0aG9kID09PSAnZXRoX3JlcXVlc3RBY2NvdW50cycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbFJwY0hhbmRsZXIoYXJncyk7XG4gICAgfVxuICAgIGlmIChpc0ludGVyc2VjdGlvbk9ic2VydmVyVjJTdXBwb3J0ZWQoKSkge1xuICAgICAgICAvLyBub3RlOiBtYXN0ZXIgaWZyYW1lIHdpbGwgcmVqZWN0IHJlcXVlc3RzIGlmIGludGVyc2VjdGlvbiBvYnNlcnZlciBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybiBuZXcgTWFzdGVySWZyYW1lUnBjSGFuZGxlcihhcmdzKTtcbiAgICB9XG4gICAgaWYgKCFQT1RFTlRJQUxMWV9BUFBST1ZBTF9SRVFVSVJFRF9NRVRIT0RTLmluY2x1ZGVzKGFyZ3MubWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gbmV3IE1hc3RlcklmcmFtZVJwY0hhbmRsZXIoYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9wdXBNb2RhbFJwY0hhbmRsZXIoYXJncyk7XG59XG5cbmNvbnN0IENPTk5FQ1RJT05fVElNRU9VVCA9IHNlY29uZHNUb01zKDUpO1xuY2xhc3MgRXRoZXJldW1Qcm92aWRlckNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdFSVAxMTkzIHByb3ZpZGVyIGNvbm5lY3Rpb24gdGltZW91dC4gTWFrZSBzdXJlIHRvIGNhbGwgYEZhbWlseUFjY291bnRzU2RrLmNvbm5lY3QoKWAgYmVmb3JlIHVzaW5nIHRoZSBwcm92aWRlci4nKTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgZm9sbG93cyB0aGUgRUlQIC0gaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkzXG4gKi9cbmNsYXNzIEV0aGVyZXVtUHJvdmlkZXIge1xuICAgIF9ldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgX2FjY291bnRzQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuICAgIF9uZXR3b3JrQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuICAgIF9jb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IG51bGw7XG4gICAgX2Rpc2Nvbm5lY3RVbnN1YnNjcmlwdGlvbkNhbGxiYWNrID0gbnVsbDtcbiAgICBfY29uZmlnO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gb3B0aW9ucztcbiAgICB9XG4gICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZz8uZGVidWcpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlciBpcyBjb25uZWN0ZWQgYW5kIHJlYWR5IHRvIHByb2Nlc3MgcmVxdWVzdHNcbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIEZhbWlseUFjY291bnRzU2RrLmlzQ29ubmVjdGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpTT05SUEMgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBhcmdzIFRoZSByZXF1ZXN0IGFyZ3VtZW50c1xuICAgICAqL1xuICAgIC8vIHJldHVybiB0eXBlIGlzIGxvb3NlIGFzIHdlIGRvbid0IHdhbnQgdG8gdHlwZSBhbGwgdGhlIHBvc3NpYmxlIHJldHVybiB0eXBlcyBnaXZlbiBpdCdzIGEgcHJveHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIHJlcXVlc3QoYXJncykge1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JDb25uZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVyID0gZ2V0UnBjUmVxdWVzdEhhbmRsZXIoe1xuICAgICAgICAgICAgbWV0aG9kOiBhcmdzLm1ldGhvZCxcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBwYXJhbXMgdG8gYmUgYW4gYXJyYXlcbiAgICAgICAgICAgIHBhcmFtczogQXJyYXkuaXNBcnJheShhcmdzLnBhcmFtcykgPyBhcmdzLnBhcmFtcyA6IFthcmdzLnBhcmFtc10sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVxdWVzdEhhbmRsZXIuaGFuZGxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpTT05SUEMgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIHJlcXVlc3QganNvbnJwYyBtZXRob2RcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGByZXF1ZXN0YCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7IG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGlzdGVuZXIpIHtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgc3VwcG9ydCBgbWVzc2FnZWAgZXZlbnRcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZygnb24nLCBldmVudE5hbWUpO1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSA9PT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdhY2NvdW50c0NoYW5nZWQnOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc3Vic2NyaWJlVG9BY2NvdW50Q2hhbmdlRXZlbnQoKS5jYXRjaCgoLi4uYXJncykgPT4gdGhpcy5sb2coJ2FjY291bnRzQ2hhbmdlZCcsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hhaW5DaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLnN1YnNjcmliZVRvTmV0d29ya0NoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc3Vic2NyaWJlVG9Db25uZWN0RXZlbnQoKS5jYXRjaCgoLi4uYXJncykgPT4gdGhpcy5sb2coJ2Nvbm5lY3QnLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc3Vic2NyaWJlVG9EaXNjb25uZWN0RXZlbnQoKS5jYXRjaCgoLi4uYXJncykgPT4gdGhpcy5sb2coJ2Rpc2Nvbm5lY3QnLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgcHJvdmlkZXIgZXZlbnQgZW1pdHRlcnNcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsYmFja1xuICAgICAqL1xuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBsaXN0ZW5lcikge1xuICAgICAgICAvLyB3ZSBkb24ndCBzdXBwb3J0IGBtZXNzYWdlYCBldmVudFxuICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnbWVzc2FnZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkgPT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWNjb3VudHNDaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLnVuc3Vic2NyaWJlRnJvbUFjY291bnRDaGFuZ2VFdmVudCgpLmNhdGNoKCguLi5hcmdzKSA9PiB0aGlzLmxvZygnYWNjb3VudHNDaGFuZ2VkJywgYXJncykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjaGFpbkNoYW5nZWQnOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMudW5zdWJzY3JpYmVGcm9tTmV0d29ya0NoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMudW5zdWJzY3JpYmVGcm9tQ29ubmVjdEV2ZW50KCkuY2F0Y2goKC4uLmFyZ3MpID0+IHRoaXMubG9nKCdjb25uZWN0JywgYXJncykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLnVuc3Vic2NyaWJlRnJvbURpc2Nvbm5lY3RFdmVudCgpLmNhdGNoKCguLi5hcmdzKSA9PiB0aGlzLmxvZygnZGlzY29ubmVjdCcsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN1YnNjcmliZVRvTmV0d29ya0NoYW5nZUV2ZW50KCkge1xuICAgICAgICBpbnZhcmlhbnQoIXRoaXMuX25ldHdvcmtDaGFuZ2VkVW5zdWJzY3JpcHRpb25DYWxsYmFjaywgJ0FscmVhZHkgc3Vic2NyaWJlZCB0byBuZXR3b3JrIGNoYW5nZSBldmVudCcpO1xuICAgICAgICB0aGlzLl9uZXR3b3JrQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2sgPSBGYW1pbHlBY2NvdW50c1Nkay5ldGhlcmV1bS5vbk5ldHdvcmtDaGFuZ2UoKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZW1pdCgnY2hhaW5DaGFuZ2VkJywgbmV3VmFsdWUuY2hhaW5JZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZUZyb21OZXR3b3JrQ2hhbmdlRXZlbnQoKSB7XG4gICAgICAgIGludmFyaWFudCh0aGlzLl9uZXR3b3JrQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2ssICdOb3Qgc3Vic2NyaWJlZCB0byBuZXR3b3JrIGNoYW5nZSBldmVudCcpO1xuICAgICAgICB0aGlzLl9uZXR3b3JrQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5fbmV0d29ya0NoYW5nZWRVbnN1YnNjcmlwdGlvbkNhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgc3Vic2NyaWJlVG9BY2NvdW50Q2hhbmdlRXZlbnQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2FpdEZvckNvbm5lY3Rpb24oKTtcbiAgICAgICAgaW52YXJpYW50KCF0aGlzLl9hY2NvdW50c0NoYW5nZWRVbnN1YnNjcmlwdGlvbkNhbGxiYWNrLCAnQWxyZWFkeSBzdWJzY3JpYmVkIHRvIGFjY291bnQgY2hhbmdlIGV2ZW50Jyk7XG4gICAgICAgIGxldCBwcmV2Q29ubmVjdGVkQWNjb3VudCA9IG51bGw7XG4gICAgICAgIC8vIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uIGlzc3VlcyB3aXRoIGltbWVkaWF0ZSB1bnN1YnNjcmliaW5nIHdlIHNob3VsZCBub3Qgd2FpdCBmb3Igc2Vzc2lvbiBwcm9taXNlIGFuZCBpbW1lZGlhdGVseSBhdHRhY2ggbGlzdGVuZXJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZXJlIGlzIGEgc2hvcnQgYW1vdW50IG9mIHRpbWUgd2hlbiBgdGhpcy5fYWNjb3VudHNDaGFuZ2VkVW5zdWJzY3JpcHRpb25DYWxsYmFja2AgaXMgbm90IGFzc2lnbmVkIGJ1dCBgdW5zdWJzY3JpYmVGcm9tQWNjb3VudENoYW5nZUV2ZW50YCBjYWxsZWRcbiAgICAgICAgdm9pZCBGYW1pbHlBY2NvdW50c1Nkay5zZXNzaW9uLmdldEN1cnJlbnQoKS50aGVuKChjdXJyZW50U2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgcHJldkNvbm5lY3RlZEFjY291bnQgPVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnN0YXR1cyA9PT0gU2Vzc2lvblN0YXR1cy5BVVRIRU5USUNBVEVEXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudFNlc3Npb24ud2FsbGV0LmFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYWNjb3VudHNDaGFuZ2VkVW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IEZhbWlseUFjY291bnRzU2RrLnNlc3Npb24ub25DaGFuZ2UoKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb25uZWN0ZWRBY2NvdW50ID0gbmV3VmFsdWUuc3RhdHVzID09PSBTZXNzaW9uU3RhdHVzLkFVVEhFTlRJQ0FURUQgPyBuZXdWYWx1ZS53YWxsZXQuYWRkcmVzcyA6IG51bGw7XG4gICAgICAgICAgICAvLyBzZXNzaW9uIGNoYW5nZSBhZmZlY3RzIG1vcmUgdGhhbiBqdXN0IHRoZSBhY2NvdW50XG4gICAgICAgICAgICAvLyBPTkxZIGVtaXQgdGhlIGV2ZW50IGlmIHRoZSBhY2NvdW50IGNoYW5nZXNcbiAgICAgICAgICAgIGlmIChwcmV2Q29ubmVjdGVkQWNjb3VudCAhPT0gbmV3Q29ubmVjdGVkQWNjb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50RW1pdHRlci5lbWl0KCdhY2NvdW50c0NoYW5nZWQnLCBuZXdDb25uZWN0ZWRBY2NvdW50ID09PSBudWxsID8gW10gOiBbbmV3Q29ubmVjdGVkQWNjb3VudF0pO1xuICAgICAgICAgICAgICAgIHByZXZDb25uZWN0ZWRBY2NvdW50ID0gbmV3Q29ubmVjdGVkQWNjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVuc3Vic2NyaWJlRnJvbUFjY291bnRDaGFuZ2VFdmVudCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yQ29ubmVjdGlvbigpO1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5fYWNjb3VudHNDaGFuZ2VkVW5zdWJzY3JpcHRpb25DYWxsYmFjaywgJ05vdCBzdWJzY3JpYmVkIHRvIGFjY291bnQgY2hhbmdlIGV2ZW50Jyk7XG4gICAgICAgIHRoaXMuX2FjY291bnRzQ2hhbmdlZFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5fYWNjb3VudHNDaGFuZ2VkVW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZVRvQ29ubmVjdEV2ZW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JDb25uZWN0aW9uKCk7XG4gICAgICAgIGludmFyaWFudCghdGhpcy5fY29ubmVjdFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2ssICdBbHJlYWR5IHN1YnNjcmliZWQgdG8gY29ubmVjdCBldmVudCcpO1xuICAgICAgICB0aGlzLl9jb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IEZhbWlseUFjY291bnRzU2RrLm9uQ29ubmVjdGlvbkNoYW5nZShhc3luYyAoaXNDb25uZWN0ZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2NoYWluSWQnIH0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcoY2hhaW5JZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW52YWxpZCBjaGFpbklkXG4gICAgICAgICAgICAgICAgaW52YXJpYW50KGlzU3RyaW5nKGNoYWluSWQpLCAnSW52YWxpZCBjaGFpbklkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVyLmVtaXQoJ2Nvbm5lY3QnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1bnN1YnNjcmliZUZyb21Db25uZWN0RXZlbnQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMud2FpdEZvckNvbm5lY3Rpb24oKTtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuX2Nvbm5lY3RVbnN1YnNjcmlwdGlvbkNhbGxiYWNrLCAnTm90IHN1YnNjcmliZWQgdG8gY29ubmVjdCBldmVudCcpO1xuICAgICAgICB0aGlzLl9jb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjaygpO1xuICAgICAgICB0aGlzLl9jb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZVRvRGlzY29ubmVjdEV2ZW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JDb25uZWN0aW9uKCk7XG4gICAgICAgIGludmFyaWFudCghdGhpcy5fZGlzY29ubmVjdFVuc3Vic2NyaXB0aW9uQ2FsbGJhY2ssICdBbHJlYWR5IHN1YnNjcmliZWQgdG8gZGlzY29ubmVjdCBldmVudCcpO1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IEZhbWlseUFjY291bnRzU2RrLm9uQ29ubmVjdGlvbkNoYW5nZSgoaXNDb25uZWN0ZWQpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIuZW1pdCgnZGlzY29ubmVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmVGcm9tRGlzY29ubmVjdEV2ZW50KCkge1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JDb25uZWN0aW9uKCk7XG4gICAgICAgIGludmFyaWFudCh0aGlzLl9kaXNjb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjaywgJ05vdCBzdWJzY3JpYmVkIHRvIGFjY291bnQgZGlzY29ubmVjdCBldmVudCcpO1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjaygpO1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0VW5zdWJzY3JpcHRpb25DYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXQgZm9yIHRoZSBwcm92aWRlciB0byBiZSBjb25uZWN0ZWRcbiAgICAgKiBUaGlzIGlzIGRvbmUgdG8gbWFrZSBwcm92aWRlciBjb21wYXRpYmxlIHdpdGggYHdhZ21pYCBgaW5qZWN0ZWRgIGNvbm5lY3RvciB0aGF0IHRyaWVzIHRvIGF0dGFjaCBldmVudHMgYmVmb3JlIHRoZSBwcm92aWRlciBpcyBjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKEZhbWlseUFjY291bnRzU2RrLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZGsgaXMgY29ubmVjdGluZywgd2FpdCBmb3IgaXQgdG8gZmluaXNoXG4gICAgICAgIGlmIChGYW1pbHlBY2NvdW50c1Nkay5pc0Nvbm5lY3RpbmcoKSkge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gRmFtaWx5QWNjb3VudHNTZGsub25Db25uZWN0aW9uQ2hhbmdlKChpc0Nvbm5lY3RlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHRpbWVvdXQgfSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZS50aGVuKCgpID0+ICh7IHRpbWVvdXQ6IGZhbHNlIH0pKSxcbiAgICAgICAgICAgICAgICBkZWxheShDT05ORUNUSU9OX1RJTUVPVVQpLnRoZW4oKCkgPT4gKHsgdGltZW91dDogdHJ1ZSB9KSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdGhlcmV1bVByb3ZpZGVyQ29ubmVjdGlvblRpbWVvdXRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdGltZW91dCB9ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIEZhbWlseUFjY291bnRzU2RrLmNvbm5lY3QodGhpcy5fY29uZmlnPy5vcHRpb25zKS50aGVuKCgpID0+ICh7IHRpbWVvdXQ6IGZhbHNlIH0pKSxcbiAgICAgICAgICAgIGRlbGF5KENPTk5FQ1RJT05fVElNRU9VVCkudGhlbigoKSA9PiAoeyB0aW1lb3V0OiB0cnVlIH0pKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXRoZXJldW1Qcm92aWRlckNvbm5lY3Rpb25UaW1lb3V0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgZmFtaWx5QWNjb3VudHNDdXN0b21BY3Rpb25zID0gKGNsaWVudCkgPT4gKHtcbiAgICBnZXRJZFRva2VuOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTZXNzaW9uID0gYXdhaXQgRmFtaWx5QWNjb3VudHNTZGsuc2Vzc2lvbi5nZXRDdXJyZW50KCk7XG4gICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbi5zdGF0dXMgIT09IFNlc3Npb25TdGF0dXMuQVVUSEVOVElDQVRFRCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTZXNzaW9uLmlkVG9rZW47XG4gICAgfSxcbiAgICBzd2l0Y2hBY2NvdW50czogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7IG1ldGhvZDogJ2ZhbWlseV9zd2l0Y2hBY2NvdW50cycsIHBhcmFtczogW10gfSwgeyByZXRyeUNvdW50OiAwIH0pO1xuICAgICAgICByZXR1cm4gYWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gZ2V0QWRkcmVzcyhhZGRyZXNzKSk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9yZXZva2VQZXJtaXNzaW9ucycsXG4gICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGV0aF9hY2NvdW50czoge30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sIHsgcmV0cnlDb3VudDogMCB9KTtcbiAgICB9LFxufSk7XG5jb25zdCBjcmVhdGVGYW1pbHlBY2NvdW50c0NsaWVudCA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGF3YWl0IEZhbWlseUFjY291bnRzU2RrLnNlc3Npb24uZ2V0Q3VycmVudCgpO1xuICAgIGludmFyaWFudChjdXJyZW50U2Vzc2lvbi5zdGF0dXMgPT09IFNlc3Npb25TdGF0dXMuQVVUSEVOVElDQVRFRCwgJ0FjY291bnQgbXVzdCBiZSBjb25uZWN0ZWQgdG8gY3JlYXRlIGEgRmFtaWx5IEFjY291bnRzIGNsaWVudC4nKTtcbiAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVXYWxsZXRDbGllbnQoe1xuICAgICAgICBhY2NvdW50OiBjdXJyZW50U2Vzc2lvbi53YWxsZXQuYWRkcmVzcyxcbiAgICAgICAgdHJhbnNwb3J0OiBjdXN0b20obmV3IEV0aGVyZXVtUHJvdmlkZXIoKSksXG4gICAgfSlcbiAgICAgICAgLmV4dGVuZChwdWJsaWNBY3Rpb25zKVxuICAgICAgICAuZXh0ZW5kKGZhbWlseUFjY291bnRzQ3VzdG9tQWN0aW9ucyk7XG4gICAgcmV0dXJuIGNsaWVudDtcbn07XG5cbmNvbnN0IHZlcnNpb24kMSA9ICcyLjE2LjUnO1xuXG5jb25zdCBnZXRWZXJzaW9uID0gKCkgPT4gYEB3YWdtaS9jb3JlQCR7dmVyc2lvbiQxfWA7XG5cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQmFzZUVycm9yX2luc3RhbmNlcywgX0Jhc2VFcnJvcl93YWxrO1xuY2xhc3MgQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGdldCBkb2NzQmFzZVVybCgpIHtcbiAgICAgICAgcmV0dXJuICdodHRwczovL3dhZ21pLnNoL2NvcmUnO1xuICAgIH1cbiAgICBnZXQgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFZlcnNpb24oKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2hvcnRNZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgX0Jhc2VFcnJvcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXRhaWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NQYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFNZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG9ydE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1dhZ21pQ29yZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3JcbiAgICAgICAgICAgID8gb3B0aW9ucy5jYXVzZS5kZXRhaWxzXG4gICAgICAgICAgICA6IG9wdGlvbnMuY2F1c2U/Lm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuY2F1c2UubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5kZXRhaWxzO1xuICAgICAgICBjb25zdCBkb2NzUGF0aCA9IG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3JcbiAgICAgICAgICAgID8gb3B0aW9ucy5jYXVzZS5kb2NzUGF0aCB8fCBvcHRpb25zLmRvY3NQYXRoXG4gICAgICAgICAgICA6IG9wdGlvbnMuZG9jc1BhdGg7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IFtcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQuJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubWV0YU1lc3NhZ2VzID8gWy4uLm9wdGlvbnMubWV0YU1lc3NhZ2VzLCAnJ10gOiBbXSksXG4gICAgICAgICAgICAuLi4oZG9jc1BhdGhcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgYERvY3M6ICR7dGhpcy5kb2NzQmFzZVVybH0ke2RvY3NQYXRofS5odG1sJHtvcHRpb25zLmRvY3NTbHVnID8gYCMke29wdGlvbnMuZG9jc1NsdWd9YCA6ICcnfWAsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgLi4uKGRldGFpbHMgPyBbYERldGFpbHM6ICR7ZGV0YWlsc31gXSA6IFtdKSxcbiAgICAgICAgICAgIGBWZXJzaW9uOiAke3RoaXMudmVyc2lvbn1gLFxuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSlcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zLmNhdXNlO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg7XG4gICAgICAgIHRoaXMubWV0YU1lc3NhZ2VzID0gb3B0aW9ucy5tZXRhTWVzc2FnZXM7XG4gICAgICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICAgIH1cbiAgICB3YWxrKGZuKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlRXJyb3JfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VFcnJvcl93YWxrKS5jYWxsKHRoaXMsIHRoaXMsIGZuKTtcbiAgICB9XG59XG5fQmFzZUVycm9yX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9CYXNlRXJyb3Jfd2FsayA9IGZ1bmN0aW9uIF9CYXNlRXJyb3Jfd2FsayhlcnIsIGZuKSB7XG4gICAgaWYgKGZuPy4oZXJyKSlcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICBpZiAoZXJyLmNhdXNlKVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZUVycm9yX2luc3RhbmNlcywgXCJtXCIsIF9CYXNlRXJyb3Jfd2FsaykuY2FsbCh0aGlzLCBlcnIuY2F1c2UsIGZuKTtcbiAgICByZXR1cm4gZXJyO1xufTtcblxuY2xhc3MgQ2hhaW5Ob3RDb25maWd1cmVkRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQ2hhaW4gbm90IGNvbmZpZ3VyZWQuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDaGFpbk5vdENvbmZpZ3VyZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBQcm92aWRlck5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignUHJvdmlkZXIgbm90IGZvdW5kLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHJvdmlkZXJOb3RGb3VuZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3RvcihjcmVhdGVDb25uZWN0b3JGbikge1xuICAgIHJldHVybiBjcmVhdGVDb25uZWN0b3JGbjtcbn1cblxuaW5qZWN0ZWQudHlwZSA9ICdpbmplY3RlZCc7XG5mdW5jdGlvbiBpbmplY3RlZChwYXJhbWV0ZXJzID0ge30pIHtcbiAgICBjb25zdCB7IHNoaW1EaXNjb25uZWN0ID0gdHJ1ZSwgdW5zdGFibGVfc2hpbUFzeW5jSW5qZWN0IH0gPSBwYXJhbWV0ZXJzO1xuICAgIGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcGFyYW1ldGVycy50YXJnZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLih0YXJnZXRNYXBbdGFyZ2V0XSA/PyB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke3RhcmdldFswXS50b1VwcGVyQ2FzZSgpfSR7dGFyZ2V0LnNsaWNlKDEpfWAsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBgaXMke3RhcmdldFswXS50b1VwcGVyQ2FzZSgpfSR7dGFyZ2V0LnNsaWNlKDEpfWAsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6ICdpbmplY3RlZCcsXG4gICAgICAgICAgICBuYW1lOiAnSW5qZWN0ZWQnLFxuICAgICAgICAgICAgcHJvdmlkZXIod2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdz8uZXRoZXJldW07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgYWNjb3VudHNDaGFuZ2VkO1xuICAgIGxldCBjaGFpbkNoYW5nZWQ7XG4gICAgbGV0IGNvbm5lY3Q7XG4gICAgbGV0IGRpc2Nvbm5lY3Q7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbm5lY3RvcigoY29uZmlnKSA9PiAoe1xuICAgICAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUYXJnZXQoKS5pY29uO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGFyZ2V0KCkuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBuYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRhcmdldCgpLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBnZXQgc3VwcG9ydHNTaW11bGF0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IGluamVjdGVkLnR5cGUsXG4gICAgICAgIGFzeW5jIHNldHVwKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHN0YXJ0IGxpc3RlbmluZyBmb3IgZXZlbnRzIGlmIGB0YXJnZXRgIGlzIHNldCwgb3RoZXJ3aXNlIGBpbmplY3RlZCgpYCB3aWxsIGFsc28gcmVjZWl2ZSBldmVudHNcbiAgICAgICAgICAgIGlmIChwcm92aWRlcj8ub24gJiYgcGFyYW1ldGVycy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdCA9IHRoaXMub25Db25uZWN0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZG4ndCBuZWVkIHRvIGxpc3RlbiBmb3IgYCdhY2NvdW50c0NoYW5nZWQnYCBoZXJlIHNpbmNlIHRoZSBgJ2Nvbm5lY3QnYCBldmVudCBzaG91bGQgc3VmZmljZSAoYW5kIHdhbGxldCBzaG91bGRuJ3QgYmUgY29ubmVjdGVkIHlldCkuXG4gICAgICAgICAgICAgICAgLy8gU29tZSB3YWxsZXRzLCBsaWtlIE1ldGFNYXNrLCBkbyBub3QgaW1wbGVtZW50IHRoZSBgJ2Nvbm5lY3QnYCBldmVudCBhbmQgb3ZlcmxvYWQgYCdhY2NvdW50c0NoYW5nZWQnYCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHRoaXMub25BY2NvdW50c0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2FjY291bnRzQ2hhbmdlZCcsIGFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBjb25uZWN0KHsgY2hhaW5JZCwgaXNSZWNvbm5lY3RpbmcgfSA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyTm90Rm91bmRFcnJvcigpO1xuICAgICAgICAgICAgbGV0IGFjY291bnRzID0gW107XG4gICAgICAgICAgICBpZiAoaXNSZWNvbm5lY3RpbmcpXG4gICAgICAgICAgICAgICAgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzKCkuY2F0Y2goKCkgPT4gW10pO1xuICAgICAgICAgICAgZWxzZSBpZiAoc2hpbURpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHNob3cgYW5vdGhlciBwcm9tcHQgZm9yIHNlbGVjdGluZyBhY2NvdW50IGlmIGBzaGltRGlzY29ubmVjdGAgZmxhZyBpcyBlbmFibGVkXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbeyBldGhfYWNjb3VudHM6IHt9IH1dLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHMgPSBwZXJtaXNzaW9uc1swXT8uY2F2ZWF0cz8uWzBdPy52YWx1ZT8ubWFwKCh4KSA9PiBnZXRBZGRyZXNzKHgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYCd3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zJ2AgY2FuIHJldHVybiBhIGRpZmZlcmVudCBvcmRlciBvZiBhY2NvdW50cyB0aGFuIGAnZXRoX2FjY291bnRzJ2BcbiAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIHRvIGAnZXRoX2FjY291bnRzJ2Agb3JkZXJpbmcgaWYgbW9yZSB0aGFuIG9uZSBhY2NvdW50IGlzIGNvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2V2bS93YWdtaS9pc3N1ZXMvNDE0MFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkQWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50cyA9IHNvcnRlZEFjY291bnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhbGwgaW5qZWN0ZWQgcHJvdmlkZXJzIHN1cHBvcnQgYHdhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnNgIChlLmcuIE1ldGFNYXNrIGlPUykuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYnViYmxlIHVwIGVycm9yIGlmIHVzZXIgcmVqZWN0cyByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAvLyBPciBwcm9tcHQgaXMgYWxyZWFkeSBvcGVuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBSZXNvdXJjZVVuYXZhaWxhYmxlUnBjRXJyb3IuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50cz8ubGVuZ3RoICYmICFpc1JlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRBY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50cyA9IHJlcXVlc3RlZEFjY291bnRzLm1hcCgoeCkgPT4gZ2V0QWRkcmVzcyh4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1hbmFnZSBFSVAtMTE5MyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTMjZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCBjb25uZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFhY2NvdW50c0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNDaGFuZ2VkID0gdGhpcy5vbkFjY291bnRzQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignYWNjb3VudHNDaGFuZ2VkJywgYWNjb3VudHNDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5DaGFuZ2VkID0gdGhpcy5vbkNoYWluQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignZGlzY29ubmVjdCcsIGRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTd2l0Y2ggdG8gY2hhaW4gaWYgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudENoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCAmJiBjdXJyZW50Q2hhaW5JZCAhPT0gY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFpbiA9IGF3YWl0IHRoaXMuc3dpdGNoQ2hhaW4oeyBjaGFpbklkIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvci5jb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IGN1cnJlbnRDaGFpbklkIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhaW5JZCA9IGNoYWluPy5pZCA/PyBjdXJyZW50Q2hhaW5JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGRpc2Nvbm5lY3RlZCBzaGltIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChzaGltRGlzY29ubmVjdClcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29uZmlnLnN0b3JhZ2U/LnJlbW92ZUl0ZW0oYCR7dGhpcy5pZH0uZGlzY29ubmVjdGVkYCk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGNvbm5lY3RlZCBzaGltIGlmIG5vIHRhcmdldCBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtZXRlcnMudGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb25maWcuc3RvcmFnZT8uc2V0SXRlbSgnaW5qZWN0ZWQuY29ubmVjdGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgYWNjb3VudHMsIGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvci5jb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gUmVzb3VyY2VVbmF2YWlsYWJsZVJwY0Vycm9yLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXNvdXJjZVVuYXZhaWxhYmxlUnBjRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgICAgIC8vIE1hbmFnZSBFSVAtMTE5MyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcignY2hhaW5DaGFuZ2VkJywgY2hhaW5DaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICBjaGFpbkNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdkaXNjb25uZWN0JywgZGlzY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgZGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QgPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLm9uKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHBlcmltZW50YWwgc3VwcG9ydCBmb3IgTWV0YU1hc2sgZGlzY29ubmVjdFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWltcHJvdmVtZW50LXByb3Bvc2Fscy9ibG9iL21haW4vTUlQcy9taXAtMi5tZFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBBZGRpbmcgdGltZW91dCBhcyBub3QgYWxsIHdhbGxldHMgc3VwcG9ydCB0aGlzIG1ldGhvZCBhbmQgY2FuIGhhbmdcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2V2bS93YWdtaS9pc3N1ZXMvNDA2NFxuICAgICAgICAgICAgICAgIGF3YWl0IHdpdGhUaW1lb3V0KCgpID0+IFxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBleHBsaWNpdCB0eXBlIGZvciB2aWVtQDNcbiAgICAgICAgICAgICAgICBwcm92aWRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYCd3YWxsZXRfcmV2b2tlUGVybWlzc2lvbnMnYCBhZGRlZCBpbiBgdmllbUAyLjEwLjNgXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9yZXZva2VQZXJtaXNzaW9ucycsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogW3sgZXRoX2FjY291bnRzOiB7fSB9XSxcbiAgICAgICAgICAgICAgICB9KSwgeyB0aW1lb3V0OiAxMDAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7IH1cbiAgICAgICAgICAgIC8vIEFkZCBzaGltIHNpZ25hbGxpbmcgY29ubmVjdG9yIGlzIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgaWYgKHNoaW1EaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29uZmlnLnN0b3JhZ2U/LnNldEl0ZW0oYCR7dGhpcy5pZH0uZGlzY29ubmVjdGVkYCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmFtZXRlcnMudGFyZ2V0KVxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbmZpZy5zdG9yYWdlPy5yZW1vdmVJdGVtKCdpbmplY3RlZC5jb25uZWN0ZWQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmICghcHJvdmlkZXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyTm90Rm91bmRFcnJvcigpO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2FjY291bnRzJyB9KTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoKHgpID0+IGdldEFkZHJlc3MoeCkpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRDaGFpbklkKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IGhleENoYWluSWQgPSBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX2NoYWluSWQnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihoZXhDaGFpbklkKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0UHJvdmlkZXIoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQucHJvdmlkZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB0YXJnZXQucHJvdmlkZXIod2luZG93KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQucHJvdmlkZXIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gZmluZFByb3ZpZGVyKHdpbmRvdywgdGFyZ2V0LnByb3ZpZGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IHRhcmdldC5wcm92aWRlcjtcbiAgICAgICAgICAgIC8vIFNvbWUgd2FsbGV0cyBkbyBub3QgY29uZm9ybSB0byBFSVAtMTE5MyAoZS5nLiBUcnVzdCBXYWxsZXQpXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2V2bS93YWdtaS9pc3N1ZXMvMzUyNiNpc3N1ZWNvbW1lbnQtMTkxMjY4MzAwMlxuICAgICAgICAgICAgaWYgKHByb3ZpZGVyICYmICFwcm92aWRlci5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB1c2luZyBgb2ZmYCBoYW5kbGVyIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIG5vb3BcbiAgICAgICAgICAgICAgICBpZiAoJ29mZicgaW4gcHJvdmlkZXIgJiYgdHlwZW9mIHByb3ZpZGVyLm9mZiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub2ZmO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiB7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGlzQXV0aG9yaXplZCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEaXNjb25uZWN0ZWQgPSBzaGltRGlzY29ubmVjdCAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzaGltIGV4aXN0cyBpbiBzdG9yYWdlLCBjb25uZWN0b3IgaXMgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIChhd2FpdCBjb25maWcuc3RvcmFnZT8uZ2V0SXRlbShgJHt0aGlzLmlkfS5kaXNjb25uZWN0ZWRgKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGlzY29ubmVjdGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgaW5qZWN0ZWQgY29ubmVjdG9yIHRvIGNvbm5lY3QgaWYgbm8gdGFyZ2V0IGlzIHNldCBhbmQgaXQgaGFzbid0IGFscmVhZHkgY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgLy8gKGUuZy4gZmxhZyBpbiBzdG9yYWdlIGlzIG5vdCBzZXQpLiBUaGlzIHByZXZlbnRzIGEgdGFyZ2V0bGVzcyBpbmplY3RlZCBjb25uZWN0b3IgZnJvbSBjb25uZWN0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSB3aGVuZXZlciB0aGVyZSBpcyBhIHRhcmdldGVkIGNvbm5lY3RvciBjb25maWd1cmVkLlxuICAgICAgICAgICAgICAgIGlmICghcGFyYW1ldGVycy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGVkID0gYXdhaXQgY29uZmlnLnN0b3JhZ2U/LmdldEl0ZW0oJ2luamVjdGVkLmNvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3RlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5zdGFibGVfc2hpbUFzeW5jSW5qZWN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NoaW1Bc3luY0luamVjdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIHByb3ZpZGVyIGlzIGZvdW5kLCBjaGVjayBmb3IgYXN5bmMgaW5qZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2V2bS9yZWZlcmVuY2VzL2lzc3Vlcy8xNjdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9kZXRlY3QtcHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUV0aGVyZXVtID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2V0aGVyZXVtI2luaXRpYWxpemVkJywgaGFuZGxlRXRoZXJldW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0eXBlb2YgdW5zdGFibGVfc2hpbUFzeW5jSW5qZWN0ID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdW5zdGFibGVfc2hpbUFzeW5jSW5qZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAxXzAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdldGhlcmV1bSNpbml0aWFsaXplZCcsICgpID0+IHJlc29sdmUoaGFuZGxlRXRoZXJldW0oKSksIHsgb25jZTogdHJ1ZSB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShoYW5kbGVFdGhlcmV1bSgpKSwgdGltZW91dCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQcm92aWRlck5vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXNlIHJldHJ5IHN0cmF0ZWd5IGFzIHNvbWUgaW5qZWN0ZWQgd2FsbGV0cyAoZS5nLiBNZXRhTWFzaykgZmFpbCB0b1xuICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmUgSlNPTi1SUEMgcmVxdWVzdHMgb24gcGFnZSBsb2FkLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgd2l0aFJldHJ5KCgpID0+IHRoaXMuZ2V0QWNjb3VudHMoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhYWNjb3VudHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgc3dpdGNoQ2hhaW4oeyBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLCBjaGFpbklkIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgdGhpcy5nZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUHJvdmlkZXJOb3RGb3VuZEVycm9yKCk7XG4gICAgICAgICAgICBjb25zdCBjaGFpbiA9IGNvbmZpZy5jaGFpbnMuZmluZCgoeCkgPT4geC5pZCA9PT0gY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoIWNoYWluKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTd2l0Y2hDaGFpbkVycm9yKG5ldyBDaGFpbk5vdENvbmZpZ3VyZWRFcnJvcigpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnY2hhaW5JZCcgaW4gZGF0YSAmJiBkYXRhLmNoYWluSWQgPT09IGNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLm9mZignY2hhbmdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIub24oJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IG51bWJlclRvSGV4KGNoYWluSWQpIH1dLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRHVyaW5nIGAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nYCwgTWV0YU1hc2sgbWFrZXMgYSBgJ25ldF92ZXJzaW9uJ2AgUlBDIGNhbGwgdG8gdGhlIHRhcmdldCBjaGFpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgcmVxdWVzdCBmYWlscywgTWV0YU1hc2sgZG9lcyBub3QgZW1pdCB0aGUgYCdjaGFpbkNoYW5nZWQnYCBldmVudCwgYnV0IHdpbGwgc3RpbGwgc3dpdGNoIHRoZSBjaGFpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGNvdW50ZXIgdGhpcyBiZWhhdmlvciwgd2UgcmVxdWVzdCBhbmQgZW1pdCB0aGUgY3VycmVudCBjaGFpbiBJRCB0byBjb25maXJtIHRoZSBjaGFpbiBzd2l0Y2ggZWl0aGVyIHZpYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjYWxsYmFjayBvciBhbiBleHRlcm5hbGx5IGVtaXR0ZWQgYCdjaGFpbkNoYW5nZWQnYCBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1leHRlbnNpb24vaXNzdWVzLzI0MjQ3XG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFpbklkID09PSBjaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHsgY2hhaW5JZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIC8vIEluZGljYXRlcyBjaGFpbiBpcyBub3QgYWRkZWQgdG8gcHJvdmlkZXJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gNDkwMiB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBVbndyYXBwaW5nIGZvciBNZXRhTWFzayBNb2JpbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLW1vYmlsZS9pc3N1ZXMvMjk0NCNpc3N1ZWNvbW1lbnQtOTc2OTg4NzE5XG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/LmRhdGE/Lm9yaWdpbmFsRXJyb3I/LmNvZGUgPT09IDQ5MDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVmYXVsdDogYmxvY2tFeHBsb3JlciwgLi4uYmxvY2tFeHBsb3JlcnMgfSA9IGNoYWluLmJsb2NrRXhwbG9yZXJzID8/IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrRXhwbG9yZXJVcmxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXI/LmJsb2NrRXhwbG9yZXJVcmxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzID0gYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlci5ibG9ja0V4cGxvcmVyVXJscztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrRXhwbG9yZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tFeHBsb3JlclVybHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXIudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5PYmplY3QudmFsdWVzKGJsb2NrRXhwbG9yZXJzKS5tYXAoKHgpID0+IHgudXJsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJwY1VybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8ucnBjVXJscz8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJwY1VybHMgPSBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyLnJwY1VybHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyA9IFtjaGFpbi5ycGNVcmxzLmRlZmF1bHQ/Lmh0dHBbMF0gPz8gJyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkRXRoZXJldW1DaGFpbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBudW1iZXJUb0hleChjaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbk5hbWU6IGFkZEV0aGVyZXVtQ2hhaW5QYXJhbWV0ZXI/LmNoYWluTmFtZSA/PyBjaGFpbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25VcmxzOiBhZGRFdGhlcmV1bUNoYWluUGFyYW1ldGVyPy5pY29uVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeTogYWRkRXRoZXJldW1DaGFpblBhcmFtZXRlcj8ubmF0aXZlQ3VycmVuY3kgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4ubmF0aXZlQ3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnBjVXJscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW2FkZEV0aGVyZXVtQ2hhaW5dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENoYWluSWQgPSBhd2FpdCB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFpbklkID09PSBjaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgeyBjaGFpbklkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKG5ldyBFcnJvcignVXNlciByZWplY3RlZCBzd2l0Y2ggYWZ0ZXIgYWRkaW5nIG5ldHdvcmsuJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN3aXRjaENoYWluRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBvbkFjY291bnRzQ2hhbmdlZChhY2NvdW50cykge1xuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCBpZiB0aGVyZSBhcmUgbm8gYWNjb3VudHNcbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgaWYgZW1pdHRlciBpcyBsaXN0ZW5pbmcgZm9yIGNvbm5lY3QgZXZlbnQgKGUuZy4gaXMgZGlzY29ubmVjdGVkIGFuZCBjb25uZWN0cyB0aHJvdWdoIHdhbGxldCBpbnRlcmZhY2UpXG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuZW1pdHRlci5saXN0ZW5lckNvdW50KCdjb25uZWN0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gKGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0KHsgY2hhaW5JZCB9KTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZGlzY29ubmVjdGVkIHNoaW0gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHNoaW1EaXNjb25uZWN0KVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb25maWcuc3RvcmFnZT8ucmVtb3ZlSXRlbShgJHt0aGlzLmlkfS5kaXNjb25uZWN0ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50czogYWNjb3VudHMubWFwKCh4KSA9PiBnZXRBZGRyZXNzKHgpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFpbkNoYW5nZWQoY2hhaW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBOdW1iZXIoY2hhaW4pO1xuICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgeyBjaGFpbklkIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBvbkNvbm5lY3QoY29ubmVjdEluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0gTnVtYmVyKGNvbm5lY3RJbmZvLmNoYWluSWQpO1xuICAgICAgICAgICAgY29uZmlnLmVtaXR0ZXIuZW1pdCgnY29ubmVjdCcsIHsgYWNjb3VudHMsIGNoYWluSWQgfSk7XG4gICAgICAgICAgICAvLyBNYW5hZ2UgRUlQLTExOTMgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgY29ubmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRzQ2hhbmdlZCA9IHRoaXMub25BY2NvdW50c0NoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2FjY291bnRzQ2hhbmdlZCcsIGFjY291bnRzQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2hhaW5DaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluQ2hhbmdlZCA9IHRoaXMub25DaGFpbkNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2NoYWluQ2hhbmdlZCcsIGNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIub24oJ2Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIG9uRGlzY29ubmVjdChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCB0aGlzLmdldFByb3ZpZGVyKCk7XG4gICAgICAgICAgICAvLyBJZiBNZXRhTWFzayBlbWl0cyBhIGBjb2RlOiAxMDEzYCBlcnJvciwgd2FpdCBmb3IgcmVjb25uZWN0aW9uIGJlZm9yZSBkaXNjb25uZWN0aW5nXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svcHJvdmlkZXJzL3B1bGwvMTIwXG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IuY29kZSA9PT0gMTAxMykge1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlciAmJiAhIShhd2FpdCB0aGlzLmdldEFjY291bnRzKCkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZW1vdmUgYCR7dGhpcy5pZH0uZGlzY29ubmVjdGVkYCBmcm9tIHN0b3JhZ2UgYmVjYXVzZSBgb25EaXNjb25uZWN0YCBpcyB0eXBpY2FsbHlcbiAgICAgICAgICAgIC8vIG9ubHkgY2FsbGVkIHdoZW4gdGhlIHdhbGxldCBpcyBkaXNjb25uZWN0ZWQgdGhyb3VnaCB0aGUgd2FsbGV0J3MgaW50ZXJmYWNlLCBtZWFuaW5nIHRoZSB3YWxsZXRcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGRpc2Nvbm5lY3RlZCBhbmQgd2UgZG9uJ3QgbmVlZCB0byBzaW11bGF0ZSBpdC5cbiAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgICAgIC8vIE1hbmFnZSBFSVAtMTE5MyBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGlmIChjaGFpbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2NoYWluQ2hhbmdlZCcsIGNoYWluQ2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoJ2Rpc2Nvbm5lY3QnLCBkaXNjb25uZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgZGlzY29ubmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QgPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5vbignY29ubmVjdCcsIGNvbm5lY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG5jb25zdCB0YXJnZXRNYXAgPSB7XG4gICAgY29pbmJhc2VXYWxsZXQ6IHtcbiAgICAgICAgaWQ6ICdjb2luYmFzZVdhbGxldCcsXG4gICAgICAgIG5hbWU6ICdDb2luYmFzZSBXYWxsZXQnLFxuICAgICAgICBwcm92aWRlcih3aW5kb3cpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3c/LmNvaW5iYXNlV2FsbGV0RXh0ZW5zaW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuY29pbmJhc2VXYWxsZXRFeHRlbnNpb247XG4gICAgICAgICAgICByZXR1cm4gZmluZFByb3ZpZGVyKHdpbmRvdywgJ2lzQ29pbmJhc2VXYWxsZXQnKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIG1ldGFNYXNrOiB7XG4gICAgICAgIGlkOiAnbWV0YU1hc2snLFxuICAgICAgICBuYW1lOiAnTWV0YU1hc2snLFxuICAgICAgICBwcm92aWRlcih3aW5kb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kUHJvdmlkZXIod2luZG93LCAocHJvdmlkZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3ZpZGVyLmlzTWV0YU1hc2spXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBCcmF2ZSB0cmllcyB0byBtYWtlIGl0c2VsZiBsb29rIGxpa2UgTWV0YU1hc2tcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBhbHNvIHRyeSBSUEMgYHdlYjNfY2xpZW50VmVyc2lvbmAgaWYgZm9sbG93aW5nIGlzIHVucmVsaWFibGVcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIuaXNCcmF2ZVdhbGxldCAmJiAhcHJvdmlkZXIuX2V2ZW50cyAmJiAhcHJvdmlkZXIuX3N0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgd2FsbGV0cyB0aGF0IHRyeSB0byBsb29rIGxpa2UgTWV0YU1hc2tcbiAgICAgICAgICAgICAgICBjb25zdCBmbGFncyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2lzQXBleFdhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc0F2YWxhbmNoZScsXG4gICAgICAgICAgICAgICAgICAgICdpc0JpdEtlZXAnLFxuICAgICAgICAgICAgICAgICAgICAnaXNCbG9ja1dhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc0t1Q29pbldhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc01hdGhXYWxsZXQnLFxuICAgICAgICAgICAgICAgICAgICAnaXNPa3hXYWxsZXQnLFxuICAgICAgICAgICAgICAgICAgICAnaXNPS0V4V2FsbGV0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzT25lSW5jaElPU1dhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc09uZUluY2hBbmRyb2lkV2FsbGV0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzT3BlcmEnLFxuICAgICAgICAgICAgICAgICAgICAnaXNQaGFudG9tJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzUG9ydGFsJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzUmFiYnknLFxuICAgICAgICAgICAgICAgICAgICAnaXNUb2tlblBvY2tldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc1Rva2VuYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2lzVW5pc3dhcFdhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICdpc1plcmlvbicsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZsYWcgb2YgZmxhZ3MpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlcltmbGFnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgcGhhbnRvbToge1xuICAgICAgICBpZDogJ3BoYW50b20nLFxuICAgICAgICBuYW1lOiAnUGhhbnRvbScsXG4gICAgICAgIHByb3ZpZGVyKHdpbmRvdykge1xuICAgICAgICAgICAgaWYgKHdpbmRvdz8ucGhhbnRvbT8uZXRoZXJldW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5waGFudG9tPy5ldGhlcmV1bTtcbiAgICAgICAgICAgIHJldHVybiBmaW5kUHJvdmlkZXIod2luZG93LCAnaXNQaGFudG9tJyk7XG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5mdW5jdGlvbiBmaW5kUHJvdmlkZXIod2luZG93LCBzZWxlY3QpIHtcbiAgICBmdW5jdGlvbiBpc1Byb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdChwcm92aWRlcik7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlcltzZWxlY3RdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZXRoZXJldW0gPSB3aW5kb3cuZXRoZXJldW07XG4gICAgaWYgKGV0aGVyZXVtPy5wcm92aWRlcnMpXG4gICAgICAgIHJldHVybiBldGhlcmV1bS5wcm92aWRlcnMuZmluZCgocHJvdmlkZXIpID0+IGlzUHJvdmlkZXIocHJvdmlkZXIpKTtcbiAgICBpZiAoZXRoZXJldW0gJiYgaXNQcm92aWRlcihldGhlcmV1bSkpXG4gICAgICAgIHJldHVybiBldGhlcmV1bTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5jb25zdCBMb2dvID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTFFBQUFDMENBWUFBQUE5elFZeUFBQUJRR2xEUTFCelVETkRBQUI0bkdOZ1lIeVFrNXhiektMQXdKQ2JWMUlVNU82a0VCRVpwY0QraUlHWlFZU0JrNEdQUVRZeHViakFOOWd0aEFFSWloUExpNU5MaW5JWVVNQzNhd3lNSVBxeWJrWmlYb3BjK3h6M3B2T3pENHJsV3lhc2N5MlZZOEFQdUZKU2k1T0I5QjhnVmtrdUtDcGhZR0FFdW9aQnFieWtBTVIyQWJKRmtqTVNVNERzQ0NCYnB3am9RQ0M3QlNTZURtSFBBTEdUSU93MUlIWlJTSkF6a0gwQXlGWklSMkluSWJGemMwcVRvVzRBdVo0bk5TODBHRWh6QUxFTVF6RkRBSU14Z3pNT05XeGdOYzVBYU1DZ0NBb3Y5SEFvVGpNMmd1amljV0pnWUwzMy8vOW5WUVlHOXNrTURIOG4vUC8vZStILy8vLzhHQmlZWnpFd0hCQkI2RysrejhCZ3V4L0VRb2g1QWZrYnpZSEJ0QlVocG1IQndDREl4Y0J3b3FJZ3NTZ1JMTVFNeEV4cG1Rd01uNVl6TVBCR01qQUlYd0RxaVFZQU9RWmNMc0VDbGI0QUFHbWZTVVJCVkhnQjFiMEoxRzNIVlI2NDk3bjMvOThvNlEwYW51YkJsdWRKZUFpVGJZd2QyZ0dDNlVBQ0JGWlk3Z1ZOQjNDYUpFQjNWaGJRaE5XOU90RFFrQVlTSU9rRUdoSkNHSnJFQkd6SmtyRXNUN0preTVKc3pYclNleHFmM3F3My92ODkxVFhzdld2dmZlcmNlLzhueWFicnZmUGZjK3JVcWRxMTY2dTlkKzA2cHdyUCsvQ0hBM0FJOFJRUm1xRnhieVJsaVZkcGNTUTlqajI3SUFTd2RBVkhWeGk3bDY1aGNaQW42TmxGZE9PY2U0dkNnQjVGYzVpWGRpTjFhYlNGUDEvMlByUm9VdGlZUi9PeTlDOVRyN0V3TlZjNHB3b2pUREZ4QzBDTUkybkg4aHdsaFg0RDVaT3ZXd3p5OWNIbFM4Rmx6aGZ3Wk5seUROMnBQbFNYd1QwVkF0ZDd5VEw4K1NEdUhPdkN6ektkeU9CdXRJZXVqNkhmcFRYdHU4RXczV0Q2TnBqbkFMbkZ1STFJUEI5R0swbjVaaUNNOUg0R3lUSmhMcUFYMUdIWk1vSks3MEV0cDB0SzRubGhMcUJmUUYwOENGbkFnUHJOOFNITXowTjFZbWpsdVlHd05LRG5TZVY1REVPbnR0SG5wWjdmS0JEeXVXSldVSG5LcVdMVXNneWFKNFdialQybkR2NTZUQ1dMNmdhdzB2a2xyQXYvdnBEMm1OY1dyVHBBSTAwK0g5RzBHNVhXVS8xZ3M4ZkJTQ00xZ01xL1kvZDlCekQzV2lxVXBTNHpRYWt5QmtEUTZrN0hRNXVaaTRDZ1FlcHBoSkU2NkRpdUM5UE01N2xjcHNVMWF1QTZVbDFRMVMzOTlvNm1GMXFYRkRxNU5ieUhxaTdRb0JtWjV3cDh3ZG4rM0c2bzZxaWZSVjB2UTNRdGJ4R3dQVWJUK1JTWGVFai9OaVV5cVF3UDVCYUlPdzhHbDk0SEF3VEtTMHZpWGtrMWZlamVydTAyazIranJOYjFnRTdkNEdBN1l3dEVZWUV0SHloTjBIV2g2L1E3QVFWNGJtaWRQd3pEYUYwMHJicGRHbkhRcUkrdmgyNkxvUGpOZFFDaTNYZUFsTDd6Y2FBNmc1UFlDREJxTXVwNzB4YWh2cEsyRGtNQUNtalZ2YzQ5MDRFRkFwTDA4ZEpnQUF4VlVYM09URUlsRmNZWWlnb29QaTlmWjBuUHRDajZmS1ByKzJNU0QrZlVBUnpOREJDSjB5QlI5WlQ2cWpLQzhqUkltY3hmdnVmNGI4NHBMWEJkc0cxYkc5NHBMU0wwMGkwdGFIcGRQNHJ2Nlhub09pdXQxYURTYUN5WUkzQVY3YU0yOUtBeWMxUXdOcVN5WjVnSGRFY003a2J5YUFYZm1PWWc1dmFGMk1yUXhDekZHRlozT2o5ZEg5OHhQYzI2M3QwWVFLQWRQQ0EwQ0h4bjFDRG8rWjR5c1NRdnJvdlRQamtrc0hDZG9MWUR0T3BDYVkzQUFaZ3ZZQmpBQkZTaFdkR2ZqczdWS2NlcHVnU2lTM2RLLzZ2dDgwSEhVblZmYWxBNGIyQ0hEUk9DRzF1RG1NODdkZDRDZ3k1SGlHMUkyT0I2dXdFQzlWaE9oeG9zeXRaclNTQWcyblU5ZFoyd1JUK01hQittWHdkdGQ3cEQ2cUpBM0VOdFFDT3hBWVoyZDZNK1kzdzJkUUVMOXJudFFYWFNBR09hTzJmK3pjQUNHWlZ3TVJKWjVRdFVMeEUrL092S0hBdlRGaE1zN2JaeDVYeU9WTlpnN2tBeFQwbmtUa21OVk5GdW5vUno2clpYS2k0eHh2UjJZaG9EbTVudEpSeHhyb0poQk1RdElIZSt2ajZlOG11QlRNd0tKZ0ZxZy9lVVYwLzhhTlduV1Jmbi9RQlYvZ0RVcmgydzBVbjlQWk12MDYzYXhFdGZYeGVobi9KaGdkTnpIUm9EUU0yZldpVTEySGIzT015VjBLM0tlREFiYWRVQThBUXNJRHFWUnFTMVZuZE9Pb0N1V0NCbUlhdmdkRTBNSS9EMkpDbDYxZUFpN1JTWVdWV08xUmRkcDlRTjdldlFBbms1dEp5UlVnZW1rblE2cmdNZnlvenlvTkhxZlREbzFQV0F0a1FXdWh0dHh2ZUI2bERxcFd0UXo3WEcwSFRxdzhmTkZGM21PV1UrNWVLY1JOWVNHNkFONnFrMndOSFpLV0pQa2dxUUhzdFNGWnhVcHZPSlpoVGxOYUhyeVFpZzgyOEF3QkZ6b0ZRME1ROHppRE9ZTVRHaEo2YWtocStnbmpHb1lXakQ4WUJFUUswR0ZicmpBWXlEMkFBaGQ2S1NGUU5aUUJDY09NRGFUajF3ZmFoamdqVTVwQjdVMkIxVWJjUHFmQ0RKdUM2cXpZeFdUUEdSM3hQVEJxbTlkRDFSNmdMQUhkTzJTU0RhVTZNSlgvdStDQTNYTVdkRVMwZWRrNlV6VXIxNG5ORHhzL1FyZm5QbEFOQlNubWtLQ3NOVFE2Z0drK3IxQTN1UjQ3eWtnZ3JtaWJyV2NSYlFMT0dHRXJFVnFrUlQ2amptMnF0RzUvTUpBWHdHd2FqQXB1bmhCMFFPREZyVHRFQ2QwM1ZXd21rKzFRcUVvYm5CRWpyVFhrRE9ramtCWVVJZ1NIR21reUlhU1Qvd0N1Q1FuazRFVFcyVEJPU0JTZWkxVWtNRGNKbEZrQkJQdTBtaG53QTZJM0JPMG5sTXM1NzRTcnlkb1J0N1FlMEEyVlJSWURiaktJVlJJNmtwdnBnY2FKV2pya0NuQzhXaDUwSTNya2hoZFQxUlFKNUFaYUlCTmpaVWRxT0hEdFN1YjJ4RUIrNVlUcFNRTTJBcFVrMFBhQTB3RUYzRHUvcUJCY0JFMVZuYm4xd1hBS3R4dU56ZzZxQ0JyVHRscDBGTzVabDBZTUhNZGVCZkRVb3RlU2UrZnR4aFZWb3YzVFdQUU5PdjI0YmJJWjMzU2FPVTgxbVU0aDFwbUJrZFBFQkU2cmc2eUxnSVFBYjFmdkFiUEYwVU41aFkwYjNHeEkrQVdZT1h3VHpSWUNZZ2xITjdUelBRZ0RvVU0wUVRVQ1VyU3pFbDRiQ2FHVE9vZGhvRFBFdnI5R3dvNWtwK3RzT0I3MVpMcFBwYjZEWU43K3FMeUJwSmFSd1lEcWlDcm91dWd4OEh4THF6Tko1QkJibnV0TVlUNGlVb0NZTmtCaFdUQ0pybW9CVTBoZWFKL09yMkJsVWJNaldBZ2R3dzlhQ0FXT29RVW51a01nalk4VmdIRUJNM2c1cXZDY0F6NnZ4c1pnMEVrQklPbXNmVzVPQ0VLcEdXMlBNa00vZndkRDUxZ0o0T0FBNzFHZlJtUzJvQWE5TU9KeHBJTWtPcGVKWml1ZkdLcVZGVU5XU21pUzJIS09iS2hKaXV4dzhBVU10bmVyRFM1VTJuT2g2Z2RNRDFZTDVoRlpZQ2hmcGJ4d0RhL3NjTUJMWW5SZjFDNmFDZGdGNTVDQWhNcG1XeDJ2Qm00QWQyTE1OQW5yVGExTFcvUmtWUXZ6MFNxRW1iekxEU095T0FJNEU0Q3lxbFRHWUFZdXN6OXRpRzd1aFgyOC9lZlFzTm9Gc0o3YVRWSWpORHdBa1YyQ3NVeHlDZXBnRUluOU16VThWSUk2bUJUWnh1ME1tNEx4WmdGazlISDloT0xveWRFVU5uR2VDSmpwQWxReG80enJCNkMvVHNsa2hvZExZbVdNMVI2MHFnUmpBZHNrcTVDdWl1WWtCMHBBWnpvUVZJcWlIVkFYUGRab0U3YXhCZzhBQXJhRkRUTDQxQVRWc3lMUk1QYUFKejRrK0hPSkRVUlpyNyt0aUtzSlpoTTdBbndUSWp6Wk4rMTRudnFkejE5QnNIamV0cHJCSDZpcTBrcldPOEVTNU9Vb3V6QXV0N01ReHM3OHFiYWdhQUlWN2hTUjIrRnd1RFNCSlBpVEhUenNhbGdxWTB1czczRlNnSzA3dkNRRzBPS3NJRGVRdXlUME0xZkM4MmNsRmpFd1oxYXBoUTh1OWozbXlLR0ZDcitnRkpCUmlSVnRWMEFpUGhKdFRvRFBUS0p3dnU1S0dSdXBCVXl4MFQyRVlPMVZTQ2FtdW1EamtEWlVxeGxBN1ZHMUFIdUVQdHFyMFlSaUtISW5TcWhxMGR0UTdXTStWTzQyRHRsQ3lsQ2Rnem9UK1FpZEZsNGRMRm1Hdy8welEzQnZxTlFNNjRpL0hyRE5xZ1hzckNPa2NSOUdBNHVQYzdGS2lINzNKUVp0cTNETkJRWFFyTUdzZ0d4SkhRQk9RVkQvUlNjSlZ3V0NVZ1dFRWpoQllHQmxIQjFiNWlqMFlxbSt3MXNUZUJ3SURrNGJBTjRBZFRuWk5xYkZNeWNMV1pOQVV3RWsxQVFMRE5UNVBOTDFQdFNIK29TUGJvelVnRHlZQXFKbGlQZnpVNDFza3NZY25Oa2xHbSs1MDlXUUZOTmpTb2VrRHh5a3dSbExTbTlLRkFsbDE4YklZQnRidVJOc2pqR0RWdWNRSWwvL1pkSGlDdWdSV1dlWnpVQjRsYzEyMk96TW5xajBlbFZWRUJIeFJkMVliR3hzd1NXbmVPUHJSa25qZ0p6UUJlU1FYRVhscmlDNGp6Z1dBR2kyeGY4VUJqVTZ6b2hhdXJjUG5telhEaHBrMndmVHJONlZKWWl3dzR1cllHejU0NUhZOHo4RlE4bmw5ZkozVlRHbWFkNkVsZ1RubFAyRk9BSUlDQlVBRUZhQUZRelEwdzlyNGUzSXJYZ3lWWUtFcDRjNko5MDJhNFlzc1cyQlhyY0lHaWZUMG1PYkoyRmc2ZVBRdlBwdVAwYVRnMTYzTWpCQ3FuRjdvN0drd0ZNZzBZTEtUYU1aQ0VaNSs4RlV3TVlneEJCbmlUR0RQcGFwMFN6L1BBa2JyNmFxUjlUK1QzWlludmtmWWRLNnV3UW9QenRTaE5qNnl2d2NISTcwT1Ivd2ZpNzFvb2NuS1NOVkRSbUtrbHNwdXVMelJuVjEySDFMNEkxUDBLM21LZXNab1FMUkF4d1FDZ3ZsMEl0bDQ5Q09LTklCTGhCTTV0SisyTGJiK3o5elVYU2NVZ0pSQkhCcXhnalZ0QnlFY0JlS3hzVndCZkdGbUJzRHN5N3kwN2RzRHJMamdmcnRpNjFmaWlqWG9CRzFMYy9wT240TGFEQitFTFI0L0NFeEhvRTZoMmJ4NmtzSW5DZzh2MHIzTUFnRHFab0R1dHNaczdIaEJTSjh5OUlzRE8xUlY0Mjg1ZDhNWkkrMVdSZG1qUVBoWWVPM2tTUG52NE1OeDk3RGc4ZC9aTUFXL3VPQjNaMG9YMkRCSmtTVmh0N3A1TUZ4WUcwb2FCdEFSV0xjSjF3Y0QrNEJBNzNBcDg5YTZkOE5hZE8rRzZiZHVrOHkwS3FheEhuajhCZHg0NURQY2VQdzZISThpWjcxbkRUQXFQT25MZkZld0VLTG9zWkR2NkxDSUJ0bWZYandDYlFkMHBIZ3BsSkptRGFUOUt0K01qSHdrOEt6YVEwTkFZQVBKdk5pY1NnSzFrTGtlWHBmQ0tpcXUyTkt1M0l0bGVGcG40emdzdmhPdTNiNGN0a3dtOGtIQjZOb3ZnT0pMQi9jQ0pFMWs2Qkc1MFVETnhvUTVva01TejdyemFlNkh0em9rQXVhUzdMb0wzN1pIMlY1KzNIYlpPTi93MW13bG5vclM2NjhoUitFd0U5NFBQUDAvbVJQV0FySWRnQmwzRjJ4R01YejZIVUEyUGpxVTBxQUYzS0dCL1ZhVDVhM2Z0amtEZUFkc2k3UUhPUFNTK2Z6N1NmbnVrL2VISWR4Nmo1TWtVb2owZGEzVG9jeDIzM3ZPOVhzeEdHVXVFNm4vbit2bzNGTE9wdkRNQ1dydGw2bURBU1dNQTY3MWc0SFlLelBFK1MrZ1Zrc2dyblFJMFZLWW1jK0p2WHJvSFhoR0JQTzA2ZURGRHFtZ0N4NTg4K1NROGR1cFVVVXVJYWtER0RBQUJNMXVLcUVBc1BtZzJMV2cwdENOS3RlKzk2a3A0UlFSRnQ2UkVXemFrQnJ2ditQUHdCL3YzWjlPazBBN2kxZUJKb2pxckNLSjFTdDFCTkEyYlVFRFNPTVRFRjBWVDR1OWNjVG04TVdyRFRTOHkzNU8zNGd0SGo4RUhuMzRxMHI1V1hIb2htWUFnSUU2L1p4dUExcUJPZ0Y0blFLK0hPbGpXTTZVTWFEWkQrQnAzM1h4ejBDYUhuaG1jNTJOT1lOYlNlVldCZDhWZHl3Q1E3TGwzWFhRUnZPZmlpN0prYUlXTlNvc3hTQ1ZiKzJQUEhZUS9mdklKa3NRbzd3TUU5YUFmUTB4QVRVSkFzVEVUczFMODExKzRHNzU1ejU1UmJmSmkwdjZKU1B0SERod2dXNVZuUm9zWlVqMDJRVFNPSnlLcmEzTHpyY1puM3gzNS9rMlhYQUk3VmxmZ3BhVDl5Tm5FOStjaTdjL0ttQ1daU3dMb0JGcXdZRDRiTzBNYU5NNzZYdExNd0lHYUI4VHBuUkVxUzc5NW1UdnVybHR1Q2FKdVF6QnZ2bFc3eTg3d01XalQrYW95TXpLUXM2blJ4UUZHQmZPVXBOdjJDSUlrSGI0cTJtc3ZCa09YWmZEbmpoeUIzM3AwYjJaYTFqN0tmZzVndlRuRmk2RW5XYkorandEdTRHOWRmam04ZGRjdStITFNmbWVrL1QvdDJ4OEhqek9sYVFxb3hkTVI5RHNpeWsvYkZ6QW5nZk05VjE0Qjc0eUEvbkxSbnZMODlLRkQ4QjhqN1d0aytxVUI0em93Z0lza3p1Y0I1SHlOSkhPNnorYUtNVCtDTXJOQzQ4TUhBMml3Z3o4RDZLNFRHOWhJWmdFekNMZzNzWDBOTk9xTUJlNk9xdTZIcnJzV0xvK2ovNDBHUFNnY1krQlk0TFRQeEZINVA3L3ZmbmcrQW1OS2twb2xzNlREQXVLSlBGc0FjWDQwTVg3azVTK0RpNklId09jYlhrS2FPU1RUNDFjZmVpaDZTTmJGRjZ4ZnVkUTBWRGRuQWNONVVZajg0MWRjRDVjcHZudmF6b1htc2NHdWo5c1hUYjUvOGVCRGNDSjF5QTV6UjB5UytHd0M5cXpQUUQ0RFVDVjFxQ0ErMjF2VFEzenhMVkRUMFhrd3l5Z1ozYnNXUUM0ZUJPdUxKanVUL2JKVFNzdjJjcElTMjZZVCtCOGpJT2FCT2N3NUFDenp3eExwZmRxTEl4ai95YXRlQ1RzakxlekRMck9Xb1V6NnhDTjF3TlVjVHhNKzhjR2RFY3dmZVBuTERaaVhwV0VqTk05TG05eC9QM2p0dGRGMm4rYUlSSHYySHZGdjVqL1ZnL2hmYlAwcC9OajFMNGRMSTk5YnRMMFFtbUhKdU9TKy9QRlh2aUs2QUtjWkMwbElWQ0ZadkRsbTRnb0F6TnQvK2dEQ0tHSVRzeW1ZMlZrNXg2SGJMb09ZWnY4UTBjeVVzU3VMejZlQjNwYUtQV3dhSC95eENJamREaEFBNHlCOG9XRXN6K1RUL3RGSXk3WW90YkovRm9xZlhBOWljeDFLMTRldFVkUDh3SFhYUmRwWFI4djVjdENkUWdMbEQwUlFieVZiTVFzTkhuaEQwcFFkVFY0VjAzRlRiS3ZVRWE5d2JrUmQxb3NkeHZKTXd1U0hJaCszUkg1bVVDY3pLSkRRd3pwL0lKTllJUmlCYXJDb3ZFd2NQRTZyVkc0azRCbENmbWxIdTREOFN5L3NoOHhxaTFUZjkxMTFWWFRVYjVIV0N2cUFMKytSUW1yZzc0cjJKS1QzQi9vK0QvaEVZa0R4ajJmQXhPTTdvcjEvNlpiTjBsaGZycU1mb2YyeXJWdmd1NisrS3I4VEFRUU1rV3BRL0wxcGxpSUI1VHV2dUNMV2RjdVhuZllXM1NsY1JYelBjUXFVNWxWV3NPL1BkQXA3blpQTWd4bHVDblY0cEcxSmdJR0VUcmYxSzVSNjJyY1FSVXpOUEUxK3hCN2VlOG5GMGMrNVN6TFZGUXdOVG11d3Z4Z2hqRnkvT1E3czNoY0hlT2tMaXpSYjFaRzBUdThjWUY4MHk3c3V2aGplU0lQWFZqNHZFb21qWVl6MjExNXdBWHhEcEMzUldLYW1pZmFZZ0dsL1QvUmtmRzMwajQvbDgxTFM3dlBYNTIrTGZIOVhwQ3RoSXd1VEFGa2F5M1E4Vk44L3Y1WmJEbWhhREMxd2R3TWdxMEZoemREMkVIbkhGcURPeWdIYkwyVWd0WHRsSllPQ3k5SWp6NkIrNVJ5c0dta0JleU1ORVVhZTRldTNSZmZieFhHS092RldYbS9NWG9FZUxraTA3N2xrOFB5NWdPRmNhQjRyajgrL01mcnZ6NC8yY1Q4ckhiQzhPbERBdkN2T3VMN3o0b3NHK1cyRTloZENjeXRlbjM5THBQM1MxVTNsRFVFeW5YaHNWaitXQVBOdWpGZ0lqRVhLSzN1bURDYVIzemRCYUFFN2hRNlVrUjdVbTFkUTMrTFN0azVTaGNtWCtMZWp5a3ZBNEFveE9NTlloZEdDWHFRNkFidG42UTNMSGJBZ1B2bkEzM2ZsNVRDTG8rOUFoZkR2dDBYYTAzc05QaDlZc3V4bDZGZzJiYXY4Uk51M1JBMlRydkkzbFVSM210ajQ1c3N1Z3kxcTV1L0ZvdU5jK1F6dS9MeUlpZjgybW5LSjF1eWZDRXJhT2lCclNaekdiNEl4SlpIMWRRRzJLbFFqWHE3cHF2WU8vVXBoOFFUd2I1SjJhYVluemY2OUtjNUUrUm9HT2cvK2dKR2dnTTAwZWZ0N21lQVp5OWV2anVyNytqamIxMGRRSjJDdlI0bDM3YmJ0TWY3OFFWcWZ6NWNyakpYL2hsMDc0Y3BvbDg0aXpjbDBTcjlYYjlzR04remVKV20va3JUUEsrLzFrZS9wbFlkRU03L2Z6QzlLQ1pDMVYwT2VWQklackVibklJTkNiVHZiTisrR3RyUUJOaEZVWnFTaTM3Q2Z3VHVpQXorNVl6SlRjUW5Ha2dUbVk5RGp2ZlNtWnpZNnVIUkY1dVBOMGFZN0c4R2NmYUtSOXErTzZwcG5FMzNhci9RQjd2eXJJNStUUGJxMlBzdDErTnA0M1FMeVY1cFdINTllai9qcjBhUkxVcnI0MFFPOUM4OHZNaEcyMEw3MXlWaE1RZU5VQnpPWnJ4TjcvRWd2b2wrMm9YTWhHVlRsbGNIMHJzQ2JkOVhCMURLQUExZVdHUng2SktyRTZNeVNkbStoTkNQbEprbTNQYXJCOUhMUWptamJYUnNsTmtDN2NiNVNvUVdRRkY1Tkx4WWwydE5rMXVzMDMrRXJTL3VBMzhFZXJ6di9mTmdaK1o2MFM1YlNZU2c4Qld1VVp3dVQ0T0k2ajNDOWlxanBIZnlrOFFOVzhadSs4azNTK1lab2FtenVKcGFaRHFDdHdkNG91QUZHdlIrQkVqTWpGcVZ0U1k4MEEvcmFIVHZoOU5wYU5qVzJPdnRULzRMTHc5L3pZVUVmVzVpMlZhNCtraTM5bWd0MlJOclg0VTI3ZDJmSnQwZzZBbXljNWpBdnJRWXF6T2xNemdtUWJPbXZpVFJuS2QwSFNheS9qQ2x2V2xsdmh1RFZ1KzFrekRkeVEvLzFsQ0dwQjIxdXBKNldpSHQ3R21FemZhcWl3Z0JvOTFoOVQzOHE1Y09vYVlKRGNvTktwNnZnNmJraGVqd1NVMThmN1UvL091WThVTXdEenlJd0xwTVdSdExvK0srNktKbE02L0NHU1BzaThKNHJ6Zms2V043WFQ5bkFTcUFsQXVlYjNIanJOQWFRZGVzSUVDWmJ1c1dZUkJ3dnJKZ2NQQmhFaHdoMXFXMW9MVW9MY1Bwc2JxUjNPYTdadXMyK29ybE1NT0lZcUtjT29nd2RmSFBnczJaelJFVnBpZDJpNllydDIrREthR3BjRmdjcVBpeGRoNjlRdUNoTy9Gd2FlWjdxNE1NTHBkMElIR1htZWROZzlIbjM2OFBMSXM4M1Q4cVNEY25sbUlNMWtzdXBMZ1JkTXUyaFEyd3NZOENKV25sbkZjQ2Z2REN4eFhaT2c1TXI0L1JzTnVmblNFVTVINnNsTWFzUHJteW93UGIwdHRLYUhzR25yWWVoZkx6Ny9hOThCV3lhVEpxUzhLOUs4T1NuOCtTaSsrSFh2VVpvMS9MbW5HaFhIYjhsQ0pmT003UXZqUTBjQzBnZmR0eDE5QmdOeElPUlhnMGNtM1A1cmhCcXZRZnZjbUFqZ3pDSDJyS0VWY2d1bUVzMmJSNmtOd00yZlE1Ty9YRmQrZ3JRZkE5aFlCZXI3SVJXYlVNYkFwd284V1lJaDB1M0RUK2QrcXNFWmc3ZWJFamg0cTFiQnZjM1Nyc3gvUkFBOFJ5ZWRYbG91OW5QTWJCUTI3TjVjNTYzS0ZJNnFEcW90d2lEYmV0eVVnblVwRTQ1QTZ1aXc4aUtsdnk1ZVBrc1AzK3dHNEJlVmV6elN5Z2VwSXFtbHRDMDB0cWw1eE5EaVFOcnkrTFFlUTdVRlhlS0FZZUdRVXU4WlZUcnVhU0ZCZW5INkZnRTJJVjBORHI5V040QlJtNHcvOUhhdWo1L0xaVWxQUW1xSFhGd3VONlhHYzhjSjVLdnBBNjY4anFQME9aQU5UbUNSd0M2SHFKQlhwYlZLZ1BSNGt0TVpzZk82TEliWTBhQUJwQmhoT2t1azdKaVpUdWQxQlhiV1RTcXBlcTBpSkJtWHhzTjU1SjJvK21YU1F0ejBocWdJY3lsS2JReUdiRnB3bGhHTUpCQnRVMmd6TmptbGE3eTZ3ZHhjSWpzcVhFZndRYXdjeG9qS3FSK0E0WDYwNlFxRHl4WWFQbFh5cHpYODgwelZmSGdUOTZOZEc1d3RSSmxsbVZvZ2tydzUvSXg3NGdFSWRkS0V5WFdRcWcyZHRCVjlPbVhDQnRJK3BLbDNVaG9EWnh4VVZxdlFrYmFzNFgzVm53clRRckpienlqbDluU25icVZTQzJCMXpTRVVacHJhVk85WnBnUllucldBdlZxT1FScXFNdFF5Y0l1RFRVd2htdmQrNDJRTkJmampHbHBITlRQZW9tc3lteEphL2xkd2dUeGZXSHMyV1VhdDVVTndOREVPSmZnZVl3TlhyUUdTMElEUTJPSkNtaTU0bW13NW15TlNELzVTM2JDRGt0aHZZNDNZODBXaGdZQWVtWlgxdVh3UkpqdEQvZ2dpU3JyeXRGVUpTOU50ZGIzZzN6c2ljcWZhalNvN0FnbldqYWtVVjlPT2lNbzZZM09qZ3RPS3lpRWFrbnVBN3JHc0RjZDZhcGNId1pBZGRvRTVqeTdMTXE5amR4OEJOdHB1WUZhd3FpQmZ3Rm1xNmVIOFdMenZmVHVEK01uZjR6YzF3V0JBaldHNEMvVWJ3aDlFRUI3a01pdk5rRUFMTEFsVTZ4ZklNZnJRMmZPd3J5Z3dXS2tNY1ZCc0NDRTBLRE5TeG1WTjVGZDc0VjJBK2o3VXZ3ODI1b0JobzF5Z29yWHRHT2JKdE4vVkw3NlB1Q3dlQjFRbFRzZ3RRSGt3UUNZQ3VwN01KcU1YekJicEtYMFNRQVlkR2F1YzNCcE1BeXpQcjYrSnQ5RnpxUk9kVUdnMXJzOUdac2hHSHd5bjZaakJHdStsQVdvU3dIRjdLakwyYWFJUUlYdVAzbENBR0VjOHVBcTU0SHJDbWF3czFhUTRGb1gxWDJmRFV0SWtaYnFJUzJkZzZzOHF2T0E3bG13d0pkckJhNjVhVnMwaktRZnBOVzlZU1J0ME0rNHpxbzdhUlBnVVBudGFXTkJwTnRNOTE4dEJFeG5WY1cwdEcraThlRHBNL215ZU14QzlwN05OTmJRZFNMWGlYMlkybG9IVnd0K1VSVE03Sjlzb1FDZ3Rrd0w4UEN4WXpaM2xyclFJQ0xZaXFQOGFVZ2M1ckNUS01GM1VYQUExTS9xY25GNHYyVnFvRXFMd2Rhbk5YdFZpWGI1amtrOEZ5OXBjVHl0cEZFQWIzb3VOUGhDT3k4Qkg0N3czQUhJRC9TRGExOTFhM0J0T21YOWdYMG5uaWRNbFE4VmVBQ1k0MUFKUjZqeFk5dTdwVHluTEw3TkdyeVpXRFJpUDczU1Z3cW9hd0xuUmJpQjR4QWVUVXRZRVRlMGxPVzZoRll0Vlk4SEowbTFKTmVTa3h2SjhYeVl0NkxCZ0VwSkhBTlVMZGwwb3dlYmRsQWVqdjlpaThoR1BTVXR6RWtIVm5KTDNScDVTUlpoUEVzeGw5eDkweGFoL1N4SERQZ1BEVUhVQ0VXREI3anIwR0dwT08vWFVzWnBZQ1MwZnJmSHJPK2RDNng3N3BoM09YU0Zta2NJNXVXVStoSlJhZVdUNnpQNDB0R2psV0JWY1pNNU15T29IdGk2VnM5WU9tcWNnRjNIYVNrTDR4SlNEL0pFVFRjYUVqWFF3ZFdsQmRSQnk0L0VMVXFMamZMY3VRR3pUOXZvT0lZVmFOdkl0RUdqT0FOMFYyeHdZTkh0eEdqMDVEeDgvSGdjZDUyQm1pdzRYTG1YMEVLYnhScllIWVF4VHF1S2dqM013dUVBcEpiTGlrUzNQUDFVVzJMNllsQUJFUnhqVytVU3N6MXQ2UEkyMmw5Sk5YMTAxSDk5Zk92Rkc3bm0zd0QyM1YyKzlzL2pnclJqZWNOSU9XUDB3a2plaXNkOEg0aVBxUGpYN0J6K05yV0ZGZ0F0a09ublRNQktpdzRmM0wrL3JCRk5wcTNCV0FCNStWK1JhUHZwWUdZbzFIYzVCcjB4aENhSVpjWDVZRmUrTEV0c2RmQ25qejFlMW12MkVnT2x6TG9DYUYvaitEZTRIdTRsZHgrY05BQ3draHBVZ3hJZ09LMk9sM3ZRQUFvNG9JemR3MGJhTVBJY05zN0RBcUF2UTRkTHE0T1BGMFZzVU5FR1M0QVJnT3MyQ2hiVXJVT2VEV0RHWVFrakgzdjZhVUNxZ0RZdFpncklqRGNXbkI2YlBneFhTNVRCb0FPM0toQ2h1dXJxQ3Y4RjFNK2NPZzIzUFBrVWZPdFZWN0tXZzNwU09hTWxNbWdtNHpEZU1GZUJlSFJnRm04ZWlBUFVYL3V2TjhJdGQ5OExqeno5YkhtSm5BWWRRSFVDZlc1WTBHS1ZDNzVPWDRHQWpnR0k2cGRHbDN5ZXROTFZsMXdFMy95V3I0TDMvL1Yzd0o2ZE81cWc1bXBoY0tCczFGVS9ZOXBVeGZQR1Izb3NrVTQvOHNTVDBZbHdITFp1MlNRVEk3TGhLTlR0TFZvZFJNNjUvVlQ4MU5PcTI0bDNuTElUTE9VOURsNTRHNG14ZWZQeXRJZktwSU0vMi84NHZQdXlTMkhUcExHNktEYTR4eUJ0aUFTSFUwRDlTOC9wZGsybmR6eXlGMzc4My80ZVBQek1nYkwxd3VvcTFZZkJxbGJzREI3QXdYU2E1Y0tMaFd6Y2VDcXNNU3p0VUYzbjg2NmsySC80S1B6R2gyK0dtKzY2QjM3bTcvNHRlTWRyWG1VcFp5azZCK2lERU5yeG5rWXZxejc0K09NWksya2ZGaUQ4eUM2eUFBTjd1WG82bE0wRE5rMEt4bTNINm9tRXRBVXdzaThhUlVxWHRkZ3JxdktuNXQwRWJqdndMSHppMldmaEd5KzlyUG91ZGFsOEdoWXpoLzJpeGROaW1TUnBDUGdwN2ROSGpzQlAvczUvZ01maTZIblRsczNRVFRyZ3I5ZUZLVUVEdXIzWTRjYkRRTVl0a1I0YjU4dUhnbVZVMXlnUzBLd0JSK0l4ejhMRjJaUzlCdy9Cei96N1A0WS8rTWtQd0lYbm4yY29DaU9kT1lUbHU2MlpBOUJnSnRvKzl0UlRjTWZCZzlDdFRxME5qVHd3ckd0NTZ5OWpxbWxqY2FmNVlUWU5raVpCTmhYUVZMSUF1U3hBeTR0dHMwckoyd3VUaEo1RVVQL1NQWGZERGJ0MjV3OVBUZDZxc0FBTmxkYVEwdUx2YklsclZhZjA4enQvZVZ0c3NDT3dHc0U4WFpsR1FFL2lEVmtDUjlud1FXeXhjblBjTHZ1ckdneVVGUzlrS3dvQU1Nc0FwTy8zMG5JTmEydXdMMHJyZi9XaG0rR24vdmI3aG5WV1BBZG95cU1CRFVHWkUxNGlhMXYrdWRPbjRkZnYvU0wwWGZyNmU1SzFlc0RpL08xSjg5ZTljSndMRDZxUUxRSk1WWnFrOEhTZWJQQXlKRUFGY0piVU5LdVRwVFA5VGlLQUp0TUpQQjVuRFgvdjRZZmdSMS96V2pPeTFwMEdXdEtBSlFIZE4rbUduWExBMlE5OTRWNllibHFCbGMyYkloMHJtUjdlVDRWSHpXSWZrcVFtV1EzYTFQci9RL0RiYWVRNEd2bkpGaFJwdTd3Y24rb2QyMndXQit5NWs1K0ZXKzk3ME9RblBHQUI0dTYxUW1na1lzbXNhV1A2L3Q5SDk4SVhvMnQzOCtiVjNEYnNjZ29heElSUDNvZXhWdGpabHA0VzBDYUgyQmxoVUVHWmZxU0s5aVNsZGE4cE5raVhpVnhKNzdoR1NmRHZIbndRcnR5MkhiN3RxcXNOb2dObjdtZ3pRbHFCR0hVaWNOSkFwVS9rN3o5eURGWTJyV2E3ZVpwV2Jzb1NnRjVMNUlLZGsxekFyZW1ETnNNY0tYTkRlSW5TQ2hGT2w1UGxYUG1GdEY1Y1IxSTdEZUxUTmxocFE2SjQvdmpob3pVckpZYjFOZy82UkdOQTMyZTYvZWRQM3UzNGwzRWcrQ3YzM0FNcnF5c3dqZU9ycE0yaEt3TEgrSjhEZXphd21ob0lSdWhVUGxqTW1sRmJxOEZFTW9lcXp2STBKWlF0RXBBa1hzWnpVaDFSVkNkQ3AybTlpUFV6OE0vdXZBTnUyTDBicnRpMlhUSkhwZEtRS2lHTVVpMXJPcitYenE0WGlQYUpIYXBMcGtaYVMzbGF6QTFXVTl6cmk3TStpQVRRcWt5WDVYbkRIYWYxdmdOQW00ZTFPa1BJNm1MUXA5V0ZqS0JkNmh3cW9IbDVOcXpHZEg1Yzl1N3VpamFkUkZDdHI4OHNtTUdhRnl3NHZBYlZORE50ZWhaVkRnWG1KNTQvQVQvNTZVK1J3RXVBbmtSYUpsbWp5TjdsQU9LQTZEMHRNQVIwSzI0S0RaN2xjMnIwdWtzbm12cXdsT2JCR20rVmtCbVdpWTVYcXoyY09YTVd2dWZtbStEZnZ2TmRjUDM1RjlBbWtaWW82ZlRFaVdEZlFtMi8zTzJBekRTRDlQcGltK1hkbUVLZGdTcmJLQmQ3TFpVbGUzU0VZa2Jsdkx5TnBLU1NMbnMwWUNzTmJqeXRMOU5sZ1FFbE5RT25qSE93YkJRUGRRSHhrakRmaWJ3Sk5PWkI0MHZXUlFsUXdsalpOVnAyLzNYV0FTL1g5Y1NKay9DOU45MEVaMks2MWRpUlZuaHNrOXNJYUc5Ry9SNTBGVFM4RzVoOEZ1aTBnNlk1aGM3YzFJTWswbHU1UHRUVk9IUHZwemJyYUVRaWs2RS9uUmJUSTFYZ1dMVGIvdjdIYjRVSGp4NnBQVmNmanBPTkNhQUI0YjVDa205WjR6Y0RPbSt5UXd4anB1VjlzOVBDdVZpMkhTNGI4V0JOZy9XOHozc0ZkdVoralcvRmRZUDgybW54SE5JNk9tSWROSzI1TG5JZmNoM1QvYlE3YStuRU5XMVM4WGtnTnVtc0tlZmFRZUpZN2F0R0Q0NzVESDdwWEpUZ2djT0g0ZS9kOUpHOFdlZHFCSEk2a25UdUpwM2dTQmNaTkIzS3pOQ2YvOEVncm9ZcHFGR3dGMGIxUlIwVS9TTlRrWWhraHZCKzAwWENoZHo1eXpZRHNCSW9ud0RQbmowTjMzZkx6ZkJQYi9ncStKdFhYMlBWdWpORFJGcUhCb0NWYW10cFp0Mm94VC9PZS91aGJGekpFa0JMQWxNTytnN1RrSzdZa0tJNnJXSGtCdEtDcTVCUGp6cEx2YkJtYlQ5ZUxWYitrT1RndmJ0elczV2xBNEFycW1WZTZKY2NYYk9aS3FBN3YzSGZQdmk1ejM0V2pzZngxT1lvMkZianVDWko1ekpRNzRyZ2dlclZZSmR3MGZiMXF5aVJjb3hCM3drVmhxZk1TNmN4QUJyWHRRZFZZSFB2N2FVaUpiZml3cHZTdEc1QjV1bTFzL0N6ZDN3V25qNTVFcjdyNWRmRGVkR1cwaVpJQU1zNTQ4TldOS0JPcjg2Um1VRUhzSVFPeGN5b3p2c3VMMnlTcFRpWkYxckZOcVhQV01BTjNOdEkya2FjdmlRdVM0Zm1NYjBBSFJVL2dEczZ6UjFRUjJjVjdzSE1Kc2lnbzNzNnNKb2JZaS9INCtqWk0vRG5jZUxrZjcvanp1engya3hBVGhvN2dWa1BUR1d2Y3Vxc1VpN2pGMkFndFQxUE5HM05oV1lNMHdoWStWeWpQNVNsRE1vSXRQYWk2b0hBN1A3dHBoT1JHc2thT0xPMkRyOXk3OTN3eDQ4K0FqLytoaHZnWFhtZDQ4cWNBYWhZdUlWS1EzQTBHeW10R2hEWnJNaDdwUE8wS3Qzdk9xRzlOQ0M5UDBDQUNFMW1nSks2TUI0MGdXR0RhZWZscmRJaUVZTlFlYzAzaTJzVnFSTjM4dHlNVWljdTlMNk9WRGMyTFR5NFVTZERhMWJvTEQ3enpEUHdDNSs3RXg0NmRqU0NlS1ZJNXZnN21SYXZCc3JZcGp6QlpvTjBJcXoxR0pDM2lKZlFlSmREcDhmR1JWQ01xQjhubHRsRUZ2L2xIWSt5U0hYZWVXVlNWMmZuN2VHZU9uVUsvc0Z0SDRNM1gzZ1JmSGVVMXUrNExDMHlQakhkclNXQjVWcUJXRGMwcXl3ZzI3TXlpdmJIQm0xeXNKa1NpTzdDZ2FEejlDRHJHdmRBWGFPTGd6bHBmWnF4TUpKM0JYWDFiQlRod2E2MzRvUE9OalBVbVRoa2xVNlNta1ZnVUhRRUhRZnorMXBhVitOalR6NEJmL3J3dzNCcm5BVmNqVUpzUzVUS0NjanBTSklacDhXclVleDNFaUFkZTZDb0RFUVoyTElsVURSa1E4REFrSzBwTkQvQjRpL0JSYjJQcU1OU0tHV0phR2JlT0o4TTdPeklSN09CWjFwK2F5MzIyTHNPSDRRN1B2a3M3TnEwQ2I3bHFtdWl4TDRLcnQreEU3YndleUNLYWlFRmh4STdhTnBwOEFOWUpEWDdvWXNxcTErcjE2bFY4bE1qMnNwUitsYmR6ZSs4K0VWcEY4VkJsWXJsSEJXSmhTUHNuV0hQUXBYUUpSM1BGbVkzYStKYmo5VStjTlhybllUMmdRVkpBdkVqY1lMa3hzZjJ3czM3SDRmOTBTMlhnTHMxemdHc3hsODJNVmFTNjNTaXdVemc3SVk3K2xhYldaWG5HVEYyajhMaUhkZTcwcmloMlREVjd1R2VwQ2RvR0hDRm9SMWxSNXQycGozQms3ODZWbmF0VzROajYydndPdzk4Q1g3My9pL0JhM2J1aG45MHcxdmdEYnN2cWlOcnhVd1BiRlIwOFVpZVgvRUthTmNSb1crTDZRV3JvRG9HQ2tBc3MraUxIbEFkUnZjd0dBclBTaDg5cTB5S3VXa0JxaXhxZ1VwNUJXeWZJZHJKSHUwb0Y5R2dDTlZUUmF2MjlCMmFGMzE0UW9OcDRsOFdhdnBybms4KzlRVDg5cjMzd0wwSEQ4R1pmajBETjVzV1V3Wng4V1FrVHhlcXlaTXdVREdvT2lXb2hnekRTb1loTDh6a0JKMmJkem5jeUdJWWpMZWpsQ0lPZkNXcEFhcjNnUFBON3hiUVFqUnAwaU5KNlRXb1d5M3ZYdGtFYjkrekI5NTl4VlZ3K2JiellPdlU3a2V0Z2MyVk5VS1ZrWUVnSHBjaXNyQzZuR1FRUklOYXpaU2NCNnFCVWpEMTVpdjI4eklOb09KMWxOWVlBZXpOQUJiWXRtcnR2SnN0UWhKWDkyamRnVUhicDJ4ZVVIeWdqaCtnMHE1RGFFUnczRis3OURKNDQ0VVh3MzFSdTM3OHlTZmg5Z1BQd29FenAyRVRTZVRzbG92bnViM0pmVnFrY2pVbHRNWXg1eENrbmFCNXJocGQ0NVRPcDU1QnphQ1lZMFpsV2x3RXFDNDhvSmRsZ2dLTlBFNDdhbVV2Q01DcmR1MkN2eEh0NTdkR0JxMTIwL3JKVGJETU5MYWRpek5NUjZSQkJ3OUFGSGpwK1dLL3NlWUprbDBnYVZ3WXI5QTNLS1pWZUR2NVJ0TE9TMThsR0xpNkl6QzFKWnEwWnJydUN1RFp3aWdkUE5XOUxMblZYR2M1VlB6b2pxYWJQR21BcmRFMmZzdkZlK0N0bCt5QlkydG40SXVIRHNHSDl1K0hMeDQ3VXZhTHgvSUZrM1FpWlJvWi81N3Z3RnhSYit1S2hhQnhPT1JnYzFDSU1HU3AvLzV1VUpCSWFyQXRwVnBDcHBianZ3czNiNFlmdU81NitHdTdMOHIzK2MwcThJLzZpd2FJTFQxbDRvQkdTUVBudXdHRzBLdDhteG53Q0FvaG9LVTFVcWZSL2RrSUVoOEMybnVoTFJQcVBUUnBBWFU2MGczaXVBaWtQVmhTUzJ5RmVhZEp3V3JlWk41MGx0UmdBYXlCRGZxYWVNVXZxcDIvdWdtK2JzK2w4RFVSM0hjZU9nRC81b0VINGJrSWNwMjIzWG5STVFHYktWdXhIbXFjeHZpaDdSTW9YNEtqdEFDOUR4Q0txWUU0TEU1RzNpcWE3ZGZFc2JRbzMzZGZmUzE4eHhWWDUrMThqVVRXNTdYV1ZrVUgyN0hCVmFBMEVsS2prZk0rcUE3bFh0REd2TjFtTFN1SExwankwWEduSWRlcVVCa0p2dDA0TGM1SjY1V2dTY1BJNXRDMThpcXVWUVNlOFFWYVNDWVIwTmtKQ21KTjAvOGN3Q2h2WG8rUXZTa3lFSTBSYjR1YTlnMDdkOEVmUnovMEgrNTduRlpVcXNBTkhRZzJtblduZ3BET01WUlhLaWc4dHZpU3pvMGZ1aVdad1QzQVBieGNsMExRaTMrWFNhNVUvSE5lOUZ6ODVLdGZCVytKZzc2VWZCYkErRDM5d1NHNDMwRVJXcnFXalJYSkJZUmdqZXd1STBra01OaDY5STFNMnhnZGlvQTVXRzQrUGYrdUxkdldtN1VjS2hNQUJDWHljcjFrbzFxVlRvUFNYZ2JBSTRKRVlZbUFWdUxMdWl3d0NKdGpPMy9mdGRmQjFkdTN3YTgvOUNBY20vVzg0V1dkRVRiMkwvK3hxbzVCRFhwUUR2UDVKeVlIS29OYlo4VDNjQ1FickJsQVZZekNrL0loUUJ4YTc0bCt5Wjk3emV2ZzJxM2JxMnNvZ0pIUTVoZHFKdHpKVzBIVXBMUmJKMzVvc2FlTm5sZXR6VklKUUVrcjF6a1ZIY2E4R3IwSFRnOHVFTjFHMUN4b0xxNG82dCtndUY3S3FudjFvZERHZytMOFlsSlAycXRoamdYTkUxQVNXbDNMeTBoaEtHUjZkZkgyaXk2Qks3WnVnNStPSHBFRFo4L21XV1EyYzdSZzVOUDBzcFZ3UU44RGFKc2M0a1dpc1ErMDNIWmEyckxOeFNZR1FFT0txL2NKbEUwVW1OWHgyVXVpYi9KL2ZmVWI0T3F0V3dYTS9RaVk1VjNjTUdTMHgxTUxRMEgyMXNVOHdtYTNveDR0bzNKWEZjYjFvZ3ZaelJiQWxhRkI2d0U4TDh6cmpjMzB1REJ2M2RTSXhVbUhaRDRoTVVya1MxZmJNR3V0YkM5MHhRNUhyUHhYZ3NUNG9ZUGpmMldqbE1QUDhjSkRvTzZualV4Ly9nMXZoSDk0MStmaFVIVE41bzI5bGFtRXJZcWhoN0FkaDRqSllkeGM1Ym1wajVCZlkwSlk2WWFnZHBObFZRY3NqT29MODhucGVYNWszdi81dWpmbDdTcUNBN1BzNXFXWUtjd1ludGJyVU0rSG4yV2hTQ2RXYmFoc09OTWlITTh2T29vZ3gwV3k4cTlFUVA0ckFHQnhFMnJIRU1GZFV2TnNYSzV6TjcvbmlJOGVsSFJXOXlRZEhSMUxkL3BsTWk3ZHZBVitJWUw2QTUvL0hEeWZIT0ZzQ21xTEFFQndsYWxEbW5GVzVVdWJhUGV5RXI0cHpIMlhneE0ybDhCcVBVZUFCUUp6R2dEK1dKelczaFBCM0RzZ2E2a01ZTldiem04ZWNhSDF5N05SV2tKRHhiS1dMRWtxQjZ4QXlBNit2a3FBK1h5Qk51Skg5ZU5JL0VieUNQYXlhaHQxTTN0VndsREZTR1U2NGcwMEt5aHRFbHl4YUNWMTVrOFEyWkdEMk5SS2cvS0E4Y290VytHSHIzc1ovTUpERDJRVGxOL0hibFc5T0ZweFh2Vkg0NDNKWWZkVnJnL28zMkdvQXhFa1JDYnBuRFlSZXYrVlY4Rzc0cWgzUnZ5Vmp4NkRWVzBNNUVXZ2JvR01uNUZCRUJLUWxhUm0rclZHNFltWE9tYXN6bit2NGtZRExoR3ZpY1p6ek1QRm9ja2JRY3hCSlltTEFHcU1mWkJNRHV5YWJqdmRFVFM0ZlpQb1RrcGtpQ0ZoTm4yQzJqYmZGTjE2WHpwK0RQNzQ2YWZ5aEJyb0JRTzVoNWhDUU1admRXSXNHSGI0eWJIcFVqekdzWHZpRUNLaTZQT21XUmtFZnNzbGw4cmR3WWFOQVl5N2JPQTZXeko0N1BDQWtPM284b0VzeXpPYTlKRnJrUE5pYXdjWTJHVi9CVU1GTk8rSGJVM0E2Z2xSVHdoZ3FLUHp4NmxLVzBxMk1Kd1RHSVRnekJCcVE3SHVsUG1oeGVoL2Q4MjFjTXR6QitCdzN4ZmVzN1lJdW5iQm5jSGdldXplWUZzM1lSUzBUQXJiT3dZVlRQWnpQNHZNNk9FZnZleDYyQjBkN3Q3VUdBQWJ5a3lXSDFtYlF6RVBZSGh1QXpVVVNTRnRTL00xSDJWTmlJNGt1anM2ZCtqbng5SzM3cDF6V2x5Y2RrQS9BNlE4aTRabTd1ejEwelRXVUY0b2NPZ2Q3K2UxajFsMklLaHovUnVQN1pNVitKK3ZmeFgwZVFmWldSbHJrVm9XTTRxYVVWTldoM2ZZYW5INW5YcmpYSjRVU1ZXbnNldWcwS2s5SUxkSmt0RFJ2bmp6K1JmQVczZnN0QlVNYlhORHNoZ2lzeG1raC9ydXlULzgwZzM3cnJDdFU4b0ZXWGpLTEJITjVndE9OaCtvUGoza2F5MkxQQXRCTzI4M25GWTNabjE1QjNYN2dEU1Jla1l6UThreFBSV0tsUzhlc0FEdHBnaWpGOE4wck93a3d2SHp6WEhpNVRYYnQ4TTlKNTR2NzN1STZ3MHNyNXFtUWdBenNZSTR0S0ZSZVRjcWI5QmtJN09GUnRncjFSYkt5anpyc3htOE4vb2ZKelFMNkQ5UHA2U0dnV0J5YTdkL1VDVVgyNmt0MVFYRUxLMm9rWU1iclZSZ0Z5OEkyMktvTzNjajRBYk1rUmN6TGJiU3E5RStpcm5VMFc4Z3M0QzR4dW41ZldRMk84QUtGRDQzZy9VUkFIdVE2MVd1VW5IeU5ULzNYU2phT0VwUitQWkxMNGU3N3Y5aUVSU3FnNVZIRURTNlpmWXdPRE1EY1dDQzFJa1ZJY3k5NUljMVhvTTVBTWdnc0RDZ3orYkdaZEYyL29ZNEVCUXByQTV0Wm94SlozMXZETmo2WGt1U0FnTlVnNXBFbWJ6OHd4S00vTFBTNEF0dGFOVXhYdEtneTdGbDZyWmlRQWZWR1VWcnNxS2lObUtidVpveEV6Q1pxbldjQTZnNUFVMFd0aW5sVy80TGZjRUIxaW56Qk9xdjNyMGJMbHhaaFlOUkFPWVBRZVQ5R1g3anp0WTdTQUdxckVaYmRiQnNVR3E1VWt2Z1RxWUdTZWUzNzdvUXRxYVBJSVArTEIyTW0yNGVtRDB6bHIyV2pwRGFVK3hGcUlNT3VzWk8yZEhzMXRNTFJzdFg0MWp2ZGFwem1PZEhEblRuODlKajQ5clJobncrbGxiRm83cUhhdndRbExFczBobkIyTUVCcXViVGtoWDhOY0M0aGcxRHJjbjVhenhjc0xJQzN4eTlIck0wNXVwRE5ibkUxYUlMQzB1TGtNVXYrRU9WeG1pa2N3RFJESW5ZdEhsaU5QVC9tejE3YkNYQ0VNUXRaa0FqRG5XY0VxeW15dWdsaUd0b01UUFVyNXpTbTJxY3RuZHBQVEd0YzRDaHpEN1h0TzVhcDBWM0w1L3lDMG4wam9TaEhWVW01cnJVdFg3ZVZKT05mWlFNWVNnOFdqUzJRdThTNk9XWTMzSFJSZkJ2SHRzTE9PbExweDE4VjFkL2d6SUZ3NXp5N0taQnJpYmEzUERBQ3ZLYmF0dG5RRytOUkwzMnZBdnM1SWsyT1J4ajVrbG5WUlRSQjFWeitvUWFCQjNOR0tSR1MrOURkMG9KeWVDS1BrbUNNblVjbkEwSEc3QjlYZkh6UTloWTFyZ2dyL3JLWG5ucENybFJzSUtnWTNPRUhoRVRqTmZtOEhscVFhbWlGNUxpeUFvajBseVBuMTRkc1hKQjFPYkhJM1k2WmU0Rkpid0c1Yk5wT0JLbUpvRS94MFltNkNyTjNvMUkxRlZ4TmloSVBBelVtU2JPTXlIWXJFY0ZqQTRCR3BKZjFLbFN4WW9adVF6ajFjQXF5YnNSQ2IxSURQbTBzR1I2blhhWk1seER5L01kR21ia0FTOTFIbzM3OGt4WFBVSHM2WEJGRE1xY2QzK2NUUE1yT0xDa3d1dWlSK3kybzRkcEoxbDZFM0lzZUh6cVh3cGxZcVVsblJxMXJNQ3JpTTV4YVpuV0tINnYyTFJsa0ZheUNFTm1oSkZmZlc1NlBuZzZoczlsNnNoMmxLcW95cGVHeGtHdkwxNFAraHBQTlhUcEFHMDZUSnBhdlB5TXBaVnp0R1hrNXloaWtOYlJVWXVpaVNLUEE5YnJBOG1ndnQ2UkFTU296Z0FEYjlRWXFOSGRHaE02MnRvUmdVZVJhVXE4UDN3b0MwUjI0ZFZkcnRDcWFIRlY0cUJjdmg2OEQrMFREUnBHSWJNdUhsNGs5T1ZiTmtzbHVJQitSRHByNEM4YldrSnM4THdhRUxIWlVkSVJjOWpOaFVvYXNCcE9MM0tFS3FuSCtBS042MVpqNHB4clhQRDh2TFJ5SHFySmtadFlPWCtUMXlDOUtvcnlEVmE1RjdpbmQ1MEJPN2ZKQU13QW94TGNuN2ZhSndWMjQ1bUJKNTJud1dHZlBXUkJGdjBaOUdnWUNzY3h3U0ZiVWpDREVHcWVZOHhtS2MxTTZETXhQVnljM3FpakFvTm1EbGptaEVhK0xXQWpqRXZxVVFaaWZURkp2L09MeW42dUpnWS9VdGFIa0kvdkVJY0V0SzQ5c1FEajRtdFI1VGFTRmx4NitoQVk1WDRCaEpnYTdKcW1Sa1daZk9xYW9JUWw0bG9renJzWEdrY0s1MCtuV1JpbTkrWW5RWmZCNE1HQks5Q1U1ZXpwNXR0MjNyMlhnUlBxbDl3YXpHbjVsaXlobzRkamhRY1p5UGRjdmlQWFkyMFpZQWhrZno1NGhpVXpZbTA0aWcrNnAycDlUL0g1bzFwd2xRZG9pc3RpcDRaeDBacnk3bFJhaVZ3aTMwVnArVHJVMlYzVXFNbHgvTjVLQVFmUzhnMjUyc3lqRmhlNTdWcWRHUnB0UlR4c0M1ZWF4QytEd2FSTzB4cDdQVXZvT0V3UGs2cE5RR0VQc2ZxZEVjd1lRWWZoVjkrdWtVS3cwWEk3YU5XaFAzK2QzNnZEa0JlRDY2WUVwNXRqUUs1MUFDaWpmaUE3bWwxVW9ab2hRTktxcTJCbkNuTERJd2dVaG02SldnTTBYZ0pITmJxMHRlZkFJaDFsMC9LOUlSMHkxeW1EWFB2cUtQdHl6Rk9zb2JJbUF3R2pCbkdvaEdncnBrRnBPNEw2bXJrR2JXNm94NG9tRDdROGM1QWJnaUhVN1dNTEVZMGJLZ0YyajVWUUdoQ0RwZEIvNWxJV2xPbUZLSGFNbisySEt6eG9jSStCMmwrM3puWFA5aXJNbEpkbXZ6SVRPa0E5b1dEY2M3VGdqRWlOcnZDRnlLK0REdDBxV0hzVllLUGtGNUxXMTB5bjgyQXVjWG5oSGlHWU9oYVBBVkRseHk4cE0zbzZHblN4SjRpWXlMZjF1emF0eFdmOHVhZFVTZzQyWGc4SU5halg4OHRzQUx3OUNISU9pQTQ3d2ZHTXNCaHEyaFJHSmxhd2ltTk5wRHBuWWlzekFodzRjOFlrRUdLQ2FqTVZXc3h5VkxUdklhaUpoTXFrbkJldERUMXcyeW5KVkRKUWtoVHBwS1AzR05FRGlJanR0TjVFVzFFRVN4QjFwSktLSlhrRDJOeUtVbVpYeTBOVnZoYVg0cjdwMUhWUUMzQ29vcnJhWWJJWnhoTXJQREJjRkVZYjRkeUNsN1ZIenE0RGU4c0V6Z0ZrM1pRQ1pXdzhQY1JvQ25aUU9DOElLSVBLUzFhTHpvQks2NXVOVlVLREc3QXRod1pGYW13Rmx4aUg5Sm0yVjlQZGJDK2lYbzZLWFhVcGlReXFVaWJPNUZEcExTRUF5a2kyQklyYlR6Y1RRbE1rcUxTb09XSTZWV2pHaVZ5aXVwVGxGd0lZa3dQN0tzZ0oxSUhmaFI1cjlPQisvZm1pc0tETmRMR0h6cHhXdTF5UjEweFd1d3JWdFNodDI4aEVoZVpPc25yaW9kYW5mamRZcnRVOVN2K2xvMGRNVm5vZFp6SHRHcmdRNmEzdklRdzZwQ0VUeHFRM0R3UmJFbG1CQXQxNURwMjdibkZ0REFYWWlCbnJkU05wVGM5MlBkU25UelQyVG1Mbng2cjZLbnpIK2gyVXBNWDZialF6VWgxc0duQWVWWmlCVVZnR3FCcXdwREVsbXZ1akEzVTY5ajcvUE4xVTVRR0JHNW1rT3NBRnc2S2crRmZpcC9PYURzVEJiWG50NkNmTjJNR2pKMDdZZkNpaE1SUFZ2U3dWNlg2djJ4T0hOQVZkT0xUcHpVbFkrblRraStiR2s3ZnU2R2w5N1hzOWpvRVdZT0FDOGdUTWVkVGNIRXNyclliRER1NERXd3lvMEJCb1lSbGVTVDR6RjB6ZDlCcDNUU3FESlVlSzE2QkRtMmFzS3VaQWU1M0NIWWNPNWdVZERWaEh0TGpHb0tlUGFiU2JCaEdBc2ZHUURocmcrc3VIRTdOMXVPZklFWGoxQlR0RUN4dENBWXhUbkVFTi9wNzZOZTZlTUtURFMrcmdwSElZdkhsR1EvdE9aY3JKNmJ0Q1NVdTN0QXNMdGFvT3RhRVo1MmJHVDJoU2NXajdoQzVIcDlWbGk2WnI4QUQxTTRWQVplZ2tCdmJsRGJ3QU1rc0s0cWVISmhJTlB6MjRBZ3hORlZTMG9RSy9sM29vSk9iemV3NGZoc05uejhLbXJadUJOV3Q1ckJwZ0dpOEJ4Z01YMDF4OU5QL3dad2RZa3dmdS9SRGNyQ3Btb0tSbmJucnFDWGdOQVpySEtraU5JdG92RENuQkZzR2FjZk5xWTU1UkVsbXRjV2RFQkFEWjAxRHFnd2kyMytpUFp3MExKSTN2cWVLQ2Q1cUVTR3Ftblp0M0dENDdTS3NCQkxYcy9OdXBYc0NqY240M2xEdWxBbnJ2ZjBFSml3RFc1QWpneDJJVnpLRjJRdk1zQnpYcytDLzdIaU53ODZLYW5KWHFsTkp1bHFHaEQ0TTRsWDJscVY3WUlVMk5EaVk5cTNta3JaSC8wOTVINGVqYVdUMGU4MWdhL0RxYTdMMFc0K1lGNWVFUVd4b2EzK1B4ZC96Nis3M1dONFBkeURIMnphRC8xbS9lZDRNYnlYdHVXcXgxb0xvR1h5NjREeDhrZm40UUxVaEFiYkUvS05DS3BGWWRVb1Nia2kwbjE5ZmhwaWVmelB0S29waUhYdXNPRFl6QUJTcjZOSEM2ZVJYUkJYQ0dyREwxMWc5OEpGdG8vK21UY09zelQxV2hDQ1BBNWh1dVVGN3J3UmhHMEVnN1FpOXdCVmxLbzNyZk9mdWI2eWMvU0dEZ09KUTB1TEdqZXdGeEc4blRIVnkzdkdLUzFFWEZxMDZLZ2lpMG5YNmt6ZHVNQlN1ZGh3SlNOTEtBVnduUzNLMkloQTgvc1IvMm5uaWV0bW11cnlXSXBBNnMrUlhRQ1VEQmxhMURlMHNLSFlFQW93WWwxTStYTU85UFdEWWovOTJISDRMM1huWmxaaWc2TG9uUE9EZ0doaEVpbEpyVDl5V0pabTRBQStRVWlWMXRTTFovNi9kN1duem9Pby8zbmdGLzVvU1hLcTBPSWh6MHRXSmE4WWFnVkhYb0FScVJ1bUNCR3dLTWFrdFVKV296RThES0Z2NTRLRTF4LytsamU4dUdVb1FkbWZocWNNSllDc3I5MHZyY2E2bk42d2Nka2xXUFRDV2htQjJKeU5zUEhvQlBIM2cycnhmTTlyTklhRVVUekZGVm5oQ0RhV3lyUWpaL1JHTm9qc29CWU5VRTFNa0h3VGxhT2hTZnNjVXduNVpQZmRwUmhxcTByVitYMXVTbHovdldiV0krelJuSmpjNEMydkN6WXFaa3lkOGFOdXFpOTVmTWJGTTB5SnlXTzI1NzVobTQ3ZG1ub2R1OGlTUTB2YU5OaFJRUEZaZzZ0K1JhSzRqSllmZzFndkQ2Zm1vcHpYeDdsbXpvMU9PbVV3aVRLZnpFN1orRUUydHJ3M0VaRFBIVmJEZ1A3akdhZkx3VENid0NhVlpWdEY1RkdJQzhjWkFud0h6TFI2YkFlTnB1R04rNjV2Umo5eGFsYmVWdHhHQ05zNjhBS1BPTGhKQnJZQmgwUU5VdUdHeWN0QjMvaE5xK0hiVEpPbkRxSlB6czdaL0pHT21tSzFrQWFqcGFVbGVFazJubk5pUWtLMU5oZWdJOVVNQktTUlJnTTRQU2xyZlJjYkl5aFNkT240SmZ1ZmN1c1pzNkIySlUrVEFqaEllb0RvNFBsci9lUXRHVnI3T0JaRDhTRWJ4b0l4b1FkRWJ0b2JJLzY2OWR0RVhIRFkrV1BlN1RkeTlhV3ZZdTFXc0hYS3lUS0tDQXpmYW9CNG44amh5YWRZTTRIcjlpbFFVVGRhVHJQM3IwRWRoNzZnUjBhcjl2K1F3dUkwcG5WdkZsNVIyYWVqSm0wMS9qdHNNQmVPdUxTa0dpaSs3UzM0M2w0dktIbXBoNzNHUTJoWDVsRlg0djJ0SnZ1L0FTZU0vbFZ4cTF4aE5YS0JuVGoxSjE4MEpMNjBzK0lwbjFPdEdkNmtVTVpMQU1GQjJLaGdlZ3VGUG9iYVFkQkdLdzdmMEFUWm5pMDBKRnkyQVNwelpjSFhnUUhVR0xUUkR6QTVWTndPN1ZJRGJya05kR2NLaWJUUXNvVkhLUjZzQ1NtZjFJK3ZqUVk0L0JyMy94M2dqbTFiS3BVUFp3ZENKc1JLaEttU2lzcTZhcEl4cnJnQkxBZXprYURWU1hYMlVHUTJPbWlSaWRYWGVURE9yVUEwL0Y2Si80OUNmZzhSUEhXOXB3S0xGUjUyYVpHUm8zakpSR1ZRY3RJc1RlNlpSL3VoUHBYSmN0NktvWWFhbDRveis3a1lxOEdHbFYyWFBwb0xRVGRIWFJZcEswbGVkSHArSWF2T1NJbHNXSC9seTFINE41b29yZzg2ZFBQZzgvZGZ1bkl5WUNkS3ZUTWlDY1ZJOVQwQmtDbUVrZm5nNnBuOUxCYU9oY0hVWXVHRFJvYjZPS1ovRWZpVXhteDJRbDJrZnhPQnhtOEhkdS9BdDRNbFpJcXg3KzFXMEVYQiswakpNeWxRUVBZM1RxNFhTbmdRRTBjS1Y3V0hkcTRuaHhlYm1HeDVFREdnZHVJUDJ5YVhGZWVxUkJsSkVXWU5MWER0TTRXazN1ZUJvYWJPWjI2a0NLR3h4VCtuMzA2Qkg0cmc5L0NBNzE2eGtYazJRN0o5T1VKYlJrQ0NRd2Erc0hWUlkwNkJzMHY3czJOckxFTVpQU3VaOXc2UlFTc2RpaWlkQkpsTkNUMVVoOFZDOVBuVGtEMzNQVFg4QURSdzRiS2UzYndIVEF4WjFSNk9YUmVhR0hwVnBuMy92TjBTVmVKSmgweEc1d2pzNW5iUTFGMVlGUjI3cmRhRnBZS20zWFRBc0w2YkEwRHlkY2JCc0JTMjJhV0dIelFnUkdzS2FIUC9naHhwbHV2d21CaW44ZlBId0kzditSRytHSlU2Y3lGaWFycXhrYldVSnJEY1QwVWFNSHdocEFvME5oYlhzZk9oZ0JTVE5vQ1kxUXU0OUJvNWJTa2ZoTnF6RGR2QXFQeFFyOTNRanFHL2Z0TlNxSmUzaCtOTmp5dlN0SjNFanV2cjdXWUJZQTUzZzFLR0pwVEdxYnZSOUdiV3UxYkk1VzNGajZqYWJGSmRQNnZNbGtFb2FXWndJT1RaYjYraWpWM2ZGUkwvL0ZmR2Z2Um5EdG85c3RTMms2V0JOLy9Nbjk4TDBmL2d2WWYrWTBURFlYTEdUTm5TU3owQWExWFJBSHBzNEE3R0JwOEtFYmZiQ1JVUVVNcVFQNXBZOHRPeVdCYURmUnJHSlNyOXkwQ1o2YnJjUC84TEZiNE5lKzhIazRHOC9GQXdKT1VzT1FlU0tGZzEzRVJqTzZkTEJPSkZ6UW5jMUxiTHBuMXNERFpRNVlNbDFKaXh0SXUzeSs3V1BnbWxNZGVDaXBBUmFxUHhlVUFKVXN1TzIwa0VwdCt5OWpHLy9BelRmQ2tYNFdCZG9tbUNZTXJLNWtUR0F5TnpwbFAzdEJLUVY2YzhRUjNjQ285WElnZ25lQllhZ1AxQmRQeXVnN3U4TFZ0a2VCRTJXVEZZdGJoaEZIakY2UDVzYy92K3NPK0k4UDNnOC8rN2F2aGErNzdBcm9xR2RXVlVPZzFuV0RPWnBEaDg2dHk2SEI1Y0FNVUQ2OXlxM2dSczdOa1NuZmF4SENCQnBDVWYxZEltMnJrczIwZE4yUDAxRmVVSUs2dkZsSHo2ZTZ6cFFyYjBIQXhxL3hYaWdnSndSOGROOWo4SE9mK1ZSK0JXS3lHb0c4YVNVZW0vSjRhaUtlamZvV3BPU001YVc0WXNMV09RNVU5eXRHSEpDVk44aDg5UjBhRlpGekxETTVxS2ErcTFzbHFObnhPbUxOZzVLUVBCNmc3SzBDN01lam4vb0hQdnBoZU1lZXkrRjdybjgxM0hEUkh0Z2VHU0JWUkQyNnRjUU5BTkpxaGR6aG5CUmowS0JxWkU1am5zZDJucTN6VmhvczNKbExxVWVLeERlZVczcVRHMmpZQTFUdnZIbU15a2QzV3EwTmc5V0d1aDhQcWtUblo5Ylg0Uk5QUEE2L2YvK1g0UFk0QTdnZVRjNEU0bXh1a21ST0UyN0pBOFpDaGRzNTZHeFZHL0c3SnhuSGxENDBxbGVKSzJHNmtFZG9NeEd6UTE0dGhib1hBWVJxS3JENjYzamJzU2xvdGRySG5qbzd1d1kzUC8wazNCUjc5Y3ZQdXdEZWZlWFY4TzZyWGdZdjI3RUxOaVcxQk5ia2dBWG5PU2dwSEpSYWswRVFuMmRTT2p2QllFQXdZTU55R2tMUzE1ZHNGdlZBazNmQWRpTzAwdllxUWxxY3dNdkNJTlUxMldoWkN5VzdPUUJQSm1WdFpteTZlcXAvVFRYbzVNVFpzN0R2MkJINHlHT1B3STN4ZU9Ma2lUajdGOGRPRWJ3ckVjUmRkZ3FzRnFrY3ZScmkwVUQxM2pOcmZtVGd3aWl2UkVqQy9HQTNEWklUQlB2bWZia1oyTXh3YjNNSHJxbis0bGc1K3ZPQ2dkay9YUm82L2V1N0F2WStNbUVXengrT2JyMkg0c3ppYjMveGJyamh3b3ZoKzE5N0EzemQ1VmZEaGdNRHRrUFRnWGlXTURoSlhjMFNWVlZzczgzSExzSXFBaXh1QVoxV25jekxXK0xKWXJCOW9IelJYbjRMditzSDRnRzh2YzBkUVgrVnJVTm8wSGQzbE1MLzR2YmI0QXNIbm9YMURzc2tTUVR5bEZ5MXhXVTd6V0RPUUo2d1pHWnpJWUN4anpsZXR3Mm90bWt4WktTTmxscE9WMmNVNUJvSHRhOWZXMkMxYS9RWDBIbXdxT2hSN3FqTHo5c0UzM2pKNWZEZUs2K0JWKzY4RUZZaStvTXpNNHg2R3FXMVNtTGpWOWFtQnpPcVEvdWMvQ3lIUWh5TERITWVXRkxNNDBiU3BqOWlSNmFqcjVuMDJaQW1FelR4SmRTNkl3NjhIQUJLMElmQmNDQ0gxMTI4QjM3MXZlK0QrdzhkaUo2TWZmRG5VY01lbksxVklPZjNOSnlmR1N3UGVFMlFvZFN0TGJ3UmpjakI3TEV5L0F3QmJMeWNDM0tKb2tCYmxXQzluVnhDWmRNL010MEM4RmZYMkNPOWJ0ckQxMXh5S1h6YlpWZkNlL1pjQVNzUjdiTlFONXJ4MVZ3VWNwcE9nVmtEdWJNdkphRUd0M0NXNjluQlVEYjVFVVpvbk5NMXdzajkxajBZend0eGZscHQ2SExhUENEc2dQZTh5UnZrOXNTTHZEOGdWcDg4RFliRmRsYjI4d0RrUVZFWS95U1Q4SWFMTDRXM3hQYjd3SnZlREI5LzVpbjR3OGNmZ1R1UHhybUdTWG0vcEpQQkg0QTJOY29NWmVFNUdsU1hPa2c2YmlPOTFNUGdkUUFiUDF3NXFSVks5emJudkt3V3liWEtiL1RkT2tqYW5qaVZsT0UxMjg2RG4zajVxK0R0YVIvRHZnQlk5ak5VREIwRGR2QUhkeVFqa2J2cWp5WGFoKzQ4TXFNS3AzTnVwWXJvb0lnaU80TFVEZFRkU2xkSmc0b0RucTgxN3hlV2xtaEdlcmVHK1YyTkRSbno4RFlQZHJKbzZPVUlJNytvekJKam9zUmpKWnFUNzRuZXF2ZGVmZ1Y4L01BejhNc1AzUmZuSFU0VzVRQ1ZkMFFBUlRaKzBYMTZwWGdnbFBqbkpFbTVualp2Y2x3WWtZdmNUU0VNNUllY1pZRVhLcE1URS9KSzZEMzg0d2prYjQvZWpRdW1xNFBkWmYxT3M1bC9vVFlvVjAwa0NKRXB6QjY0NWtEWnlRVGdmRzFuMzBRaWtFRXEvVk1HRUlxWFV0ZFFDY0FLdElJZEZ6ZkNSc0taWnRzRzBpSm90TXVlTnlxUzZTaE5sanB6cUx6b2NDQWcrQndhVWhwSWU3S1hrL2RNNFNQdDlaMDJySC9McnQzd2gwOCtEcis1OXhFNGxSSk53Q2pDSVppNUhJYzN3M0FjeGpmQ1lMSEdFUWliM282TnBRM01qcDZ1UXhXQTlyQWoybFgvNUpXdmdXKzk1TEtzL1dZa2xjME9zNkhTTVNvdEduR21zb21VNWtRSlZJWXlkaldEVTJDN3VzNmxVNzdCY1VQOWVtbmlyd2NodUxTK1p2NjNrUllka3luZk1HaE4zVHRKQ3FJYUZGS3k0QSt3Z3FSWHhmQW5lRXl4Rk5NVlVHK041c2o3cjdvTzltemFBdjlibE5iSHM5ZGxvblNMcHhBQllCeWtMQnM4UjFwaDJrclFBbmdyczBEZ1ptbXVQNjBxcHdobGQ2d2VMcDZzd0srLy9rM3c2dTNuWnhORHdCeVV1YUhBTFlBT2xvNHgyaVNRZTY2K093d0NZdU9YNXR5UUdRcTJkVHFjd3hWWTR0NUcwdVB3WEZ3WDZsNG1yWkVXZ3BJbExLb3IrdXBpbGVYNVltM1VPcmJtWjNRSTZzU2JIVE9sSFdiQlB2TTNvbjM5cXZQUGd4KzkrL1B3UkhUenNXalg0R1RwaktyVERZVlVXNmdONklNNnRXQU9MNHNRWUtCdWE5cGFRL1NGSldhbXJTbzJiWWJmdWVHdEF6RHJvMitCMlJFY1dvZVc2TUdXYlNrRmh4dHFoY3pOQUdiUmxubFlOSnhaTnB4RDJtWDZDT0x3Um5OaXhqOWN6LzByQmdPdER3cDhkRi96bm84a21WdnRldTJXN2ZDcnI3OEJMa29MbXllMVRGUExsaHJ1a0ZXR0x6bzhqWHcwNXo0SHZKeGpzeURYMHF1U1VOYjczUnpqZi9OMWI0SXJOMitwWU83TDBmY3d2bVd5Vm4zUUFMV1RCbUp6RXlEbEt3WnNkRWlTeWhLdmVnTzZmOE9ZOFRzdlZkcDVzUnIvdWk5V0J3NHFhMHZseGdOazAyWURQTXQxNzNpdk4xUmRkeUJlZDhlMVc3ZkJiMGRQeUJhZ3RhQjk0d0VxcXlsc3JQK0RxakR3eXd6KzBJbEVQeUI0VlcybFlGQ01LVnRVaE5rTWZqN2F6RmR1M3BvQnZNNWdkcEk1Z3h2cU43Y2F5UFBVb2Q5bU9mMTIxRkE0UUxFbUhXR0FCdTZhR013bllLRE9GeDB2VmRyUjlHRHJ4U2M4YmV6cnpRZmZUcnp5d3FTNWxUVWRKcjZoYVZQN3JvWGF6dXVVSnYxZXRta3IvUFQxcjh3Q1RvTjZnRjB2UE5FUjNzS25HbVMyMzA2Wkk1SHRiSWRsV3JsVnRraE9ZUDVBSEJpOGUvZkZVakVCdFR2MHh1Y01ZZ0U0d0dBSFdpKzV0ZFM0ZHNzMktIWVlHckZsZVJIVU9KRWxGcGxNZ2E2Vm9NQ1JBeFpjNHdhZVBhZThwVitHS29GZDI5a3hNWFZhU3AwMzdIRzhOcDJsMFlGeWV5QWQ2bGx0Y21USkRPVllVM0hmRXYzVzM1OCt4NXVWY1ZYR0NsSGtsYndaM05vcTFZbzF3dUxYclJvWkZkd1NCVUViQk1WRVNsc2t2eXFxbWUrTWc0SmUrWmhiUFY4a1FHK3ZQV0tEK3BVU2RUNUUwanQyN0M0M212eW9jQWlpZFNpZXBqbnJFclgrMlFZckZsekRCcDQ5cDd4RnloSDlwVWU2cCtqSlVDVTlSMzFURkRZaVNQUUJWVWlZTm9ES2QvRHRGNnlFWnhEM3dRcXg3NG1Bdm5yVHBnem9JSk1NV0RNVVRKMWJhQVBhWjRnMVBraU4xRzhvUFNyUUlMQ0xoUDVJbk1LK2NMcXBBbG5aelRQRmpMNTNJRlVNYXpLVHkxTWRRWGVPSDd6MFNyZ3UydXQxN2VwR1BRandRWU1YQjRsZVlOaG9vNXhMSXlwYTFYc2RobHVvNDB1ZEUyK3UyYndadnZ2aXk5cmpHQTlzYUpzZWNnOGFaa2l2ekE1bGVsd1F2VjMvOE5xWHcydzJLNFBFWG0wd0RnQ0dEOUtyWU5nc0k2QmZPQ2hFV0NDbEdPQlUyejVLNTlkdDJ3N3YybldSVkpRcnBFMExQYjNONm83cGJPQlo5NTNCb1J0aTEyUVZmdmFLbDBjcHNCbGt5em5KUXpNckVCODk4QU1NbmJMbmNzQkxuRDZBYm55cFI0QkJYWUpPRTVsMDFlcG0rUEhMcnhXQk13c0x2RXR0N0VCb3RRbURudG8xNXc5cXZCU1ByOW14Qzc1Mng4NGlwVU4xT2RiQzY5emlNa0ZqZEtvanN6a1JRck5TT2dibGlUck55djdtWkR0L1o1dzRTU0toTmRob1RXOTdCbzJGSUtXV0lQdEdoK29EVFJMN1RWdlBoLy83NmxmQmZ6ajhMTngwNGhqc1d6OWIzdTdMczJNQlpFYkZ1UVhxWUJFV0U4SXNXQ2FFbHpBdEFBRTVXQVF5NEduL20wazhyb29BL3ByenQ4UDdkMTBLTytMa3gzb1lkNWtPTURaR1FnRHhHM0RRcnl1a2U2bU1WS1g4QmtjOFg4VUpmT3RGZStBVGh3L241ZU93bzB5NFF4SU9CK01CcVBjOEc2UVpyL3pjNTRLaGJpd2w5eVJtbEpJVTZSMk5aT2ozYSt0dzlYUUZmditOYjRXdDNWVFVURlk3b0x3WldpaXBvcGJxbEdnSFJmcXJDZlA1ZkdmdnlTQ3FZUnN2d28rd2dYbk9lVlR6MUNVY1ZzVjN4ckZ5V2hkaElXR05mSUxWWVB5ckpTVzNqMGpTb0R4TlVDWHVvdUI1cWorcDQrOExrK1JjNmNwTVh2bzkwNi9EKys3NEZEd1hadW83dzVSSlo4YzIybU1sNWdjT0M2ZlEzdFp0TkRpWkdoVHo4dmJJTTNqSHpqMndYZlgrQkdSalpzQmlNR3NLc0VXQ0FrMnZIa2cvSFZlcXI5TzFNZ3NlS3JDTmxGVjVvcU5CYnJ0eEN6U0pzN1FNZ21PdkFUblhxZEVUbW5rcEFzZUVRUXZRUmxzcVUzQVdiSHVNZ1ZuelJlS1VsRVpWSm45YmtMVW9TK29FOEZDbXg3LzlrajN3bTAvdWkyT3VYalo2S2pQUEFJT0d5VkVJaTRUZStQdlF3VkxjWW5RVkE4VTI2Nk81OGI3bzJXQm04SytSeVAxaU1BZFhERXRrUlk2cEw0TTZ2L21icEE1SloxWnp2RGEyZEhwZmdLT2hpWGRzbHk4TnFZR0g4NlZxY0hVejVQVDFIc0M4aEdDY0EyRzhPQkVpK2xjRzUxQi9OZmg5eHdPWTN5NmpwZ2ZXTnBBeEZZSDZYZEhMOGh2NzlrS1lUZ2tZdE9tbStXS0Jya0UzNG5pWS80SS9qa1ZhU0JiRHZvZnQwUjU2UlJ3UTlyMlZCTWJQT1hpNmhubU4wb3JMTDNzcVVBZVNDdG56Z1VwQ3NIUm12c0FTUVFNMk9FQ3J6aVFyYmJGQkQzUHExZWk0U0JmVkMxSHljdkpFVEsxQlh2UEFIQ3l2amFUVzV3QURJZVR6SEdzRHFRTzBFd1RWQmpLdkVFcjd2SHI3ZWRHV244RHg3TUlqVzdxUjIrQ3J0RG1GamdPNnFVNkQrUTJrUTlsZGw5N1pTQi9SZWpETHlEZlVBWU5tOUZ3MVBhY09qQ0V0TFZoalpRWXFVd09VeVRGV1BhazZnMWdCVGZaSFlXSW9FMlBDaFhIcGxzL1JwalAxNC95RGVwNDZDcGVwQWIzTUFCcGNlZ1lUMDlnU01xWmRYQjRMZzJva0xYRDBobEI2TW1ZU21mZW04M2JBeDQ0ZklRbmQxUmZlY2w0TmFRSXd0L0dXK3dTTE0vRmlSemhUQUgxMW5PSTJ6QXBnWnY5YURHTUE5ckE0R0ZDSDJuTlIxVCtGanU3cmRhbkI5ZkpXWEt0QWIzN2thSU1zcFdvVjZKbFdrYnpCZFFhbVA5ZzAwaWs0YmJEMU5ubm9PTEQ1bWlqWDBYcjFuTytBWEdlZDkxd2VVY0NSYTIyZW1iS284S3UzeERtRG80Y2dLQ2VEQlRBdVR3Um9RT3ZlWUl4VXpsU0xFQkNxMk56SS9zMHRXdzJUbVBrdHV3d0FCbEprbWRBQ3RjUlJSak1HT3NXWlg5ZGFac0RNMGI1UnFRRGhTSERFQktzcFdDb05hTytINE9PajE5S2JlYWVhUU9jOTRKZU9ZSTBVaHZ3Tjd0eDNuakFuMjZXRGFpQ05Jb01MckZKNjE4cHFlVlVpcUsyUld3MWw3QTR2bmFwRUdGMU9ONURJNDVmNXBYcmVmcVNNRXFndlhsMDlKNlpzbEhFZTFQbkhpeFd3RE5VaVRwc2R4bXNCTUJSUHJWL3VSRW9HMUF4VjUyVTU0QjdYaExFblJrd3huVDZVVG1Ca1N5dG9IalFhd0pNL3FGSVl6LzZjUU8yZTU4Ty9zWmVPNUJITEFwRUpvY0R2MlF1ZFdOOFMxUFNhNW9yM3BqaEN4WHl6eGM3dUJQSnlyS3JGLzdRMG1GdmJjd3dlaDl5Sm1kWkJJd1psWnpmdVdaMCtMS3cxOE5aYjFRMXdwS1RVb0R5djZNQ2FYS0lSZWpWSjBVS2o3akRPYmh1cHh2QmVXS3F2ekExT2x3OUlEYTVUOWFxdHBqeFJRZ2RyVStadlM0T0tGbXBnZExFTkhkd1R2U2FiRHVwZDJIaFVLaExtTS9sY3dxQ1hzbFNrYzk4cFErTVpuSlB2V0p3SFJsK0xGbTFnMHJQa1pvbXU4MUJTSGRUekhOY2FXN1NVU0l2b01ITE9FV084MzJpYmVERGpnblRtbWhIdTdvN2xzU2kwQVkzelNRbXRrL2ovYkQ5cnBCNDIwanloODRJRGMzVE9XS0lGaUVXTkVGUytCZ3lxNHdpWTZhYjNhZ3dHZlQ1L2NCMWpoTEN4RGpkaWNReWZVWFRBU0Y2TGdpNVBhejd2aXhZSmplMjgxNUs1WVhvNE05UzNucnNlYWJERkVwb05kRzFqdERnWHc0SDAzUmljZSs4NjF6QUE3Z2hLcmIxVkcwTHVLWnU0OXkwVzZqTm15YXJRYURETnJnYXRldENrK2FqQkY4YnFCakMwK1ZXbjRuR0JMcjhmbzJNRDhZdlNocEViV3BqbGExZVpvMnRyZHFLTG5zcWJIY0hHUTNzWkErL3QwSHQxTlZxTFh4eC8vT1R6MEF4Qm5oeVpjWHpob2Rud1BsNEIwV05pRUhEZVRSQVR5c2dTVlJpemJ6QXBBREF3TDRMdUZPcG1jT21YZVhuZGVncGdZT0p3WFBOWmVIRkRacmNYS21oWmUvRE1hU3RaK0k1dlVOU041KzZyVnphNlFZbFMxRWhtWThUSE5QY2RQOXJPUVVta3BZNndnYlRxV0RSUndBMHBDM1FqeUF0TFQ1MDhYZ1lieFBCT1YxdVpNTkxvd1hhVWZNK2xMOHNLUS8yTXlqRUdOVjB1Znc4dURWSUdDaDk3angyU0Y3RGtSU3grYm42emdhck9TeHNVYjVudUZQYWVQQUdBT0s2RmRNVmI5K1c2WkxyeEwxWUcrYUxzOWJIMzVFa3pBNnpiRmx6Y2drelBPWGhBRERwK1VHQ0FBb0RUNjJ2d1U3ZmVDQ2ZYemd5M3laaFR6a0NkQWhnL2F3WnlCK0lyNzdHQ216OWg4cDJFZ2EzcndMUWJJRVBwZEdjajdiOTIrNjJ3bGhhUXg5b1JEYWpuMEIvZ2hZUFo4RUxGR2JyZE0zeDk1K0dEd010TDRBdG9lSDZ5OHhIK25LKzFOTUpCNGdMcTA3TVozSFg0a0gzRERVMnlISVFCWWRpZ294S1cxVExNbDhJQUkrcTFJY0g0dVAvd0FiajM4TFB3MkxHakF6QmppM2JYUW9ZT0JPdlNoQllUN1hPZVpnUUhDRlFOUnVmOFd1WWpSdzdDM1FlZmhZY2pNTXhXSDFqcnIvbW5KN244MFcvd0NITU9VT1ZLQlIxZjd6MTZHSTZ0cjZzTm15d1Ayc2JEZk5CM3ZpY2JadnE4SksxeWNndDZ1N3dBNDBlZmZkcUNZUVRVZkM3MEJZQjVIVlI3REZvRWVrbXNKenM4T0JuWTZaM3B2QmZJVS92eUI1MDM3M3ZFYkpGaHdJMk9mdnJ0QjRVcmdsb2dwamd2ZmZWdlVIWFFyN3d5YlhvbnNkdWVlQXpPaEJuYy9QaERlYU9lQ2RvM0RYR01QR3lUdkd6QUJmbjVjdm5kZFcwcS9kbVRUK1M5NGRIWklzVkVScE1QanVYcjdyVS93Wkw4MGM2Q05iemNzbHNUcmZmOG41L2NGM3ZkMllwenNLQUdhREJ6cENjTkpLMENBMHVaUVhxMHowckhBUVVLdFJmUGVnVERCeDkvT0s5ci9KRW5IOC83Z3pEUXRRb1htOXJUeldWakkxNlZHM0QwMFZKMXRJMHREWW0xb2ZTbVBHbEc3RVEwa1c2Tm5URXRLUDZYVHoyZTY2SzN6aHQ4M0FERGpxOTV0ZEV3VDhOd2gyU2EwVjJmaXBMNW84OCtXUmJFejR2aUU0NG9CNkhUanlMVktUWm9xb1BDVVZHTzRGQmQrdzZER1F1WTAxY0hhVytOVHgwOElOS3RwZUkxUjdUUDFraGhQdFZwZ2dXdEp0bllzM1Q0dnFocFlnbWRBSEhvN0ptOG52RXpaMDdCYlUvdkw0RG9odW9iZEIxUXNVYWZhM3RhSGJwcVpuYlA1Y3YzMGNXTDF1Z0szUW5ROXh4NkZ2YWRlRDdUZnVETUdmam9FM3VsTTJwUUcyM3VDWVBhRG1HZVBlZU8wTWpEWHh2dEFsYnozZkxNay9CWUhCQVdDZDNST3RLVklTaE1ybHhvMnRqR0JPQkJvUVkxNnRaeEQrcGZVemhtd2hLZzAzWnV2LzNvZzFGYTlIYWY1ODR4MkJYanB6bUZJZWdPeFNnTmZLUThBRzBkZlpuYzBGTnErRDk0NUFIYVQzRWxSazdnRHg1OUFOSWFIUU82dTZHMEt3WFU4b05saTZtTG9kUGZWNTJpVTNYV0hVb0R1V3dlRytCUEV1MHJ0Tk5ZUFA3cjQ0L2srMU5WUDk0dlVIOFc1VnNRRzgyOVRQRG1wRDQwci9RbmN1bVlSV3o4MGVON0MxNm1FNmg3bGNNQW9DQnFEc0NxZTBjMG5YZUxLV1p5ZGJ6S0hNQks2VWpnWnc4ZmhrOGNlTmJhb3lvNzZibnBZVFdBTUpJTFFRWlk1Z0E3QU9NZ2o5SkpMcmRUUUFiMWZSdjlmalJLNTg5R0tWZjJBeW5BK1B5aDUrRG1hSHJrTkowRnRlZGZSeDBNR3V1ajY3RkJhNVVqYndKNGE4NXJFazM3U2p3KzlmU1Q4SmtEejVUT21HbWZ3TzN4K3JaWXA2a0N2djdXVXVNQkhRSXpMNVZkRTl5OXNDQ05WaVd5bFUybmdLek9iMzNtcVlpUmcyV1YvN1JWQ2R2UmhoRU9jOUJvN0VZWVdUbHAvQUVEY0FYc0JPWkoycmgrV25ZSi9jVXYzUTFIa2lydmhwSUdQWE1CbXBMTGQwZ3RmWDE2VkNkTVlsNkRFV0d3L1ZoaTdzblpHdnpTM1orajdjWm91OTYwb0dDOCtmTjMzWmsvNHZTMmFCTWNtcE91SW9NMDZLN3BPVzBuQzVoQmdScHEyUW1zYTVHMm43L3I5a3hySjdTWEhWcC84UXQzd3JHenB3WDhHdGlpcmJwR2gvTDhiUEVjaCswREZnYlZ2RkM4enI5UTZEZ1VhZnMvdnZTRnJBMFRYc3BxLzkzOFJtMFY3S0owTTdoYVVIQnEwcUpRSXFYR2JBZmxqZXNqcU84L2NReCs2Nkg3VFE5dDJYVmp6TkpCQzc4NW5YTklJc0xBSzhESDd6OThQK3c5Y1R5cnZkUUo4MEhuVDBWYitsL2ZkNCtSNWdMbURvWm1FTUFBckVZQzZtdkZ0azVkZXhPcGMrVnFjUDcyL1YrQ0o2TFBQMjlzU2tKa1F0dFI3NHQyNlovc2ZValMra04zUmkvMC9DQmNhMDArYjc0T3kzVUFNQjRXejdlMFBldnZQL0lRN0R0MXFtdzBsUFppNlNaMUUwN0IwNUJBbk5mb0t0VGxkRWU3SHhMRFZlYW9ESFN5ZmRqTFVUZXVYNFYvRjIzcHY0aGVEODlRTTJpQkJqaGdTQW82c3Z3OW4wZm5tVWtkS24xQy8yZjdIb1YvZGQrOXRPOTAyZWdtZGNRSmIwVVdqOSs0LzR2UkpOa3ZkcXN4UWJCaFJ2RTVxVnloRlJ0cDZEcm9mRUtWbnBwZmJHTHc3MGVlZUJ4KzY3NjdZYkpwaFd6bktlM1lPeTNhSnBvZy85ZTlkOEVISDN1a0xCdkF0bmRYWFhyaWVYRDBNRytEOHgwSGpYWjBmQWN3R2lYenZxdVNlYXFPRDBVcy9Pc29TREsvZWIvdlNmRndhS25HNjZPZ3hwMkF2QjJZbG82WFZBMzBMcXJZd3dER3JnbDhuVzNDQ25JR053OE1KeE15UFNMQlNTWCs3QmZ1Z1B1UEh4RXB6Y0FZbUNLS3VkMHlBRmRwV0dvYU5ZMXFNSVdsUWRQeDhMRWo4TTgrOTFrNG5lSUpFSk04bUozSUlDWEZweStSLzZmUGZCSWVPSEo0S09YQWFwclczdVZlZW9zVVZ1Y2l6ZFN6dml6bVZ3THpRMGVQd00vZGNYdmU0ekdiU1N0VG9yc2pUVk5BanZIM0Z5TGZ2eFR0MUNrOUsveW5RMHRRR1RBQzJNRWp0b0ZyVENOMThHQ1V0Y05LVnp2am84ZVB3azkvN2pNWkU0bkc2WVJveDQ0R2hZd25JQ0hKaktvNDlIalRlR1dDTy9DUjBrVnJKdEpyT0szcVJicjFxdnV1N3ZGOXBPL2g3My9xWS9EVXFlZU5sT1BLRDREdFFPMXR1R1ljT0hCcHFhU2tVd0x6ZjMvYlIrRjRuQTZackd5U0JVNDYya3N2ZzJKU3BGM2FBVFZ0cGZCREgvOG9QQmlmMHcwMTdXd2p6Z096c1N2QlNtTnRWbWc3bVE4R1F6cWVQUGs4L0Vpay9YQzBuN3U4c1dXTDlrbVcwTk40SEl0dCtJR1lmdi96eHd5d1dsNFE3UW5oSnMzWHdRSzhDL1krUDVlV0pCQzZRYlV2blQ4ZGFYLy9yVGZEbVNUd1dDdE9hVEJvR2xya3ArQlBSRmhMT2pmaThKcTc3N1ptcVRlU3NNVEpKekxLdURJZk52STZaYlFjMlByYU9xeWZQUXV6ZUt5ZE9nMDdJL0gvejllL0cxNTIzZ1YxRVJxMWFvOWZ4WEtNRkV0OVphNlc3aHBzek9qOTBWNys3bHMrQklmaXhFbmF0bmRLRzBWT2FDODlwRExTQW9KOUpHeDk3V3lrZnkzdlRiNW5kVFA4KzI5OEQxeTZiYnNzbkNPTDZHQ2xtZC9oMERTSEVkcVpuWm4rSU5VUkFFMmhTdEVuamgrRHYzZkxUWEFnMGxSb1g0MjBrNFJUdENmZXovcFpvWnRvdjJMVEZ2ajFyM3NYWEhYZStXWnBXMWxrSmtCek5hc2dSRHFXVjl3MUI5emFQRXVkS0FtRGYvREpLTkRpWkZ2ZXhEN1N6enZOZG5rVGUxNmlyUTVPTXNpZExjMlNlOEJNQitySmpoLys0ZjhGNWdYVUR6SHJ1RHgxRGF4ZWlTaUFhaHZGY0RMT0RQM1Jvdy9CVmR1MndTc3V1QURxckJBTVRRZ1lTbDR0dGIxZlUyemt6cnJsc3JxTngzK0pOdk1QZnZ3V2VEN0ZwZjJuYVEvcVRqWlQ3NnFHRVczVFNXSEhZcWY4azBjZWhpdTJiNE5YN3R4UjZXYWVkNjVEVWFXRVh1ZlpZZld1VFppSnBobHJQVDZ5ZngvOHlNZi9FZzVIYlpHQnZLbEl1TW1BZGlLRUFBNEVpdVJwK3FNNGxubFpCUFQxNTE5Z2xLcXg3eFZmRVlibms4NmFjVnJic2haYzBiOHgvcVpvNy8vRVoyK0RneXhFRXFCWHFxbVU3V2ZYdUlYdkFqQmlYclVVS3RCVUk4d0Y5TmlEZ3pnRWgyZVRSTnM2RFA2MUtFRnVqSldjeGQvRTNHM0ozdE5NaFNHNE5YTTdCUTU5M2VtQmxESXpqc1hHL0swSHZnaS9HQWRKWjdBVElCZEFUQ29nbEM5TFFOMFJFMm12dzFOUjY5eTBiMS8rb1BPYTg4NkQ4MFpvOSthUU5rVU1RQnFBbmxKOCtqMFpKZG92M2ZVNStPVjc3NGFUS1Q3U3ZiS3BSWHNuVEt1MEU3Q0ppTFVvZnYvOHNVZHoyMXg3L3Ztd1BkRU9saTVQb3hFZzZ0b003cUU5ZUgwKzh2MWYzdmVGeVBmUHc2bVlNRzlrVDZaUWNaRlcybVVEVUdJY2VoZVlzNlBuZ1RsSERVeU9GRWJlQUEraWsvb3ErdnZ5eFhmMTY5QkMxb0VXY0V6bXgvcGFORDNXcy9uQlpzalZtN2ZBVDd6K3ErQ2RleTZQRE9rRzY2NHhHVTFLY0FoK2JZT2VpUkxodG1lZmpnT2pPMkZ2dE4rSzV5S1pHS3Q1QWlLN3VicUpNRTczZmw3Wk1uOWFIOVgzYkQzUlQrYlRXcXJIR2x3ZWFmK1pONzhGdnY3U3kvS0F6SzhJWk5RMjJEcGdZOWFROXl6cWNoNDlmUHFaWitDZmZ2cVRjU3IrdEtPOXVPazZuaW9lb1QwUk1pUGFaNW4ydGN6elJQc3JvcVQrNGRlOEhyN2gwaXR6NldackVHaTc2d3k5Q21zVC9xWHpOQVA0bVFOUHd5L2Y4emw0NFBuajBSTkRBbVMxZW1UeS90OUtJeHBUZzhFZFFJSGNTV2VEZzNtQTFqZjc5ckl2WmhsVC9yRFIyTklBdktRQnI0QmQxcnhiejR5ZHJhMW5waVp3OUJFY0ljYTliZmRGOEozWHZCemVmZG1Wc0dVNnRhODR3cEN4cU9waUpFazhQeEU3enMzUk5mU2Y0N1RxcmM4K2xTY2RwbmtXamNBZ2R1ZEVBREVhQXRBcTgzMWVuRHVET1kwTG9oM2JuMDIweitDckw3NFkzbmZ0dGZCTlYxMlZwZDVnU1ZxMHRPdUxUTCt5b1k5R2UvZldPUHYzK3c4K0NIY2VmQzZxNDdRaC9KUlVkT21JeFcvYktkcEhWS1RRWGtHZDZNL0FqblhvWW4xZXUyTW5mTWUxTDRmM1hINDFiSXQ4MHF0YzhhOE9udTlhMnh5UFBMazlBdmwzSDdvdjBuNmdERml6UkY2VmFmbUpUSE5QOGtORE1BT1lVVDhCR25YQjhyMWhJOUI5dlBhZWV5cnQvRUFJbFZYYUNCOE1EaXZhakpTbURoRm9oZlpBQTYwQzdKbEl1Z1JxWnZZMWNjRDFqWHV1Z0crLzVqcDRaV1IyS3JRbEpUU0RTOTBDM0hQNFVEWmwvbVR2SS9ETTZWTmxLcHQ4czh6UWp0UjBkZVJ6dmlpNEVKNEJyVVVTYUJGS0JzZGFBa2NCeFN3MllxcExIK20vYXVzMmVPZWxsOEw3WG5ZZHZDbDJVTm1QUlBqVzZKQlFBSDNYYzgvQmpmc2Voejk5OUZGNCt2UXBtaXlaaW45Y0JxNVRvbDFVTkVpRHEyYXIzQ0pROCtaTkJkaHIwakhUMHNlcFBhN2RlbDdlYi8xOTE3NE1YblhCVHVDbHhsdmFVV011Q2JHN0R6MEh0MFpmL1FlakFIbmk5SW5jQ1F2UGl3RHAyTVJJYnNXdWVHT0E1aXR5Zm1uLzlYVFNWZHM1bDU4TDZnU25BdUtncEFFVXlhMzVtcUhLZ0pZSWJvTWd6VzF1cExXZzdhcjlVSnBmSkhaR2NyNk9yQVFrU2QwckV5U0JPQUZoUmtkaWJtSjRrdGlwRWM2UERmcm1DeStHYTdhZkJ4ZEc5WDUrc2grSmdMV1l6L0ZvWHg2TW5wTzljVGJ5emdpSXcydG55anNCTkV2SkV3MVpLckI3aXlSYnAyeE9na1JGWGY2clVWanEwM09uVEVlaU4wdnNkYWxIbjRBZHdaSHFkMEVzNzgwWFhRVFhSRnQxOTViTmNFR2luY3BLdHV6UnFKME9uWTYwUjgvRjV5UHRCOCtjTlRPczJRK2VORXVrUDd2anBsVXFpNW1oR3pWM0hLd0xzN0RKcE14RDl0d2svczRHdEpmNkpOcDNSdHBmdCt2QzdJbmF2WGx6SENlczV2WG5Vb2dwOHVENHVkanBIb3ZteEYxUml4eUpuUnJGQjg2VEpWTTVUeTVRWkQ4NTFsRmxCbTFuQjRESmRnN0d4S2puRERjV1FseG5nS0dTellDR1ZoaXpvL21lQTNXR3RUSkR5QWRXMDVOYkx6TzJueFdKdmI0dVVydUFZcGFsU1U4YnN2UmtrNHZJTUhxdlU3T1RYUVgwWkNxREpsWng3TytVS1ZiZGMxSEx6R0RyenAwVjJLYjJ3RTZkY1ZiMkN5SGFXUnNGM2dYSjg1SlViV3JVVERjTjdqS1FKOU9xU1F6dFJMK2cyZFBlYmp1dFpSSTl6UHZBWmdocHpjVDd6SGZabmFvdjMwWHJzWklNeWdvdFFoZHBEbjZIcCtOT3lHMHk2U3B3MmRSQTYvYlJBRzRPQkZ0aDVONTA3Z01OUjdDVlo2eXVTL2RKZE1vSDRseUJRRnZ6cHNxbkRZVW1IYzAwOXFVaCs4UUladWlNVkNSdGJ4RjZKV21HNmdaSTRxSzh1dG9WaVVIcUxjZWpBckxvVFBWckVVS1ZxNEJHNnFCWmdtQTVXRnAyc3duMDB6aEpRMkJJQzc1bkxVUTdwZ2EvdnBmeStBanRrMDVldlVVQndSemFvZkZyUWdDMmVWZ2hzL1JMd09yN0pCMlRDUlA1bnJYS3RQQjlWanNyalBHZGFKZVg4aDN0eGE5TThaanVrWDBpTGprRTR4b0NCV2FwVHdQTVdnQ04xcnVFamEwK2FqTGt4a0tvaTl4cFVFdlhqcmY3QXVKVTJRUU9KSUQwWFdaaVZxV1JLYXphWlRNWjlxQUFHQ00wazlMVi9ieFJxV1FVa05NTFV3YkFsWEZvNnFVckY0b0VDVUd0QTEwNmR4N0VSVERrMXdRUzdkUkpRK3BNM0FGWmt0UG9WdlkvVWRLZzBLMjBoam1RN0h3RTgwcWxwMzIwVVF2UlRkb25wTm96ajB0NVlkSVgyalhmYVlKTStKNk9iZzd0SklVSG1sQWRBekNqbTUzV1VycFZKVGtmQjNNSzg3ZWs4TmNtS1Mvb1NBQVFCaENvWlJWd0VDQUgwQXd1d002MlZQbzB1aTl4eFV3SjR2ckx3SEtqS3YweVMvVzlGalVJWkk4Tm1DWFBjU2JZWnBqYVFBWFZhTXZRbnNzazJ2dFVaaG80VnJOS3o2QXVUVHY3d1Z1MEU3OHI3WXBvMDc1WXRhVkk2aGJ0U1VxSHpIZnVlTDNzcnhkcUhUaVBJdTZIdEpQLzNnZ1dKenc4c092em1uamJIcmdBdFBQQ2RJRDRSWmxwVHdqU0lDcjM0STdBWDZSUllRT2FmSkg5MUtvaVdWcVRmWngvSjUwQ0JWVEdVbnJKMzRBVXJZMnBRYnNJekQ1NGFaQ0w2L05DN2tIVnZlVFlaNmxYQml3aDg0RDNBYXkwZzZJZkxPMklEaVNjeEExY2NRSHRXdkFnT2w1cGttczY1SHdUblYyUWpoa0UxT0Q0RG9ZVzRidW1YVXRaSFNldkgrcG5vS2FGZW80RDNqZnFPaWNzYjNJTUNpSlFBM2RpUlExSjdqd1k2SU5kRVFnbldVMkQ4QlpGTWlDYkxaU0gyV0F1ZUpzRHJPbzFJS1o4aklSR1d3ZDVScFVwWkNxcHl2cVdPMXcyUlpqNHlRanRRZVVGQTF5Z3E4ZUFSbHllZHF4MmpPT1hUVCtnWFExWUJkeDByYnZmd0Z5YVI3dDBRQUFaK01sOVVKMVg1YUU2d1FzRmN3cFRqYlZtVUJXVnRId3lDdXBRSkZwS2xFMEt4ZXdRU0pxVFZPUEdSOHBVaEZvb0RHQkpnUjFVaWNQNTRSRFFBSUJPNVFWOVh6TzJQbUpQVlErc3AxUmVOalBTTmZuYU5ZOGcxQTFGU0wxTDV3YWlHWDJoMktBZFhOMFUwTTExYllweXFmaWxhV2ZOd2xxUzhoQ053M3dYY3dXRS93R0hnc1RTcnVqbWFyQkVWbWxxdlFDcXIvbkZCWE1LWnVOTnF4aHJ2ajUvYzg4d2lXem5USHhoRXRMZ1NocVhNRnlhVnpGWlNZS2dHYnNNSFU2Q01ZaWw4UVhFbFptMmZqcFhNcVc0b1Fna2dXMStCbWd5TDZoK3RTT2l2RHEzaU9aS3J1MlFmTTMxQ3FvRGFwa1JUSTRjRjFRK05UR2JiVEoyejBJR2xLU3U2WmFpR1N6Zm1jKzhLTG1oblVBcjVpa0RHWEd3NFpXMEc4TEF5R3lkdC9oc1RJNUJwOUMvb21hNWNDQXBDd0xLb09JTmdWb3FBSkpraGpwQmcxV0tvODZFSDJNYlcycUFoZ2xZaVRSU2dKbEhscXE2SnluMEl4SWJHQmNRTkFOTXZWbkRCS0tkMFJLVTFnSmRkOFZITFkxYXROZHpwRWxCSEtXZGZ3TFV6Z2RFT3lwZU1GU2xHWkUxaUdwWHFod2FMV2xwcitSWk1HdmFVZk85RVYvNEFuWUZXQlUvYUJQRUFaREJYZlB2dEpWb05LQWQrZnNHUUdKQ1lHNW5Td0hOTEtLdVlIQmJTeFVROGlydU9PeUdvM1M1RTdUTU13L1hubUIvVlRrQ3dsRGpVUkFraWJJMk1xek8vM1dkWUpCM20zYUZUQUk1ZW9ERENPMFdpeUJvZFB0VGlNUU9vYUxKUFN3UURVTXl4V3h4SkduYXpNY2dEaHRTanNxalZOY3hoZHZObGJjVVJtTjY2K1h3Uk90cmY0OHlLUGRVa1JyWTh1WVVXTjNBbUJCN1NXOXhRWWwwZTR3Q1FWMG9xU0VTUXovZkFyRFBTQy9zQWE3dXdSUEQwb2NrTXhmbTlpc2NGSU5RZVJrcXJlZ2IzblFBdEhWbzBXek9jUWphVWhGZ3lWbnBJTm9Od0dFSWFsTytvaE5nZnVkamZxcU9pekFIUzYzckZpYjlMOTJiYmpoVGJMU1dBVTh0aElXQ3JIT2xnY28ySEQyandRMUJEK1JhNHFJV2pJWTJkVXVCeGRJOVRLdmxnREVRZEoxUWd4cWdhaWdDSlB1djJZYWVSN3V5SzVlbnZVa3dLQU1HekZnZ0tCQXg3U0xSZzhxWGFDZUFCeVpnME13NExMRkZPMGUwT2lCV1NCdGgySUJVRTJlbVRCeW15eEw2WEFNRFY2NUJFVmg3aklDYUV5a2hvbFY2dVYwTktBMnlwclJvRTFWL1JoZzY5M0YvVHhmZDZwUk11eG9VVjZubE0yZ1YwQ2o5eTAxN1Rxc0VpODdwWFBoTytiUTZvQkUrblA5R3dMeEVPSGRBYzhIQjFib0JiTlIrV1pZYUd2Z2kvZVl4Y3NUK1FFZVB2NEh0cE1zeXpYaHd3TlB1QU1JaGVESmVHTzNuUXJjZTBNMmxYWk1IRzZBZFd2U1BnTmlrQVN2VUJubWVPNWhUZUdHQTFnUnNBTmc1V3RNdEVnU3kwaC91T2VpN01zSzRTb1RsZ1RBbUlYUzgwelpNcnBTUWNOR2huVmt6OUw4SXRHczZXalQ2ZUorK1FUdDdjMnBhUjdzWk0rajd1REhhY1VGSFdKVFdQUlpnZnBpV2R6S1UvNUV5MWU5RDEzcmowRmRKVWpvNGFUMlVEalp2VytueUU5UUZDNGVRQjVSb2xFR2xsVTNEbHFoUk5PdG4xTDNSSlc3Unl5VlVRQUJvbWxvWnB4MVJFWGo4cFgwSGptYksxOVJhaUFhZW1CblE3TW9kM0VORk0rZU5kV3lRMmNsdGl6VUg3bytvcExtbEdXMm5NR21wRFl4YkY0YzBXOUlWelRnZmR5NlBlV21uekRoOUF4MFQ2cXlYVFF0Z080R3ZWS0QwcUs4QnFRSmcwM0s1WUd1dWVBNGFtclZNVVBSNDhGSmEzVW13MGlWeGFxVGNwaGtrdDFKMm5iVlVwS29Hd0RiTkZHL0dNVERrZllub1ZMMUtKOWtRemFoeUQ1VUhtbmRneWxRMDU5bGNyTS9wZHVCaWRWcjBnL09DOUFEdStSYk5pSllPVlErTkJYUjhab3pLZmNwNzhISlNNeE5OcUF1RHdyV0t0dUxJTlloNkN0WHpYbnFid2xwVnRmYzRiMVhWUVhMZktYVzk1dExNWjQ1MnVSUENLRjB3WHFzQjdmWWUveXlnMldRM250YW9KY1VhUTN1cnZjZXEwYWxwYmozWXhBVTB5OHRzODdOdmhXWWF5dnVGMjlDanBlcmUybXJveGpQQjNSaUlyYkZud09xbnBiaXlHR0JOdXJtTUZnMkE0MmxnN0JsNGNXbVhQTStSOW5rODErclBQNzhNN1lqenIxK0U4UDhCMHN6dit0THJ4UndBQUFBQVNVVk9SSzVDWUlJPSc7XG5cbnZhciB2ZXJzaW9uID0gXCIwLjEuM1wiO1xuXG5jb25zdCBmYW1pbHlBY2NvdW50c0Nvbm5lY3RvciA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgRXRoZXJldW1Qcm92aWRlcihvcHRpb25zKTtcbiAgICByZXR1cm4gaW5qZWN0ZWQoe1xuICAgICAgICAvLyBub3RlOiB3ZSBkb24ndCBzdXBwb3J0IGB3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zYCBhdCB0aGlzIHBvaW50XG4gICAgICAgIHNoaW1EaXNjb25uZWN0OiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogJ2ZhbWlseUFjY291bnRzUHJvdmlkZXInLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdGYW1pbHkgQWNjb3VudHMnLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIGljb246IExvZ28sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0pO1xufTtcbmZhbWlseUFjY291bnRzQ29ubmVjdG9yLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG5leHBvcnQgeyBDb21tdW5pY2F0aW9uVHlwZXMgYXMgQywgRXRoZXJldW1Qcm92aWRlckNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgYXMgRSwgRmFtaWx5QWNjb3VudHNTZGsgYXMgRiwgU2Vzc2lvblN0YXR1cyBhcyBTLCBTZGtTdGF0dXMgYXMgYSwgU2Vzc2lvbkNyZWF0ZVJlc3VsdCBhcyBiLCBjcmVhdGVGYW1pbHlBY2NvdW50c0NsaWVudCBhcyBjLCBFdGhlcmV1bVByb3ZpZGVyIGFzIGQsIGZhbWlseUFjY291bnRzQ29ubmVjdG9yIGFzIGUsIGZhbWlseUFjY291bnRzQ3VzdG9tQWN0aW9ucyBhcyBmLCBpbnZhcmlhbnQgYXMgaSwgcHJvZHVjdGlvbiBhcyBwIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/family-accounts-connector-BEWV2sFJ.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/index-DD_kndDs.js":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/index-DD_kndDs.js ***!
  \***********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ index$1)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n\tm.forEach(function (e) {\n\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\treturn Object.freeze(n);\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar postRobot$1 = {exports: {}};\n\nvar postRobot = {exports: {}};\n\n(function (module, exports) {\n\t!function(root, factory) {\n\t    module.exports = factory() ;\n\t}(\"undefined\" != typeof self ? self : commonjsGlobal, (function() {\n\t    return function(modules) {\n\t        var installedModules = {};\n\t        function __nested_webpack_require_1042__(moduleId) {\n\t            if (installedModules[moduleId]) return installedModules[moduleId].exports;\n\t            var module = installedModules[moduleId] = {\n\t                i: moduleId,\n\t                l: !1,\n\t                exports: {}\n\t            };\n\t            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1042__);\n\t            module.l = !0;\n\t            return module.exports;\n\t        }\n\t        __nested_webpack_require_1042__.m = modules;\n\t        __nested_webpack_require_1042__.c = installedModules;\n\t        __nested_webpack_require_1042__.d = function(exports, name, getter) {\n\t            __nested_webpack_require_1042__.o(exports, name) || Object.defineProperty(exports, name, {\n\t                enumerable: !0,\n\t                get: getter\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.r = function(exports) {\n\t            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n\t                value: \"Module\"\n\t            });\n\t            Object.defineProperty(exports, \"__esModule\", {\n\t                value: !0\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.t = function(value, mode) {\n\t            1 & mode && (value = __nested_webpack_require_1042__(value));\n\t            if (8 & mode) return value;\n\t            if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value;\n\t            var ns = Object.create(null);\n\t            __nested_webpack_require_1042__.r(ns);\n\t            Object.defineProperty(ns, \"default\", {\n\t                enumerable: !0,\n\t                value: value\n\t            });\n\t            if (2 & mode && \"string\" != typeof value) for (var key in value) __nested_webpack_require_1042__.d(ns, key, function(key) {\n\t                return value[key];\n\t            }.bind(null, key));\n\t            return ns;\n\t        };\n\t        __nested_webpack_require_1042__.n = function(module) {\n\t            var getter = module && module.__esModule ? function() {\n\t                return module.default;\n\t            } : function() {\n\t                return module;\n\t            };\n\t            __nested_webpack_require_1042__.d(getter, \"a\", getter);\n\t            return getter;\n\t        };\n\t        __nested_webpack_require_1042__.o = function(object, property) {\n\t            return {}.hasOwnProperty.call(object, property);\n\t        };\n\t        __nested_webpack_require_1042__.p = \"\";\n\t        return __nested_webpack_require_1042__(__nested_webpack_require_1042__.s = 0);\n\t    }([ function(module, __nested_webpack_exports__, __nested_webpack_require_3506__) {\n\t        __nested_webpack_require_3506__.r(__nested_webpack_exports__);\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"Promise\", (function() {\n\t            return promise_ZalgoPromise;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"TYPES\", (function() {\n\t            return src_types_TYPES_0;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"ProxyWindow\", (function() {\n\t            return window_ProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"setup\", (function() {\n\t            return setup;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"destroy\", (function() {\n\t            return destroy;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"serializeMessage\", (function() {\n\t            return setup_serializeMessage;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"deserializeMessage\", (function() {\n\t            return setup_deserializeMessage;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"createProxyWindow\", (function() {\n\t            return createProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"toProxyWindow\", (function() {\n\t            return setup_toProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"on\", (function() {\n\t            return on_on;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"once\", (function() {\n\t            return on_once;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"send\", (function() {\n\t            return send_send;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"markWindowKnown\", (function() {\n\t            return markWindowKnown;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"cleanUpWindow\", (function() {\n\t            return cleanUpWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"bridge\", (function() {}));\n\t        function isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        var IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\t        function getActualProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return win.location.protocol;\n\t        }\n\t        function getProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            if (win.mockDomain) {\n\t                var protocol = win.mockDomain.split(\"//\")[0];\n\t                if (protocol) return protocol;\n\t            }\n\t            return getActualProtocol(win);\n\t        }\n\t        function isAboutProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return \"about:\" === getProtocol(win);\n\t        }\n\t        function getParent(win) {\n\t            void 0 === win && (win = window);\n\t            if (win) try {\n\t                if (win.parent && win.parent !== win) return win.parent;\n\t            } catch (err) {}\n\t        }\n\t        function getOpener(win) {\n\t            void 0 === win && (win = window);\n\t            if (win && !getParent(win)) try {\n\t                return win.opener;\n\t            } catch (err) {}\n\t        }\n\t        function canReadFromWindow(win) {\n\t            try {\n\t                return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function getActualDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var location = win.location;\n\t            if (!location) throw new Error(\"Can not read window location\");\n\t            var protocol = getActualProtocol(win);\n\t            if (!protocol) throw new Error(\"Can not read window protocol\");\n\t            if (\"file:\" === protocol) return \"file://\";\n\t            if (\"about:\" === protocol) {\n\t                var parent = getParent(win);\n\t                return parent && canReadFromWindow() ? getActualDomain(parent) : \"about://\";\n\t            }\n\t            var host = location.host;\n\t            if (!host) throw new Error(\"Can not read window host\");\n\t            return protocol + \"//\" + host;\n\t        }\n\t        function getDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var domain = getActualDomain(win);\n\t            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(\"mock:\") ? win.mockDomain : domain;\n\t        }\n\t        function isSameDomain(win) {\n\t            if (!function(win) {\n\t                try {\n\t                    if (win === window) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    var desc = Object.getOwnPropertyDescriptor(win, \"location\");\n\t                    if (desc && !1 === desc.enumerable) return !1;\n\t                } catch (err) {}\n\t                try {\n\t                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (function(win) {\n\t                        void 0 === win && (win = window);\n\t                        return \"mock:\" === getProtocol(win);\n\t                    }(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (getActualDomain(win) === getActualDomain(window)) return !0;\n\t                } catch (err) {}\n\t                return !1;\n\t            }(win)) return !1;\n\t            try {\n\t                if (win === window) return !0;\n\t                if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                if (getDomain(window) === getDomain(win)) return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function assertSameDomain(win) {\n\t            if (!isSameDomain(win)) throw new Error(\"Expected window to be same domain\");\n\t            return win;\n\t        }\n\t        function isAncestorParent(parent, child) {\n\t            if (!parent || !child) return !1;\n\t            var childParent = getParent(child);\n\t            return childParent ? childParent === parent : -1 !== function(win) {\n\t                var result = [];\n\t                try {\n\t                    for (;win.parent !== win; ) {\n\t                        result.push(win.parent);\n\t                        win = win.parent;\n\t                    }\n\t                } catch (err) {}\n\t                return result;\n\t            }(child).indexOf(parent);\n\t        }\n\t        function getFrames(win) {\n\t            var result = [];\n\t            var frames;\n\t            try {\n\t                frames = win.frames;\n\t            } catch (err) {\n\t                frames = win;\n\t            }\n\t            var len;\n\t            try {\n\t                len = frames.length;\n\t            } catch (err) {}\n\t            if (0 === len) return result;\n\t            if (len) {\n\t                for (var i = 0; i < len; i++) {\n\t                    var frame = void 0;\n\t                    try {\n\t                        frame = frames[i];\n\t                    } catch (err) {\n\t                        continue;\n\t                    }\n\t                    result.push(frame);\n\t                }\n\t                return result;\n\t            }\n\t            for (var _i = 0; _i < 100; _i++) {\n\t                var _frame = void 0;\n\t                try {\n\t                    _frame = frames[_i];\n\t                } catch (err) {\n\t                    return result;\n\t                }\n\t                if (!_frame) return result;\n\t                result.push(_frame);\n\t            }\n\t            return result;\n\t        }\n\t        var iframeWindows = [];\n\t        var iframeFrames = [];\n\t        function isWindowClosed(win, allowMock) {\n\t            void 0 === allowMock && (allowMock = !0);\n\t            try {\n\t                if (win === window) return !1;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (!win) return !0;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (win.closed) return !0;\n\t            } catch (err) {\n\t                return !err || err.message !== IE_WIN_ACCESS_ERROR;\n\t            }\n\t            if (allowMock && isSameDomain(win)) try {\n\t                if (win.mockclosed) return !0;\n\t            } catch (err) {}\n\t            try {\n\t                if (!win.parent || !win.top) return !0;\n\t            } catch (err) {}\n\t            var iframeIndex = function(collection, item) {\n\t                for (var i = 0; i < collection.length; i++) try {\n\t                    if (collection[i] === item) return i;\n\t                } catch (err) {}\n\t                return -1;\n\t            }(iframeWindows, win);\n\t            if (-1 !== iframeIndex) {\n\t                var frame = iframeFrames[iframeIndex];\n\t                if (frame && function(frame) {\n\t                    if (!frame.contentWindow) return !0;\n\t                    if (!frame.parentNode) return !0;\n\t                    var doc = frame.ownerDocument;\n\t                    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n\t                        var parent = frame;\n\t                        for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;\n\t                        if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;\n\t                    }\n\t                    return !1;\n\t                }(frame)) return !0;\n\t            }\n\t            return !1;\n\t        }\n\t        function getAncestor(win) {\n\t            void 0 === win && (win = window);\n\t            return getOpener(win = win || window) || getParent(win) || void 0;\n\t        }\n\t        function matchDomain(pattern, origin) {\n\t            if (\"string\" == typeof pattern) {\n\t                if (\"string\" == typeof origin) return \"*\" === pattern || origin === pattern;\n\t                if (isRegex(origin)) return !1;\n\t                if (Array.isArray(origin)) return !1;\n\t            }\n\t            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {\n\t                return matchDomain(subpattern, origin);\n\t            })));\n\t        }\n\t        function isWindow(obj) {\n\t            try {\n\t                if (obj === window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (\"[object Window]\" === {}.toString.call(obj)) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (window.Window && obj instanceof window.Window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.self === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.parent === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.top === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && \"__unlikely_value__\" === obj.__cross_domain_utils_window_check__) return !1;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function getFrameForWindow(win) {\n\t            if (isSameDomain(win)) return assertSameDomain(win).frameElement;\n\t            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll(\"iframe\"); _i21 < _document$querySelect2.length; _i21++) {\n\t                var frame = _document$querySelect2[_i21];\n\t                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;\n\t            }\n\t        }\n\t        function closeWindow(win) {\n\t            if (function(win) {\n\t                void 0 === win && (win = window);\n\t                return Boolean(getParent(win));\n\t            }(win)) {\n\t                var frame = getFrameForWindow(win);\n\t                if (frame && frame.parentElement) {\n\t                    frame.parentElement.removeChild(frame);\n\t                    return;\n\t                }\n\t            }\n\t            try {\n\t                win.close();\n\t            } catch (err) {}\n\t        }\n\t        function utils_isPromise(item) {\n\t            try {\n\t                if (!item) return !1;\n\t                if (\"undefined\" != typeof Promise && item instanceof Promise) return !0;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.Window && item instanceof window.Window) return !1;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.constructor && item instanceof window.constructor) return !1;\n\t                var _toString = {}.toString;\n\t                if (_toString) {\n\t                    var name = _toString.call(item);\n\t                    if (\"[object Window]\" === name || \"[object global]\" === name || \"[object DOMWindow]\" === name) return !1;\n\t                }\n\t                if (\"function\" == typeof item.then) return !0;\n\t            } catch (err) {\n\t                return !1;\n\t            }\n\t            return !1;\n\t        }\n\t        var dispatchedErrors = [];\n\t        var possiblyUnhandledPromiseHandlers = [];\n\t        var activeCount = 0;\n\t        var flushPromise;\n\t        function flushActive() {\n\t            if (!activeCount && flushPromise) {\n\t                var promise = flushPromise;\n\t                flushPromise = null;\n\t                promise.resolve();\n\t            }\n\t        }\n\t        function startActive() {\n\t            activeCount += 1;\n\t        }\n\t        function endActive() {\n\t            activeCount -= 1;\n\t            flushActive();\n\t        }\n\t        var promise_ZalgoPromise = function() {\n\t            function ZalgoPromise(handler) {\n\t                var _this = this;\n\t                this.resolved = void 0;\n\t                this.rejected = void 0;\n\t                this.errorHandled = void 0;\n\t                this.value = void 0;\n\t                this.error = void 0;\n\t                this.handlers = void 0;\n\t                this.dispatching = void 0;\n\t                this.stack = void 0;\n\t                this.resolved = !1;\n\t                this.rejected = !1;\n\t                this.errorHandled = !1;\n\t                this.handlers = [];\n\t                if (handler) {\n\t                    var _result;\n\t                    var _error;\n\t                    var resolved = !1;\n\t                    var rejected = !1;\n\t                    var isAsync = !1;\n\t                    startActive();\n\t                    try {\n\t                        handler((function(res) {\n\t                            if (isAsync) _this.resolve(res); else {\n\t                                resolved = !0;\n\t                                _result = res;\n\t                            }\n\t                        }), (function(err) {\n\t                            if (isAsync) _this.reject(err); else {\n\t                                rejected = !0;\n\t                                _error = err;\n\t                            }\n\t                        }));\n\t                    } catch (err) {\n\t                        endActive();\n\t                        this.reject(err);\n\t                        return;\n\t                    }\n\t                    endActive();\n\t                    isAsync = !0;\n\t                    resolved ? this.resolve(_result) : rejected && this.reject(_error);\n\t                }\n\t            }\n\t            var _proto = ZalgoPromise.prototype;\n\t            _proto.resolve = function(result) {\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(result)) throw new Error(\"Can not resolve promise with another promise\");\n\t                this.resolved = !0;\n\t                this.value = result;\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.reject = function(error) {\n\t                var _this2 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(error)) throw new Error(\"Can not reject promise with another promise\");\n\t                if (!error) {\n\t                    var _err = error && \"function\" == typeof error.toString ? error.toString() : {}.toString.call(error);\n\t                    error = new Error(\"Expected reject to be called with Error, got \" + _err);\n\t                }\n\t                this.rejected = !0;\n\t                this.error = error;\n\t                this.errorHandled || setTimeout((function() {\n\t                    _this2.errorHandled || function(err, promise) {\n\t                        if (-1 === dispatchedErrors.indexOf(err)) {\n\t                            dispatchedErrors.push(err);\n\t                            setTimeout((function() {\n\t                                throw err;\n\t                            }), 1);\n\t                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);\n\t                        }\n\t                    }(error, _this2);\n\t                }), 1);\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.asyncReject = function(error) {\n\t                this.errorHandled = !0;\n\t                this.reject(error);\n\t                return this;\n\t            };\n\t            _proto.dispatch = function() {\n\t                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;\n\t                if (!this.dispatching && (resolved || rejected)) {\n\t                    this.dispatching = !0;\n\t                    startActive();\n\t                    var chain = function(firstPromise, secondPromise) {\n\t                        return firstPromise.then((function(res) {\n\t                            secondPromise.resolve(res);\n\t                        }), (function(err) {\n\t                            secondPromise.reject(err);\n\t                        }));\n\t                    };\n\t                    for (var i = 0; i < handlers.length; i++) {\n\t                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;\n\t                        var _result2 = void 0;\n\t                        if (resolved) try {\n\t                            _result2 = onSuccess ? onSuccess(this.value) : this.value;\n\t                        } catch (err) {\n\t                            promise.reject(err);\n\t                            continue;\n\t                        } else if (rejected) {\n\t                            if (!onError) {\n\t                                promise.reject(this.error);\n\t                                continue;\n\t                            }\n\t                            try {\n\t                                _result2 = onError(this.error);\n\t                            } catch (err) {\n\t                                promise.reject(err);\n\t                                continue;\n\t                            }\n\t                        }\n\t                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {\n\t                            var promiseResult = _result2;\n\t                            promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);\n\t                            promiseResult.errorHandled = !0;\n\t                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);\n\t                    }\n\t                    handlers.length = 0;\n\t                    this.dispatching = !1;\n\t                    endActive();\n\t                }\n\t            };\n\t            _proto.then = function(onSuccess, onError) {\n\t                if (onSuccess && \"function\" != typeof onSuccess && !onSuccess.call) throw new Error(\"Promise.then expected a function for success handler\");\n\t                if (onError && \"function\" != typeof onError && !onError.call) throw new Error(\"Promise.then expected a function for error handler\");\n\t                var promise = new ZalgoPromise;\n\t                this.handlers.push({\n\t                    promise: promise,\n\t                    onSuccess: onSuccess,\n\t                    onError: onError\n\t                });\n\t                this.errorHandled = !0;\n\t                this.dispatch();\n\t                return promise;\n\t            };\n\t            _proto.catch = function(onError) {\n\t                return this.then(void 0, onError);\n\t            };\n\t            _proto.finally = function(onFinally) {\n\t                if (onFinally && \"function\" != typeof onFinally && !onFinally.call) throw new Error(\"Promise.finally expected a function\");\n\t                return this.then((function(result) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        return result;\n\t                    }));\n\t                }), (function(err) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        throw err;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.timeout = function(time, err) {\n\t                var _this3 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                var timeout = setTimeout((function() {\n\t                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error(\"Promise timed out after \" + time + \"ms\"));\n\t                }), time);\n\t                return this.then((function(result) {\n\t                    clearTimeout(timeout);\n\t                    return result;\n\t                }));\n\t            };\n\t            _proto.toPromise = function() {\n\t                if (\"undefined\" == typeof Promise) throw new TypeError(\"Could not find Promise\");\n\t                return Promise.resolve(this);\n\t            };\n\t            _proto.lazy = function() {\n\t                this.errorHandled = !0;\n\t                return this;\n\t            };\n\t            ZalgoPromise.resolve = function(value) {\n\t                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {\n\t                    return value.then(resolve, reject);\n\t                })) : (new ZalgoPromise).resolve(value);\n\t            };\n\t            ZalgoPromise.reject = function(error) {\n\t                return (new ZalgoPromise).reject(error);\n\t            };\n\t            ZalgoPromise.asyncReject = function(error) {\n\t                return (new ZalgoPromise).asyncReject(error);\n\t            };\n\t            ZalgoPromise.all = function(promises) {\n\t                var promise = new ZalgoPromise;\n\t                var count = promises.length;\n\t                var results = [].slice();\n\t                if (!count) {\n\t                    promise.resolve(results);\n\t                    return promise;\n\t                }\n\t                var chain = function(i, firstPromise, secondPromise) {\n\t                    return firstPromise.then((function(res) {\n\t                        results[i] = res;\n\t                        0 == (count -= 1) && promise.resolve(results);\n\t                    }), (function(err) {\n\t                        secondPromise.reject(err);\n\t                    }));\n\t                };\n\t                for (var i = 0; i < promises.length; i++) {\n\t                    var prom = promises[i];\n\t                    if (prom instanceof ZalgoPromise) {\n\t                        if (prom.resolved) {\n\t                            results[i] = prom.value;\n\t                            count -= 1;\n\t                            continue;\n\t                        }\n\t                    } else if (!utils_isPromise(prom)) {\n\t                        results[i] = prom;\n\t                        count -= 1;\n\t                        continue;\n\t                    }\n\t                    chain(i, ZalgoPromise.resolve(prom), promise);\n\t                }\n\t                0 === count && promise.resolve(results);\n\t                return promise;\n\t            };\n\t            ZalgoPromise.hash = function(promises) {\n\t                var result = {};\n\t                var awaitPromises = [];\n\t                var _loop = function(key) {\n\t                    if (promises.hasOwnProperty(key)) {\n\t                        var value = promises[key];\n\t                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {\n\t                            result[key] = res;\n\t                        }))) : result[key] = value;\n\t                    }\n\t                };\n\t                for (var key in promises) _loop(key);\n\t                return ZalgoPromise.all(awaitPromises).then((function() {\n\t                    return result;\n\t                }));\n\t            };\n\t            ZalgoPromise.map = function(items, method) {\n\t                return ZalgoPromise.all(items.map(method));\n\t            };\n\t            ZalgoPromise.onPossiblyUnhandledException = function(handler) {\n\t                return function(handler) {\n\t                    possiblyUnhandledPromiseHandlers.push(handler);\n\t                    return {\n\t                        cancel: function() {\n\t                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n\t                        }\n\t                    };\n\t                }(handler);\n\t            };\n\t            ZalgoPromise.try = function(method, context, args) {\n\t                if (method && \"function\" != typeof method && !method.call) throw new Error(\"Promise.try expected a function\");\n\t                var result;\n\t                startActive();\n\t                try {\n\t                    result = method.apply(context, args || []);\n\t                } catch (err) {\n\t                    endActive();\n\t                    return ZalgoPromise.reject(err);\n\t                }\n\t                endActive();\n\t                return ZalgoPromise.resolve(result);\n\t            };\n\t            ZalgoPromise.delay = function(_delay) {\n\t                return new ZalgoPromise((function(resolve) {\n\t                    setTimeout(resolve, _delay);\n\t                }));\n\t            };\n\t            ZalgoPromise.isPromise = function(value) {\n\t                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);\n\t            };\n\t            ZalgoPromise.flush = function() {\n\t                return function(Zalgo) {\n\t                    var promise = flushPromise = flushPromise || new Zalgo;\n\t                    flushActive();\n\t                    return promise;\n\t                }(ZalgoPromise);\n\t            };\n\t            return ZalgoPromise;\n\t        }();\n\t        function util_safeIndexOf(collection, item) {\n\t            for (var i = 0; i < collection.length; i++) try {\n\t                if (collection[i] === item) return i;\n\t            } catch (err) {}\n\t            return -1;\n\t        }\n\t        var weakmap_CrossDomainSafeWeakMap = function() {\n\t            function CrossDomainSafeWeakMap() {\n\t                this.name = void 0;\n\t                this.weakmap = void 0;\n\t                this.keys = void 0;\n\t                this.values = void 0;\n\t                this.name = \"__weakmap_\" + (1e9 * Math.random() >>> 0) + \"__\";\n\t                if (function() {\n\t                    if (\"undefined\" == typeof WeakMap) return !1;\n\t                    if (void 0 === Object.freeze) return !1;\n\t                    try {\n\t                        var testWeakMap = new WeakMap;\n\t                        var testKey = {};\n\t                        Object.freeze(testKey);\n\t                        testWeakMap.set(testKey, \"__testvalue__\");\n\t                        return \"__testvalue__\" === testWeakMap.get(testKey);\n\t                    } catch (err) {\n\t                        return !1;\n\t                    }\n\t                }()) try {\n\t                    this.weakmap = new WeakMap;\n\t                } catch (err) {}\n\t                this.keys = [];\n\t                this.values = [];\n\t            }\n\t            var _proto = CrossDomainSafeWeakMap.prototype;\n\t            _proto._cleanupClosedWindows = function() {\n\t                var weakmap = this.weakmap;\n\t                var keys = this.keys;\n\t                for (var i = 0; i < keys.length; i++) {\n\t                    var value = keys[i];\n\t                    if (isWindow(value) && isWindowClosed(value)) {\n\t                        if (weakmap) try {\n\t                            weakmap.delete(value);\n\t                        } catch (err) {}\n\t                        keys.splice(i, 1);\n\t                        this.values.splice(i, 1);\n\t                        i -= 1;\n\t                    }\n\t                }\n\t            };\n\t            _proto.isSafeToReadWrite = function(key) {\n\t                return !isWindow(key);\n\t            };\n\t            _proto.set = function(key, value) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.set(key, value);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var name = this.name;\n\t                    var entry = key[name];\n\t                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {\n\t                        value: [ key, value ],\n\t                        writable: !0\n\t                    });\n\t                    return;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var values = this.values;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 === index) {\n\t                    keys.push(key);\n\t                    values.push(value);\n\t                } else values[index] = value;\n\t            };\n\t            _proto.get = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return weakmap.get(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return entry && entry[0] === key ? entry[1] : void 0;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var index = util_safeIndexOf(this.keys, key);\n\t                if (-1 !== index) return this.values[index];\n\t            };\n\t            _proto.delete = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.delete(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 !== index) {\n\t                    keys.splice(index, 1);\n\t                    this.values.splice(index, 1);\n\t                }\n\t            };\n\t            _proto.has = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return !0;\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return !(!entry || entry[0] !== key);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                return -1 !== util_safeIndexOf(this.keys, key);\n\t            };\n\t            _proto.getOrSet = function(key, getter) {\n\t                if (this.has(key)) return this.get(key);\n\t                var value = getter();\n\t                this.set(key, value);\n\t                return value;\n\t            };\n\t            return CrossDomainSafeWeakMap;\n\t        }();\n\t        function getFunctionName(fn) {\n\t            return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n\t        }\n\t        function setFunctionName(fn, name) {\n\t            try {\n\t                delete fn.name;\n\t                fn.name = name;\n\t            } catch (err) {}\n\t            fn.__name__ = fn.displayName = name;\n\t            return fn;\n\t        }\n\t        function uniqueID() {\n\t            var chars = \"0123456789abcdef\";\n\t            return \"uid_\" + \"xxxxxxxxxx\".replace(/./g, (function() {\n\t                return chars.charAt(Math.floor(Math.random() * chars.length));\n\t            })) + \"_\" + function(str) {\n\t                if (\"function\" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {\n\t                    return String.fromCharCode(parseInt(p1, 16));\n\t                }))).replace(/[=]/g, \"\");\n\t                if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n\t                throw new Error(\"Can not find window.btoa or Buffer\");\n\t            }((new Date).toISOString().slice(11, 19).replace(\"T\", \".\")).replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n\t        }\n\t        var objectIDs;\n\t        function serializeArgs(args) {\n\t            try {\n\t                return JSON.stringify([].slice.call(args), (function(subkey, val) {\n\t                    return \"function\" == typeof val ? \"memoize[\" + function(obj) {\n\t                        objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;\n\t                        if (null == obj || \"object\" != typeof obj && \"function\" != typeof obj) throw new Error(\"Invalid object\");\n\t                        var uid = objectIDs.get(obj);\n\t                        if (!uid) {\n\t                            uid = typeof obj + \":\" + uniqueID();\n\t                            objectIDs.set(obj, uid);\n\t                        }\n\t                        return uid;\n\t                    }(val) + \"]\" : \"undefined\" != typeof window && val instanceof window.Element || null !== val && \"object\" == typeof val && 1 === val.nodeType && \"object\" == typeof val.style && \"object\" == typeof val.ownerDocument ? {} : val;\n\t                }));\n\t            } catch (err) {\n\t                throw new Error(\"Arguments not serializable -- can not be used to memoize\");\n\t            }\n\t        }\n\t        function getEmptyObject() {\n\t            return {};\n\t        }\n\t        var memoizeGlobalIndex = 0;\n\t        var memoizeGlobalIndexValidFrom = 0;\n\t        function memoize(method, options) {\n\t            void 0 === options && (options = {});\n\t            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;\n\t            var simpleCache;\n\t            var thisCache;\n\t            var memoizeIndex = memoizeGlobalIndex;\n\t            memoizeGlobalIndex += 1;\n\t            var memoizedFunction = function() {\n\t                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\t                if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n\t                    simpleCache = null;\n\t                    thisCache = null;\n\t                    memoizeIndex = memoizeGlobalIndex;\n\t                    memoizeGlobalIndex += 1;\n\t                }\n\t                var cache;\n\t                cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};\n\t                var cacheKey;\n\t                try {\n\t                    cacheKey = serializeArgs(args);\n\t                } catch (_unused) {\n\t                    return method.apply(this, arguments);\n\t                }\n\t                var cacheResult = cache[cacheKey];\n\t                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n\t                    delete cache[cacheKey];\n\t                    cacheResult = null;\n\t                }\n\t                if (cacheResult) return cacheResult.value;\n\t                var time = Date.now();\n\t                var value = method.apply(this, arguments);\n\t                cache[cacheKey] = {\n\t                    time: time,\n\t                    value: value\n\t                };\n\t                return value;\n\t            };\n\t            memoizedFunction.reset = function() {\n\t                simpleCache = null;\n\t                thisCache = null;\n\t            };\n\t            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + \"::memoized\");\n\t        }\n\t        memoize.clear = function() {\n\t            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n\t        };\n\t        function memoizePromise(method) {\n\t            var cache = {};\n\t            function memoizedPromiseFunction() {\n\t                var _arguments = arguments, _this = this;\n\t                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n\t                var key = serializeArgs(args);\n\t                if (cache.hasOwnProperty(key)) return cache[key];\n\t                cache[key] = promise_ZalgoPromise.try((function() {\n\t                    return method.apply(_this, _arguments);\n\t                })).finally((function() {\n\t                    delete cache[key];\n\t                }));\n\t                return cache[key];\n\t            }\n\t            memoizedPromiseFunction.reset = function() {\n\t                cache = {};\n\t            };\n\t            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + \"::promiseMemoized\");\n\t        }\n\t        function src_util_noop() {}\n\t        function stringifyError(err, level) {\n\t            void 0 === level && (level = 1);\n\t            if (level >= 3) return \"stringifyError stack overflow\";\n\t            try {\n\t                if (!err) return \"<unknown error: \" + {}.toString.call(err) + \">\";\n\t                if (\"string\" == typeof err) return err;\n\t                if (err instanceof Error) {\n\t                    var stack = err && err.stack;\n\t                    var message = err && err.message;\n\t                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + \"\\n\" + stack;\n\t                    if (stack) return stack;\n\t                    if (message) return message;\n\t                }\n\t                return err && err.toString && \"function\" == typeof err.toString ? err.toString() : {}.toString.call(err);\n\t            } catch (newErr) {\n\t                return \"Error while stringifying error: \" + stringifyError(newErr, level + 1);\n\t            }\n\t        }\n\t        function stringify(item) {\n\t            return \"string\" == typeof item ? item : item && item.toString && \"function\" == typeof item.toString ? item.toString() : {}.toString.call(item);\n\t        }\n\t        memoize((function(obj) {\n\t            if (Object.values) return Object.values(obj);\n\t            var result = [];\n\t            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);\n\t            return result;\n\t        }));\n\t        function util_isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        function util_getOrSet(obj, key, getter) {\n\t            if (obj.hasOwnProperty(key)) return obj[key];\n\t            var val = getter();\n\t            obj[key] = val;\n\t            return val;\n\t        }\n\t        function getBody() {\n\t            var body = document.body;\n\t            if (!body) throw new Error(\"Body element not found\");\n\t            return body;\n\t        }\n\t        function isDocumentReady() {\n\t            return Boolean(document.body) && \"complete\" === document.readyState;\n\t        }\n\t        function isDocumentInteractive() {\n\t            return Boolean(document.body) && \"interactive\" === document.readyState;\n\t        }\n\t        memoize((function() {\n\t            return new promise_ZalgoPromise((function(resolve) {\n\t                if (isDocumentReady() || isDocumentInteractive()) return resolve();\n\t                var interval = setInterval((function() {\n\t                    if (isDocumentReady() || isDocumentInteractive()) {\n\t                        clearInterval(interval);\n\t                        return resolve();\n\t                    }\n\t                }), 10);\n\t            }));\n\t        }));\n\t        var currentScript = \"undefined\" != typeof document ? document.currentScript : null;\n\t        var getCurrentScript = memoize((function() {\n\t            if (currentScript) return currentScript;\n\t            if (currentScript = function() {\n\t                try {\n\t                    var stack = function() {\n\t                        try {\n\t                            throw new Error(\"_\");\n\t                        } catch (err) {\n\t                            return err.stack || \"\";\n\t                        }\n\t                    }();\n\t                    var stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n\t                    var scriptLocation = stackDetails && stackDetails[1];\n\t                    if (!scriptLocation) return;\n\t                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName(\"script\")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {\n\t                        var script = _Array$prototype$slic2[_i22];\n\t                        if (script.src && script.src === scriptLocation) return script;\n\t                    }\n\t                } catch (err) {}\n\t            }()) return currentScript;\n\t            throw new Error(\"Can not determine current script\");\n\t        }));\n\t        var currentUID = uniqueID();\n\t        memoize((function() {\n\t            var script;\n\t            try {\n\t                script = getCurrentScript();\n\t            } catch (err) {\n\t                return currentUID;\n\t            }\n\t            var uid = script.getAttribute(\"data-uid\");\n\t            if (uid && \"string\" == typeof uid) return uid;\n\t            if ((uid = script.getAttribute(\"data-uid-auto\")) && \"string\" == typeof uid) return uid;\n\t            if (script.src) {\n\t                var hashedString = function(str) {\n\t                    var hash = \"\";\n\t                    for (var i = 0; i < str.length; i++) {\n\t                        var total = str[i].charCodeAt(0) * i;\n\t                        str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));\n\t                        hash += String.fromCharCode(97 + Math.abs(total) % 26);\n\t                    }\n\t                    return hash;\n\t                }(JSON.stringify({\n\t                    src: script.src,\n\t                    dataset: script.dataset\n\t                }));\n\t                uid = \"uid_\" + hashedString.slice(hashedString.length - 30);\n\t            } else uid = uniqueID();\n\t            script.setAttribute(\"data-uid-auto\", uid);\n\t            return uid;\n\t        }));\n\t        function global_getGlobal(win) {\n\t            void 0 === win && (win = window);\n\t            var globalKey = \"__post_robot_10_0_46__\";\n\t            return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};\n\t        }\n\t        var getObj = function() {\n\t            return {};\n\t        };\n\t        function globalStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return util_getOrSet(global_getGlobal(), key, (function() {\n\t                var store = defStore();\n\t                return {\n\t                    has: function(storeKey) {\n\t                        return store.hasOwnProperty(storeKey);\n\t                    },\n\t                    get: function(storeKey, defVal) {\n\t                        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n\t                    },\n\t                    set: function(storeKey, val) {\n\t                        store[storeKey] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(storeKey) {\n\t                        delete store[storeKey];\n\t                    },\n\t                    getOrSet: function(storeKey, getter) {\n\t                        return util_getOrSet(store, storeKey, getter);\n\t                    },\n\t                    reset: function() {\n\t                        store = defStore();\n\t                    },\n\t                    keys: function() {\n\t                        return Object.keys(store);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        var WildCard = function() {};\n\t        function getWildcard() {\n\t            var global = global_getGlobal();\n\t            global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard;\n\t            return global.WINDOW_WILDCARD;\n\t        }\n\t        function windowStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return globalStore(\"windowStore\").getOrSet(key, (function() {\n\t                var winStore = new weakmap_CrossDomainSafeWeakMap;\n\t                var getStore = function(win) {\n\t                    return winStore.getOrSet(win, defStore);\n\t                };\n\t                return {\n\t                    has: function(win) {\n\t                        return getStore(win).hasOwnProperty(key);\n\t                    },\n\t                    get: function(win, defVal) {\n\t                        var store = getStore(win);\n\t                        return store.hasOwnProperty(key) ? store[key] : defVal;\n\t                    },\n\t                    set: function(win, val) {\n\t                        getStore(win)[key] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(win) {\n\t                        delete getStore(win)[key];\n\t                    },\n\t                    getOrSet: function(win, getter) {\n\t                        return util_getOrSet(getStore(win), key, getter);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        function getInstanceID() {\n\t            return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n\t        }\n\t        function resolveHelloPromise(win, _ref) {\n\t            var domain = _ref.domain;\n\t            var helloPromises = windowStore(\"helloPromises\");\n\t            var existingPromise = helloPromises.get(win);\n\t            existingPromise && existingPromise.resolve({\n\t                domain: domain\n\t            });\n\t            var newPromise = promise_ZalgoPromise.resolve({\n\t                domain: domain\n\t            });\n\t            helloPromises.set(win, newPromise);\n\t            return newPromise;\n\t        }\n\t        function sayHello(win, _ref4) {\n\t            return (0, _ref4.send)(win, \"postrobot_hello\", {\n\t                instanceID: getInstanceID()\n\t            }, {\n\t                domain: \"*\",\n\t                timeout: -1\n\t            }).then((function(_ref5) {\n\t                var origin = _ref5.origin, instanceID = _ref5.data.instanceID;\n\t                resolveHelloPromise(win, {\n\t                    domain: origin\n\t                });\n\t                return {\n\t                    win: win,\n\t                    domain: origin,\n\t                    instanceID: instanceID\n\t                };\n\t            }));\n\t        }\n\t        function getWindowInstanceID(win, _ref6) {\n\t            var send = _ref6.send;\n\t            return windowStore(\"windowInstanceIDPromises\").getOrSet(win, (function() {\n\t                return sayHello(win, {\n\t                    send: send\n\t                }).then((function(_ref7) {\n\t                    return _ref7.instanceID;\n\t                }));\n\t            }));\n\t        }\n\t        function markWindowKnown(win) {\n\t            windowStore(\"knownWindows\").set(win, !0);\n\t        }\n\t        function isSerializedType(item) {\n\t            return \"object\" == typeof item && null !== item && \"string\" == typeof item.__type__;\n\t        }\n\t        function determineType(val) {\n\t            return void 0 === val ? \"undefined\" : null === val ? \"null\" : Array.isArray(val) ? \"array\" : \"function\" == typeof val ? \"function\" : \"object\" == typeof val ? val instanceof Error ? \"error\" : \"function\" == typeof val.then ? \"promise\" : \"[object RegExp]\" === {}.toString.call(val) ? \"regex\" : \"[object Date]\" === {}.toString.call(val) ? \"date\" : \"object\" : \"string\" == typeof val ? \"string\" : \"number\" == typeof val ? \"number\" : \"boolean\" == typeof val ? \"boolean\" : void 0;\n\t        }\n\t        function serializeType(type, val) {\n\t            return {\n\t                __type__: type,\n\t                __val__: val\n\t            };\n\t        }\n\t        var _SERIALIZER;\n\t        var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {\n\t            return serializeType(\"error\", {\n\t                message: _ref.message,\n\t                stack: _ref.stack,\n\t                code: _ref.code,\n\t                data: _ref.data\n\t            });\n\t        }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {\n\t            return serializeType(\"regex\", val.source);\n\t        }, _SERIALIZER.date = function(val) {\n\t            return serializeType(\"date\", val.toJSON());\n\t        }, _SERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _SERIALIZER[void 0] = function(val) {\n\t            return serializeType(\"undefined\", val);\n\t        }, _SERIALIZER);\n\t        var defaultSerializers = {};\n\t        var _DESERIALIZER;\n\t        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {\n\t            throw new Error(\"Function serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.error = function(_ref2) {\n\t            var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;\n\t            var error = new Error(_ref2.message);\n\t            error.code = code;\n\t            data && (error.data = data);\n\t            error.stack = stack + \"\\n\\n\" + error.stack;\n\t            return error;\n\t        }, _DESERIALIZER.promise = function() {\n\t            throw new Error(\"Promise serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.regex = function(val) {\n\t            return new RegExp(val);\n\t        }, _DESERIALIZER.date = function(val) {\n\t            return new Date(val);\n\t        }, _DESERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER[void 0] = function() {}, _DESERIALIZER);\n\t        var defaultDeserializers = {};\n\t        new promise_ZalgoPromise((function(resolve) {\n\t            if (window.document && window.document.body) return resolve(window.document.body);\n\t            var interval = setInterval((function() {\n\t                if (window.document && window.document.body) {\n\t                    clearInterval(interval);\n\t                    return resolve(window.document.body);\n\t                }\n\t            }), 10);\n\t        }));\n\t        function cleanupProxyWindows() {\n\t            var idToProxyWindow = globalStore(\"idToProxyWindow\");\n\t            for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {\n\t                var id = _idToProxyWindow$keys2[_i2];\n\t                idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);\n\t            }\n\t        }\n\t        function getSerializedWindow(winPromise, _ref) {\n\t            var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;\n\t            var windowNamePromise = winPromise.then((function(win) {\n\t                if (isSameDomain(win)) return assertSameDomain(win).name;\n\t            }));\n\t            var windowTypePromise = winPromise.then((function(window) {\n\t                if (isWindowClosed(window)) throw new Error(\"Window is closed, can not determine type\");\n\t                return getOpener(window) ? \"popup\" : \"iframe\";\n\t            }));\n\t            windowNamePromise.catch(src_util_noop);\n\t            windowTypePromise.catch(src_util_noop);\n\t            var getName = function() {\n\t                return winPromise.then((function(win) {\n\t                    if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;\n\t                }));\n\t            };\n\t            return {\n\t                id: id,\n\t                getType: function() {\n\t                    return windowTypePromise;\n\t                },\n\t                getInstanceID: memoizePromise((function() {\n\t                    return winPromise.then((function(win) {\n\t                        return getWindowInstanceID(win, {\n\t                            send: send\n\t                        });\n\t                    }));\n\t                })),\n\t                close: function() {\n\t                    return winPromise.then(closeWindow);\n\t                },\n\t                getName: getName,\n\t                focus: function() {\n\t                    return winPromise.then((function(win) {\n\t                        win.focus();\n\t                    }));\n\t                },\n\t                isClosed: function() {\n\t                    return winPromise.then((function(win) {\n\t                        return isWindowClosed(win);\n\t                    }));\n\t                },\n\t                setLocation: function(href, opts) {\n\t                    void 0 === opts && (opts = {});\n\t                    return winPromise.then((function(win) {\n\t                        var domain = window.location.protocol + \"//\" + window.location.host;\n\t                        var _opts$method = opts.method, method = void 0 === _opts$method ? \"get\" : _opts$method, body = opts.body;\n\t                        if (0 === href.indexOf(\"/\")) href = \"\" + domain + href; else if (!href.match(/^https?:\\/\\//) && 0 !== href.indexOf(domain)) throw new Error(\"Expected url to be http or https url, or absolute path, got \" + JSON.stringify(href));\n\t                        if (\"post\" === method) return getName().then((function(name) {\n\t                            if (!name) throw new Error(\"Can not post to window without target name\");\n\t                            !function(_ref3) {\n\t                                var url = _ref3.url, target = _ref3.target, body = _ref3.body, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? \"post\" : _ref3$method;\n\t                                var form = document.createElement(\"form\");\n\t                                form.setAttribute(\"target\", target);\n\t                                form.setAttribute(\"method\", method);\n\t                                form.setAttribute(\"action\", url);\n\t                                form.style.display = \"none\";\n\t                                if (body) for (var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++) {\n\t                                    var _body$key;\n\t                                    var key = _Object$keys4[_i24];\n\t                                    var input = document.createElement(\"input\");\n\t                                    input.setAttribute(\"name\", key);\n\t                                    input.setAttribute(\"value\", null == (_body$key = body[key]) ? void 0 : _body$key.toString());\n\t                                    form.appendChild(input);\n\t                                }\n\t                                getBody().appendChild(form);\n\t                                form.submit();\n\t                                getBody().removeChild(form);\n\t                            }({\n\t                                url: href,\n\t                                target: name,\n\t                                method: method,\n\t                                body: body\n\t                            });\n\t                        }));\n\t                        if (\"get\" !== method) throw new Error(\"Unsupported method: \" + method);\n\t                        if (isSameDomain(win)) try {\n\t                            if (win.location && \"function\" == typeof win.location.replace) {\n\t                                win.location.replace(href);\n\t                                return;\n\t                            }\n\t                        } catch (err) {}\n\t                        win.location = href;\n\t                    }));\n\t                },\n\t                setName: function(name) {\n\t                    return winPromise.then((function(win) {\n\t                        var sameDomain = isSameDomain(win);\n\t                        var frame = getFrameForWindow(win);\n\t                        if (!sameDomain) throw new Error(\"Can not set name for cross-domain window: \" + name);\n\t                        assertSameDomain(win).name = name;\n\t                        frame && frame.setAttribute(\"name\", name);\n\t                        windowNamePromise = promise_ZalgoPromise.resolve(name);\n\t                    }));\n\t                }\n\t            };\n\t        }\n\t        var window_ProxyWindow = function() {\n\t            function ProxyWindow(_ref2) {\n\t                var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;\n\t                this.id = void 0;\n\t                this.isProxyWindow = !0;\n\t                this.serializedWindow = void 0;\n\t                this.actualWindow = void 0;\n\t                this.actualWindowPromise = void 0;\n\t                this.send = void 0;\n\t                this.name = void 0;\n\t                this.actualWindowPromise = new promise_ZalgoPromise;\n\t                this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send\n\t                });\n\t                globalStore(\"idToProxyWindow\").set(this.getID(), this);\n\t                win && this.setWindow(win, {\n\t                    send: send\n\t                });\n\t            }\n\t            var _proto = ProxyWindow.prototype;\n\t            _proto.getID = function() {\n\t                return this.serializedWindow.id;\n\t            };\n\t            _proto.getType = function() {\n\t                return this.serializedWindow.getType();\n\t            };\n\t            _proto.isPopup = function() {\n\t                return this.getType().then((function(type) {\n\t                    return \"popup\" === type;\n\t                }));\n\t            };\n\t            _proto.setLocation = function(href, opts) {\n\t                var _this = this;\n\t                return this.serializedWindow.setLocation(href, opts).then((function() {\n\t                    return _this;\n\t                }));\n\t            };\n\t            _proto.getName = function() {\n\t                return this.serializedWindow.getName();\n\t            };\n\t            _proto.setName = function(name) {\n\t                var _this2 = this;\n\t                return this.serializedWindow.setName(name).then((function() {\n\t                    return _this2;\n\t                }));\n\t            };\n\t            _proto.close = function() {\n\t                var _this3 = this;\n\t                return this.serializedWindow.close().then((function() {\n\t                    return _this3;\n\t                }));\n\t            };\n\t            _proto.focus = function() {\n\t                var _this4 = this;\n\t                var isPopupPromise = this.isPopup();\n\t                var getNamePromise = this.getName();\n\t                var reopenPromise = promise_ZalgoPromise.hash({\n\t                    isPopup: isPopupPromise,\n\t                    name: getNamePromise\n\t                }).then((function(_ref3) {\n\t                    var name = _ref3.name;\n\t                    _ref3.isPopup && name && window.open(\"\", name, \"noopener\");\n\t                }));\n\t                var focusPromise = this.serializedWindow.focus();\n\t                return promise_ZalgoPromise.all([ reopenPromise, focusPromise ]).then((function() {\n\t                    return _this4;\n\t                }));\n\t            };\n\t            _proto.isClosed = function() {\n\t                return this.serializedWindow.isClosed();\n\t            };\n\t            _proto.getWindow = function() {\n\t                return this.actualWindow;\n\t            };\n\t            _proto.setWindow = function(win, _ref4) {\n\t                var send = _ref4.send;\n\t                this.actualWindow = win;\n\t                this.actualWindowPromise.resolve(this.actualWindow);\n\t                this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send,\n\t                    id: this.getID()\n\t                });\n\t                windowStore(\"winToProxyWindow\").set(win, this);\n\t            };\n\t            _proto.awaitWindow = function() {\n\t                return this.actualWindowPromise;\n\t            };\n\t            _proto.matchWindow = function(win, _ref5) {\n\t                var _this5 = this;\n\t                var send = _ref5.send;\n\t                return promise_ZalgoPromise.try((function() {\n\t                    return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({\n\t                        proxyInstanceID: _this5.getInstanceID(),\n\t                        knownWindowInstanceID: getWindowInstanceID(win, {\n\t                            send: send\n\t                        })\n\t                    }).then((function(_ref6) {\n\t                        var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;\n\t                        match && _this5.setWindow(win, {\n\t                            send: send\n\t                        });\n\t                        return match;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.unwrap = function() {\n\t                return this.actualWindow || this;\n\t            };\n\t            _proto.getInstanceID = function() {\n\t                return this.serializedWindow.getInstanceID();\n\t            };\n\t            _proto.shouldClean = function() {\n\t                return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n\t            };\n\t            _proto.serialize = function() {\n\t                return this.serializedWindow;\n\t            };\n\t            ProxyWindow.unwrap = function(win) {\n\t                return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;\n\t            };\n\t            ProxyWindow.serialize = function(win, _ref7) {\n\t                var send = _ref7.send;\n\t                cleanupProxyWindows();\n\t                return ProxyWindow.toProxyWindow(win, {\n\t                    send: send\n\t                }).serialize();\n\t            };\n\t            ProxyWindow.deserialize = function(serializedWindow, _ref8) {\n\t                var send = _ref8.send;\n\t                cleanupProxyWindows();\n\t                return globalStore(\"idToProxyWindow\").get(serializedWindow.id) || new ProxyWindow({\n\t                    serializedWindow: serializedWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            ProxyWindow.isProxyWindow = function(obj) {\n\t                return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n\t            };\n\t            ProxyWindow.toProxyWindow = function(win, _ref9) {\n\t                var send = _ref9.send;\n\t                cleanupProxyWindows();\n\t                if (ProxyWindow.isProxyWindow(win)) return win;\n\t                var actualWindow = win;\n\t                return windowStore(\"winToProxyWindow\").get(actualWindow) || new ProxyWindow({\n\t                    win: actualWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            return ProxyWindow;\n\t        }();\n\t        function addMethod(id, val, name, source, domain) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {\n\t                val: val,\n\t                name: name,\n\t                domain: domain,\n\t                source: source\n\t            }); else {\n\t                proxyWindowMethods.del(id);\n\t                methodStore.getOrSet(source, (function() {\n\t                    return {};\n\t                }))[id] = {\n\t                    domain: domain,\n\t                    name: name,\n\t                    val: val,\n\t                    source: source\n\t                };\n\t            }\n\t        }\n\t        function lookupMethod(source, id) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            return methodStore.getOrSet(source, (function() {\n\t                return {};\n\t            }))[id] || proxyWindowMethods.get(id);\n\t        }\n\t        function function_serializeFunction(destination, domain, val, key, _ref3) {\n\t            on = (_ref = {\n\t                on: _ref3.on,\n\t                send: _ref3.send\n\t            }).on, send = _ref.send, globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", (function() {\n\t                return on(\"postrobot_method\", {\n\t                    domain: \"*\"\n\t                }, (function(_ref2) {\n\t                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;\n\t                    var id = data.id, name = data.name;\n\t                    var meth = lookupMethod(source, id);\n\t                    if (!meth) throw new Error(\"Could not find method '\" + name + \"' with id: \" + data.id + \" in \" + getDomain(window));\n\t                    var methodSource = meth.source, domain = meth.domain, val = meth.val;\n\t                    return promise_ZalgoPromise.try((function() {\n\t                        if (!matchDomain(domain, origin)) throw new Error(\"Method '\" + data.name + \"' domain \" + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + \" does not match origin \" + origin + \" in \" + getDomain(window));\n\t                        if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {\n\t                            send: send\n\t                        }).then((function(match) {\n\t                            if (!match) throw new Error(\"Method call '\" + data.name + \"' failed - proxy window does not match source in \" + getDomain(window));\n\t                        }));\n\t                    })).then((function() {\n\t                        return val.apply({\n\t                            source: source,\n\t                            origin: origin\n\t                        }, data.args);\n\t                    }), (function(err) {\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            if (val.onError) return val.onError(err);\n\t                        })).then((function() {\n\t                            err.stack && (err.stack = \"Remote call to \" + name + \"(\" + function(args) {\n\t                                void 0 === args && (args = []);\n\t                                return (item = args, [].slice.call(item)).map((function(arg) {\n\t                                    return \"string\" == typeof arg ? \"'\" + arg + \"'\" : void 0 === arg ? \"undefined\" : null === arg ? \"null\" : \"boolean\" == typeof arg ? arg.toString() : Array.isArray(arg) ? \"[ ... ]\" : \"object\" == typeof arg ? \"{ ... }\" : \"function\" == typeof arg ? \"() => { ... }\" : \"<\" + typeof arg + \">\";\n\t                                })).join(\", \");\n\t                                var item;\n\t                            }(data.args) + \") failed\\n\\n\" + err.stack);\n\t                            throw err;\n\t                        }));\n\t                    })).then((function(result) {\n\t                        return {\n\t                            result: result,\n\t                            id: id,\n\t                            name: name\n\t                        };\n\t                    }));\n\t                }));\n\t            }));\n\t            var _ref, on, send;\n\t            var id = val.__id__ || uniqueID();\n\t            destination = window_ProxyWindow.unwrap(destination);\n\t            var name = val.__name__ || val.name || key;\n\t            \"string\" == typeof name && \"function\" == typeof name.indexOf && 0 === name.indexOf(\"anonymous::\") && (name = name.replace(\"anonymous::\", key + \"::\"));\n\t            if (window_ProxyWindow.isProxyWindow(destination)) {\n\t                addMethod(id, val, name, destination, domain);\n\t                destination.awaitWindow().then((function(win) {\n\t                    addMethod(id, val, name, win, domain);\n\t                }));\n\t            } else addMethod(id, val, name, destination, domain);\n\t            return serializeType(\"cross_domain_function\", {\n\t                id: id,\n\t                name: name\n\t            });\n\t        }\n\t        function serializeMessage(destination, domain, obj, _ref) {\n\t            var _serialize;\n\t            var on = _ref.on, send = _ref.send;\n\t            return function(obj, serializers) {\n\t                void 0 === serializers && (serializers = defaultSerializers);\n\t                var result = JSON.stringify(obj, (function(key) {\n\t                    var val = this[key];\n\t                    if (isSerializedType(this)) return val;\n\t                    var type = determineType(val);\n\t                    if (!type) return val;\n\t                    var serializer = serializers[type] || SERIALIZER[type];\n\t                    return serializer ? serializer(val, key) : val;\n\t                }));\n\t                return void 0 === result ? \"undefined\" : result;\n\t            }(obj, ((_serialize = {}).promise = function(val, key) {\n\t                return function(destination, domain, val, key, _ref) {\n\t                    return serializeType(\"cross_domain_zalgo_promise\", {\n\t                        then: function_serializeFunction(destination, domain, (function(resolve, reject) {\n\t                            return val.then(resolve, reject);\n\t                        }), key, {\n\t                            on: _ref.on,\n\t                            send: _ref.send\n\t                        })\n\t                    });\n\t                }(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.function = function(val, key) {\n\t                return function_serializeFunction(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.object = function(val) {\n\t                return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType(\"cross_domain_window\", window_ProxyWindow.serialize(val, {\n\t                    send: send\n\t                })) : val;\n\t            }, _serialize));\n\t        }\n\t        function deserializeMessage(source, origin, message, _ref2) {\n\t            var _deserialize;\n\t            var send = _ref2.send;\n\t            return function(str, deserializers) {\n\t                void 0 === deserializers && (deserializers = defaultDeserializers);\n\t                if (\"undefined\" !== str) return JSON.parse(str, (function(key, val) {\n\t                    if (isSerializedType(this)) return val;\n\t                    var type;\n\t                    var value;\n\t                    if (isSerializedType(val)) {\n\t                        type = val.__type__;\n\t                        value = val.__val__;\n\t                    } else {\n\t                        type = determineType(val);\n\t                        value = val;\n\t                    }\n\t                    if (!type) return value;\n\t                    var deserializer = deserializers[type] || DESERIALIZER[type];\n\t                    return deserializer ? deserializer(value, key) : value;\n\t                }));\n\t            }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {\n\t                return function(source, origin, _ref2) {\n\t                    return new promise_ZalgoPromise(_ref2.then);\n\t                }(0, 0, serializedPromise);\n\t            }, _deserialize.cross_domain_function = function(serializedFunction) {\n\t                return function(source, origin, _ref4, _ref5) {\n\t                    var id = _ref4.id, name = _ref4.name;\n\t                    var send = _ref5.send;\n\t                    var getDeserializedFunction = function(opts) {\n\t                        void 0 === opts && (opts = {});\n\t                        function crossDomainFunctionWrapper() {\n\t                            var _arguments = arguments;\n\t                            return window_ProxyWindow.toProxyWindow(source, {\n\t                                send: send\n\t                            }).awaitWindow().then((function(win) {\n\t                                var meth = lookupMethod(win, id);\n\t                                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({\n\t                                    source: window,\n\t                                    origin: getDomain()\n\t                                }, _arguments);\n\t                                var _args = [].slice.call(_arguments);\n\t                                return opts.fireAndForget ? send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: !0\n\t                                }) : send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: !1\n\t                                }).then((function(res) {\n\t                                    return res.data.result;\n\t                                }));\n\t                            })).catch((function(err) {\n\t                                throw err;\n\t                            }));\n\t                        }\n\t                        crossDomainFunctionWrapper.__name__ = name;\n\t                        crossDomainFunctionWrapper.__origin__ = origin;\n\t                        crossDomainFunctionWrapper.__source__ = source;\n\t                        crossDomainFunctionWrapper.__id__ = id;\n\t                        crossDomainFunctionWrapper.origin = origin;\n\t                        return crossDomainFunctionWrapper;\n\t                    };\n\t                    var crossDomainFunctionWrapper = getDeserializedFunction();\n\t                    crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n\t                        fireAndForget: !0\n\t                    });\n\t                    return crossDomainFunctionWrapper;\n\t                }(source, origin, serializedFunction, {\n\t                    send: send\n\t                });\n\t            }, _deserialize.cross_domain_window = function(serializedWindow) {\n\t                return window_ProxyWindow.deserialize(serializedWindow, {\n\t                    send: send\n\t                });\n\t            }, _deserialize));\n\t        }\n\t        var SEND_MESSAGE_STRATEGIES = {};\n\t        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {\n\t            0 === domain.indexOf(\"file:\") && (domain = \"*\");\n\t            win.postMessage(serializedMessage, domain);\n\t        };\n\t        function send_sendMessage(win, domain, message, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            return promise_ZalgoPromise.try((function() {\n\t                var domainBuffer = windowStore().getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                domainBuffer.buffer = domainBuffer.buffer || [];\n\t                domainBuffer.buffer.push(message);\n\t                domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then((function() {\n\t                    if (isWindowClosed(win)) throw new Error(\"Window is closed\");\n\t                    var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_46__ = domainBuffer.buffer || [], \n\t                    _ref), {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                    var _ref;\n\t                    delete domainBuffer.buffer;\n\t                    var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n\t                    var errors = [];\n\t                    for (var _i2 = 0; _i2 < strategies.length; _i2++) {\n\t                        var strategyName = strategies[_i2];\n\t                        try {\n\t                            SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n\t                        } catch (err) {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                    if (errors.length === strategies.length) throw new Error(\"All post-robot messaging strategies failed:\\n\\n\" + errors.map((function(err, i) {\n\t                        return i + \". \" + stringifyError(err);\n\t                    })).join(\"\\n\\n\"));\n\t                }));\n\t                return domainBuffer.flush.then((function() {\n\t                    delete domainBuffer.flush;\n\t                }));\n\t            })).then(src_util_noop);\n\t        }\n\t        function getResponseListener(hash) {\n\t            return globalStore(\"responseListeners\").get(hash);\n\t        }\n\t        function deleteResponseListener(hash) {\n\t            globalStore(\"responseListeners\").del(hash);\n\t        }\n\t        function isResponseListenerErrored(hash) {\n\t            return globalStore(\"erroredResponseListeners\").has(hash);\n\t        }\n\t        function getRequestListener(_ref) {\n\t            var name = _ref.name, win = _ref.win, domain = _ref.domain;\n\t            var requestListeners = windowStore(\"requestListeners\");\n\t            \"*\" === win && (win = null);\n\t            \"*\" === domain && (domain = null);\n\t            if (!name) throw new Error(\"Name required to get request listener\");\n\t            for (var _i4 = 0, _ref3 = [ win, getWildcard() ]; _i4 < _ref3.length; _i4++) {\n\t                var winQualifier = _ref3[_i4];\n\t                if (winQualifier) {\n\t                    var nameListeners = requestListeners.get(winQualifier);\n\t                    if (nameListeners) {\n\t                        var domainListeners = nameListeners[name];\n\t                        if (domainListeners) {\n\t                            if (domain && \"string\" == typeof domain) {\n\t                                if (domainListeners[domain]) return domainListeners[domain];\n\t                                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {\n\t                                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;\n\t                                    if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;\n\t                                }\n\t                            }\n\t                            if (domainListeners[\"*\"]) return domainListeners[\"*\"];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function handleRequest(source, origin, message, _ref) {\n\t            var on = _ref.on, send = _ref.send;\n\t            var options = getRequestListener({\n\t                name: message.name,\n\t                win: source,\n\t                domain: origin\n\t            });\n\t            var logName = \"postrobot_method\" === message.name && message.data && \"string\" == typeof message.data.name ? message.data.name + \"()\" : message.name;\n\t            function sendResponse(ack, data, error) {\n\t                return promise_ZalgoPromise.flush().then((function() {\n\t                    if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                        return send_sendMessage(source, origin, {\n\t                            id: uniqueID(),\n\t                            origin: getDomain(window),\n\t                            type: \"postrobot_message_response\",\n\t                            hash: message.hash,\n\t                            name: message.name,\n\t                            ack: ack,\n\t                            data: data,\n\t                            error: error\n\t                        }, {\n\t                            on: on,\n\t                            send: send\n\t                        });\n\t                    } catch (err) {\n\t                        throw new Error(\"Send response message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }\n\t                }));\n\t            }\n\t            return promise_ZalgoPromise.all([ promise_ZalgoPromise.flush().then((function() {\n\t                if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                    return send_sendMessage(source, origin, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_ack\",\n\t                        hash: message.hash,\n\t                        name: message.name\n\t                    }, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    throw new Error(\"Send ack message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                }\n\t            })), promise_ZalgoPromise.try((function() {\n\t                if (!options) throw new Error(\"No handler found for post message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                return options.handler({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            })).then((function(data) {\n\t                return sendResponse(\"success\", data);\n\t            }), (function(error) {\n\t                return sendResponse(\"error\", null, error);\n\t            })) ]).then(src_util_noop).catch((function(err) {\n\t                if (options && options.handleError) return options.handleError(err);\n\t                throw err;\n\t            }));\n\t        }\n\t        function handleAck(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message ack for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                try {\n\t                    if (!matchDomain(options.domain, origin)) throw new Error(\"Ack origin \" + origin + \" does not match domain \" + options.domain.toString());\n\t                    if (source !== options.win) throw new Error(\"Ack source does not match registered window\");\n\t                } catch (err) {\n\t                    options.promise.reject(err);\n\t                }\n\t                options.ack = !0;\n\t            }\n\t        }\n\t        function handleResponse(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message response for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                if (!matchDomain(options.domain, origin)) throw new Error(\"Response origin \" + origin + \" does not match domain \" + (pattern = options.domain, \n\t                Array.isArray(pattern) ? \"(\" + pattern.join(\" | \") + \")\" : isRegex(pattern) ? \"RegExp(\" + pattern.toString() + \")\" : pattern.toString()));\n\t                var pattern;\n\t                if (source !== options.win) throw new Error(\"Response source does not match registered window\");\n\t                deleteResponseListener(message.hash);\n\t                \"error\" === message.ack ? options.promise.reject(message.error) : \"success\" === message.ack && options.promise.resolve({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            }\n\t        }\n\t        function receive_receiveMessage(event, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            var receivedMessages = globalStore(\"receivedMessages\");\n\t            try {\n\t                if (!window || window.closed || !event.source) return;\n\t            } catch (err) {\n\t                return;\n\t            }\n\t            var source = event.source, origin = event.origin;\n\t            var messages = function(message, source, origin, _ref) {\n\t                var on = _ref.on, send = _ref.send;\n\t                var parsedMessage;\n\t                try {\n\t                    parsedMessage = deserializeMessage(source, origin, message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    return;\n\t                }\n\t                if (parsedMessage && \"object\" == typeof parsedMessage && null !== parsedMessage) {\n\t                    var parseMessages = parsedMessage.__post_robot_10_0_46__;\n\t                    if (Array.isArray(parseMessages)) return parseMessages;\n\t                }\n\t            }(event.data, source, origin, {\n\t                on: on,\n\t                send: send\n\t            });\n\t            if (messages) {\n\t                markWindowKnown(source);\n\t                for (var _i2 = 0; _i2 < messages.length; _i2++) {\n\t                    var message = messages[_i2];\n\t                    if (receivedMessages.has(message.id)) return;\n\t                    receivedMessages.set(message.id, !0);\n\t                    if (isWindowClosed(source) && !message.fireAndForget) return;\n\t                    0 === message.origin.indexOf(\"file:\") && (origin = \"file://\");\n\t                    try {\n\t                        \"postrobot_message_request\" === message.type ? handleRequest(source, origin, message, {\n\t                            on: on,\n\t                            send: send\n\t                        }) : \"postrobot_message_response\" === message.type ? handleResponse(source, origin, message) : \"postrobot_message_ack\" === message.type && handleAck(source, origin, message);\n\t                    } catch (err) {\n\t                        setTimeout((function() {\n\t                            throw err;\n\t                        }), 0);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function on_on(name, options, handler) {\n\t            if (!name) throw new Error(\"Expected name\");\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            if (!handler) throw new Error(\"Expected handler\");\n\t            var requestListener = function addRequestListener(_ref4, listener) {\n\t                var name = _ref4.name, winCandidate = _ref4.win, domain = _ref4.domain;\n\t                var requestListeners = windowStore(\"requestListeners\");\n\t                if (!name || \"string\" != typeof name) throw new Error(\"Name required to add request listener\");\n\t                if (winCandidate && \"*\" !== winCandidate && window_ProxyWindow.isProxyWindow(winCandidate)) {\n\t                    var requestListenerPromise = winCandidate.awaitWindow().then((function(actualWin) {\n\t                        return addRequestListener({\n\t                            name: name,\n\t                            win: actualWin,\n\t                            domain: domain\n\t                        }, listener);\n\t                    }));\n\t                    return {\n\t                        cancel: function() {\n\t                            requestListenerPromise.then((function(requestListener) {\n\t                                return requestListener.cancel();\n\t                            }), src_util_noop);\n\t                        }\n\t                    };\n\t                }\n\t                var win = winCandidate;\n\t                if (Array.isArray(win)) {\n\t                    var listenersCollection = [];\n\t                    for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        domain: domain,\n\t                        win: _win2[_i8]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                if (Array.isArray(domain)) {\n\t                    var _listenersCollection = [];\n\t                    for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        win: win,\n\t                        domain: _domain2[_i12]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                var existingListener = getRequestListener({\n\t                    name: name,\n\t                    win: win,\n\t                    domain: domain\n\t                });\n\t                win && \"*\" !== win || (win = getWildcard());\n\t                var strDomain = (domain = domain || \"*\").toString();\n\t                if (existingListener) throw win && domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString() + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : win ? new Error(\"Request listener already exists for \" + name + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString()) : new Error(\"Request listener already exists for \" + name);\n\t                var winNameListeners = requestListeners.getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainListeners = util_getOrSet(winNameListeners, name, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainRegexListeners;\n\t                var winNameDomainRegexListener;\n\t                util_isRegex(domain) ? (winNameDomainRegexListeners = util_getOrSet(winNameDomainListeners, \"__domain_regex__\", (function() {\n\t                    return [];\n\t                }))).push(winNameDomainRegexListener = {\n\t                    regex: domain,\n\t                    listener: listener\n\t                }) : winNameDomainListeners[strDomain] = listener;\n\t                return {\n\t                    cancel: function() {\n\t                        delete winNameDomainListeners[strDomain];\n\t                        if (winNameDomainRegexListener) {\n\t                            winNameDomainRegexListeners.splice(winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1));\n\t                            winNameDomainRegexListeners.length || delete winNameDomainListeners.__domain_regex__;\n\t                        }\n\t                        Object.keys(winNameDomainListeners).length || delete winNameListeners[name];\n\t                        win && !Object.keys(winNameListeners).length && requestListeners.del(win);\n\t                    }\n\t                };\n\t            }({\n\t                name: name,\n\t                win: options.window,\n\t                domain: options.domain || \"*\"\n\t            }, {\n\t                handler: handler || options.handler,\n\t                handleError: options.errorHandler || function(err) {\n\t                    throw err;\n\t                }\n\t            });\n\t            return {\n\t                cancel: function() {\n\t                    requestListener.cancel();\n\t                }\n\t            };\n\t        }\n\t        function on_once(name, options, handler) {\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            var promise = new promise_ZalgoPromise;\n\t            var listener;\n\t            options.errorHandler = function(err) {\n\t                listener.cancel();\n\t                promise.reject(err);\n\t            };\n\t            listener = on_on(name, options, (function(event) {\n\t                listener.cancel();\n\t                promise.resolve(event);\n\t                if (handler) return handler(event);\n\t            }));\n\t            promise.cancel = listener.cancel;\n\t            return promise;\n\t        }\n\t        var send_send = function send(winOrProxyWin, name, data, options) {\n\t            var domainMatcher = (options = options || {}).domain || \"*\";\n\t            var responseTimeout = options.timeout || -1;\n\t            var childTimeout = options.timeout || 5e3;\n\t            var fireAndForget = options.fireAndForget || !1;\n\t            return window_ProxyWindow.toProxyWindow(winOrProxyWin, {\n\t                send: send\n\t            }).awaitWindow().then((function(win) {\n\t                return promise_ZalgoPromise.try((function() {\n\t                    !function(name, win, domain) {\n\t                        if (!name) throw new Error(\"Expected name\");\n\t                        if (domain && \"string\" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError(\"Can not send \" + name + \". Expected domain \" + JSON.stringify(domain) + \" to be a string, array, or regex\");\n\t                        if (isWindowClosed(win)) throw new Error(\"Can not send \" + name + \". Target window is closed\");\n\t                    }(name, win, domainMatcher);\n\t                    if (function(parent, child) {\n\t                        var actualParent = getAncestor(child);\n\t                        if (actualParent) return actualParent === parent;\n\t                        if (child === parent) return !1;\n\t                        if (function(win) {\n\t                            void 0 === win && (win = window);\n\t                            try {\n\t                                if (win.top) return win.top;\n\t                            } catch (err) {}\n\t                            if (getParent(win) === win) return win;\n\t                            try {\n\t                                if (isAncestorParent(window, win) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            try {\n\t                                if (isAncestorParent(win, window) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            for (var _i7 = 0, _getAllChildFrames4 = function getAllChildFrames(win) {\n\t                                var result = [];\n\t                                for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n\t                                    var frame = _getFrames2[_i3];\n\t                                    result.push(frame);\n\t                                    for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);\n\t                                }\n\t                                return result;\n\t                            }(win); _i7 < _getAllChildFrames4.length; _i7++) {\n\t                                var frame = _getAllChildFrames4[_i7];\n\t                                try {\n\t                                    if (frame.top) return frame.top;\n\t                                } catch (err) {}\n\t                                if (getParent(frame) === frame) return frame;\n\t                            }\n\t                        }(child) === child) return !1;\n\t                        for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return !0;\n\t                        return !1;\n\t                    }(window, win)) return function(win, timeout, name) {\n\t                        void 0 === timeout && (timeout = 5e3);\n\t                        void 0 === name && (name = \"Window\");\n\t                        var promise = function(win) {\n\t                            return windowStore(\"helloPromises\").getOrSet(win, (function() {\n\t                                return new promise_ZalgoPromise;\n\t                            }));\n\t                        }(win);\n\t                        -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + \" did not load after \" + timeout + \"ms\")));\n\t                        return promise;\n\t                    }(win, childTimeout);\n\t                })).then((function(_temp) {\n\t                    return function(win, targetDomain, actualDomain, _ref) {\n\t                        var send = _ref.send;\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            return \"string\" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try((function() {\n\t                                return actualDomain || sayHello(win, {\n\t                                    send: send\n\t                                }).then((function(_ref2) {\n\t                                    return _ref2.domain;\n\t                                }));\n\t                            })).then((function(normalizedDomain) {\n\t                                if (!matchDomain(targetDomain, targetDomain)) throw new Error(\"Domain \" + stringify(targetDomain) + \" does not match \" + stringify(targetDomain));\n\t                                return normalizedDomain;\n\t                            }));\n\t                        }));\n\t                    }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {\n\t                        send: send\n\t                    });\n\t                })).then((function(targetDomain) {\n\t                    var domain = targetDomain;\n\t                    var logName = \"postrobot_method\" === name && data && \"string\" == typeof data.name ? data.name + \"()\" : name;\n\t                    var promise = new promise_ZalgoPromise;\n\t                    var hash = name + \"_\" + uniqueID();\n\t                    if (!fireAndForget) {\n\t                        var responseListener = {\n\t                            name: name,\n\t                            win: win,\n\t                            domain: domain,\n\t                            promise: promise\n\t                        };\n\t                        !function(hash, listener) {\n\t                            globalStore(\"responseListeners\").set(hash, listener);\n\t                        }(hash, responseListener);\n\t                        var reqPromises = windowStore(\"requestPromises\").getOrSet(win, (function() {\n\t                            return [];\n\t                        }));\n\t                        reqPromises.push(promise);\n\t                        promise.catch((function() {\n\t                            !function(hash) {\n\t                                globalStore(\"erroredResponseListeners\").set(hash, !0);\n\t                            }(hash);\n\t                            deleteResponseListener(hash);\n\t                        }));\n\t                        var totalAckTimeout = function(win) {\n\t                            return windowStore(\"knownWindows\").get(win, !1);\n\t                        }(win) ? 1e4 : 2e3;\n\t                        var totalResTimeout = responseTimeout;\n\t                        var ackTimeout = totalAckTimeout;\n\t                        var resTimeout = totalResTimeout;\n\t                        var interval = function(method, time) {\n\t                            var timeout;\n\t                            !function loop() {\n\t                                timeout = setTimeout((function() {\n\t                                    !function() {\n\t                                        if (isWindowClosed(win)) return promise.reject(new Error(\"Window closed for \" + name + \" before \" + (responseListener.ack ? \"response\" : \"ack\")));\n\t                                        if (responseListener.cancelled) return promise.reject(new Error(\"Response listener was cancelled for \" + name));\n\t                                        ackTimeout = Math.max(ackTimeout - 500, 0);\n\t                                        -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));\n\t                                        responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout && promise.reject(new Error(\"No response for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalResTimeout + \"ms\")) : promise.reject(new Error(\"No ack for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalAckTimeout + \"ms\"));\n\t                                    }();\n\t                                    loop();\n\t                                }), 500);\n\t                            }();\n\t                            return {\n\t                                cancel: function() {\n\t                                    clearTimeout(timeout);\n\t                                }\n\t                            };\n\t                        }();\n\t                        promise.finally((function() {\n\t                            interval.cancel();\n\t                            reqPromises.splice(reqPromises.indexOf(promise, 1));\n\t                        })).catch(src_util_noop);\n\t                    }\n\t                    return send_sendMessage(win, domain, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_request\",\n\t                        hash: hash,\n\t                        name: name,\n\t                        data: data,\n\t                        fireAndForget: fireAndForget\n\t                    }, {\n\t                        on: on_on,\n\t                        send: send\n\t                    }).then((function() {\n\t                        return fireAndForget ? promise.resolve() : promise;\n\t                    }), (function(err) {\n\t                        throw new Error(\"Send request message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }));\n\t                }));\n\t            }));\n\t        };\n\t        function setup_serializeMessage(destination, domain, obj) {\n\t            return serializeMessage(destination, domain, obj, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup_deserializeMessage(source, origin, message) {\n\t            return deserializeMessage(source, origin, message, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function createProxyWindow(win) {\n\t            return new window_ProxyWindow({\n\t                send: send_send,\n\t                win: win\n\t            });\n\t        }\n\t        function setup_toProxyWindow(win) {\n\t            return window_ProxyWindow.toProxyWindow(win, {\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup() {\n\t            if (!global_getGlobal().initialized) {\n\t                global_getGlobal().initialized = !0;\n\t                on = (_ref3 = {\n\t                    on: on_on,\n\t                    send: send_send\n\t                }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function(message) {\n\t                    return receive_receiveMessage(message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                };\n\t                !function(_ref5) {\n\t                    var on = _ref5.on, send = _ref5.send;\n\t                    globalStore().getOrSet(\"postMessageListener\", (function() {\n\t                        return function(obj, event, handler) {\n\t                            obj.addEventListener(\"message\", handler);\n\t                            return {\n\t                                cancel: function() {\n\t                                    obj.removeEventListener(\"message\", handler);\n\t                                }\n\t                            };\n\t                        }(window, 0, (function(event) {\n\t                            !function(event, _ref4) {\n\t                                var on = _ref4.on, send = _ref4.send;\n\t                                promise_ZalgoPromise.try((function() {\n\t                                    var source = event.source || event.sourceElement;\n\t                                    var origin = event.origin || event.originalEvent && event.originalEvent.origin;\n\t                                    var data = event.data;\n\t                                    \"null\" === origin && (origin = \"file://\");\n\t                                    if (source) {\n\t                                        if (!origin) throw new Error(\"Post message did not have origin domain\");\n\t                                        receive_receiveMessage({\n\t                                            source: source,\n\t                                            origin: origin,\n\t                                            data: data\n\t                                        }, {\n\t                                            on: on,\n\t                                            send: send\n\t                                        });\n\t                                    }\n\t                                }));\n\t                            }(event, {\n\t                                on: on,\n\t                                send: send\n\t                            });\n\t                        }));\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t                !function(_ref8) {\n\t                    var on = _ref8.on, send = _ref8.send;\n\t                    globalStore(\"builtinListeners\").getOrSet(\"helloListener\", (function() {\n\t                        var listener = on(\"postrobot_hello\", {\n\t                            domain: \"*\"\n\t                        }, (function(_ref3) {\n\t                            resolveHelloPromise(_ref3.source, {\n\t                                domain: _ref3.origin\n\t                            });\n\t                            return {\n\t                                instanceID: getInstanceID()\n\t                            };\n\t                        }));\n\t                        var parent = getAncestor();\n\t                        parent && sayHello(parent, {\n\t                            send: send\n\t                        }).catch((function(err) {}));\n\t                        return listener;\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t            }\n\t            var _ref3, on, send, global;\n\t        }\n\t        function destroy() {\n\t            !function() {\n\t                var responseListeners = globalStore(\"responseListeners\");\n\t                for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {\n\t                    var hash = _responseListeners$ke2[_i2];\n\t                    var listener = responseListeners.get(hash);\n\t                    listener && (listener.cancelled = !0);\n\t                    responseListeners.del(hash);\n\t                }\n\t            }();\n\t            (listener = globalStore().get(\"postMessageListener\")) && listener.cancel();\n\t            var listener;\n\t            delete window.__post_robot_10_0_46__;\n\t        }\n\t        var src_types_TYPES_0 = !0;\n\t        function cleanUpWindow(win) {\n\t            for (var _i2 = 0, _requestPromises$get2 = windowStore(\"requestPromises\").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error(\"Window \" + (isWindowClosed(win) ? \"closed\" : \"cleaned up\") + \" before response\")).catch(src_util_noop);\n\t        }\n\t        setup();\n\t    } ]);\n\t})); \n} (postRobot));\n\nvar postRobotExports$1 = postRobot.exports;\n\n/* @flow */\n\n(function (module) {\n\t// $FlowFixMe\n\tmodule.exports = postRobotExports$1; // eslint-disable-line import/no-commonjs\n\n\t// $FlowFixMe\n\tmodule.exports.default = module.exports; // eslint-disable-line import/no-commonjs \n} (postRobot$1));\n\nvar postRobotExports = postRobot$1.exports;\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postRobotExports);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n\t__proto__: null,\n\tdefault: index\n}, [postRobotExports]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFtaWx5QDAuMS4zX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfdmllbUAyLjM3LjZfYnVmZmVydXRpbEA0LjAuOV90X2Y1MzMyMzkxYTY3YTZmYTRlYTg0YzYxMTVjYWRmZTk3L25vZGVfbW9kdWxlcy9mYW1pbHkvbGliL2luZGV4LUREX2tuZERzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLGtCQUFrQiwrQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLCtCQUFtQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixTQUFTLCtCQUFtQjtBQUM1QixTQUFTLCtCQUFtQjtBQUM1QixhQUFhLCtCQUFtQjtBQUNoQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUIsa0NBQWtDLCtCQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsOEVBQThFLCtCQUFtQjtBQUNqRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCLGdCQUFnQiwrQkFBbUIsQ0FBQywrQkFBbUI7QUFDdkQsTUFBTSxvQkFBb0IsMEJBQW1CLEVBQUUsK0JBQW1CO0FBQ2xFLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xELFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CLDBCQUEwQjtBQUM1RTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtREFBbUQ7QUFDbEY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLHNDQUFzQztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw2Q0FBNkMsNkNBQTZDO0FBQzFGO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsd0dBQXdHLEVBQUU7QUFDMUc7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlOQUF5TjtBQUMvTyxrQkFBa0I7QUFDbEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsZUFBZTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SUFBdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JLHNDQUFzQztBQUN6SztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsY0FBYztBQUNkO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdSQUFnUixzREFBc0Q7QUFDdFU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVLHFDQUFxQztBQUMvQztBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELHlFQUF5RTtBQUN6RSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHdFQUF3RTtBQUN4RSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVLHVDQUF1QztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZ0ZBQWdGLHFDQUFxQztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsNkJBQTZCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHNQQUFzUCxLQUFLLHdDQUF3QyxLQUFLO0FBQ3hTLGtDQUFrQztBQUNsQztBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxvQkFBb0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9KQUFvSixxQ0FBcUM7QUFDekw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxnREFBZ0QsbUNBQW1DO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsd0JBQXdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZ0RBQWdELG9DQUFvQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsaUZBQWlGLDBCQUEwQjtBQUMzRztBQUNBO0FBQ0EsdUdBQXVHLGtDQUFrQztBQUN6STtBQUNBO0FBQ0EsOEJBQThCLE9BQU8sa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDZFQUE2RSwyQkFBMkI7QUFDeEc7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixzQkFBc0IsNENBQTRDO0FBQ2xFO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YscUNBQXFDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLG9DQUFvQztBQUN4STtBQUNBO0FBQ0EsT0FBTztBQUNQLEVBQUU7QUFDRixFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUV1QiIsInNvdXJjZXMiOlsiL1VzZXJzL2VsZW1lbi9zb2xpZGl0eS9zb2xpZGl0eS1uZXh0LWpzLXRlbXBsYXRlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9mYW1pbHlAMC4xLjNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV92aWVtQDIuMzcuNl9idWZmZXJ1dGlsQDQuMC45X3RfZjUzMzIzOTFhNjdhNmZhNGVhODRjNjExNWNhZGZlOTcvbm9kZV9tb2R1bGVzL2ZhbWlseS9saWIvaW5kZXgtRERfa25kRHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX21lcmdlTmFtZXNwYWNlcyhuLCBtKSB7XG5cdG0uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHRcdGUgJiYgdHlwZW9mIGUgIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KGUpICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHRcdGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIShrIGluIG4pKSB7XG5cdFx0XHRcdHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIHBvc3RSb2JvdCQxID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIHBvc3RSb2JvdCA9IHtleHBvcnRzOiB7fX07XG5cbihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCFmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA7XG5cdH0oXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiA/IHNlbGYgOiBjb21tb25qc0dsb2JhbCwgKGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKG1vZHVsZXMpIHtcblx0ICAgICAgICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0ICAgICAgICAgICAgaWYgKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSByZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblx0ICAgICAgICAgICAgdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHQgICAgICAgICAgICAgICAgaTogbW9kdWxlSWQsXG5cdCAgICAgICAgICAgICAgICBsOiAhMSxcblx0ICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHQgICAgICAgICAgICBtb2R1bGUubCA9ICEwO1xuXHQgICAgICAgICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG5cdCAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcblx0ICAgICAgICAgICAgICAgIGdldDogZ2V0dGVyXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuXHQgICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiBcIk1vZHVsZVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiAhMFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG5cdCAgICAgICAgICAgIDEgJiBtb2RlICYmICh2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpKTtcblx0ICAgICAgICAgICAgaWYgKDggJiBtb2RlKSByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIGlmICg0ICYgbW9kZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgXCJkZWZhdWx0XCIsIHtcblx0ICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBpZiAoMiAmIG1vZGUgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgdmFsdWUpIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG5cdCAgICAgICAgICAgIH0uYmluZChudWxsLCBrZXkpKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5zO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdCAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZGVmYXVsdDtcblx0ICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgXCJhXCIsIGdldHRlcik7XG5cdCAgICAgICAgICAgIHJldHVybiBnZXR0ZXI7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblx0ICAgICAgICByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcblx0ICAgIH0oWyBmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUHJvbWlzZVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVFlQRVNcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc3JjX3R5cGVzX1RZUEVTXzA7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlByb3h5V2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdztcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2V0dXBcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0dXA7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlc3Ryb3lcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGVzdHJveTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2VyaWFsaXplTWVzc2FnZVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXR1cF9zZXJpYWxpemVNZXNzYWdlO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZXNlcmlhbGl6ZU1lc3NhZ2VcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0dXBfZGVzZXJpYWxpemVNZXNzYWdlO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjcmVhdGVQcm94eVdpbmRvd1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm94eVdpbmRvdztcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidG9Qcm94eVdpbmRvd1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXR1cF90b1Byb3h5V2luZG93O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvblwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBvbl9vbjtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib25jZVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBvbl9vbmNlO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZW5kXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlbmRfc2VuZDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWFya1dpbmRvd0tub3duXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG1hcmtXaW5kb3dLbm93bjtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY2xlYW5VcFdpbmRvd1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjbGVhblVwV2luZG93O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJicmlkZ2VcIiwgKGZ1bmN0aW9uKCkge30pKTtcblx0ICAgICAgICBmdW5jdGlvbiBpc1JlZ2V4KGl0ZW0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBSZWdFeHBdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwoaXRlbSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBJRV9XSU5fQUNDRVNTX0VSUk9SID0gXCJDYWxsIHdhcyByZWplY3RlZCBieSBjYWxsZWUuXFxyXFxuXCI7XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0QWN0dWFsUHJvdG9jb2wod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICByZXR1cm4gd2luLmxvY2F0aW9uLnByb3RvY29sO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRQcm90b2NvbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIGlmICh3aW4ubW9ja0RvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb3RvY29sID0gd2luLm1vY2tEb21haW4uc3BsaXQoXCIvL1wiKVswXTtcblx0ICAgICAgICAgICAgICAgIGlmIChwcm90b2NvbCkgcmV0dXJuIHByb3RvY29sO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBnZXRBY3R1YWxQcm90b2NvbCh3aW4pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc0Fib3V0UHJvdG9jb2wod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICByZXR1cm4gXCJhYm91dDpcIiA9PT0gZ2V0UHJvdG9jb2wod2luKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0UGFyZW50KHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgaWYgKHdpbikgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4ucGFyZW50ICYmIHdpbi5wYXJlbnQgIT09IHdpbikgcmV0dXJuIHdpbi5wYXJlbnQ7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0T3BlbmVyKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgaWYgKHdpbiAmJiAhZ2V0UGFyZW50KHdpbikpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gd2luLm9wZW5lcjtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBjYW5SZWFkRnJvbVdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEFjdHVhbERvbWFpbih3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHdpbi5sb2NhdGlvbjtcblx0ICAgICAgICAgICAgaWYgKCFsb2NhdGlvbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBsb2NhdGlvblwiKTtcblx0ICAgICAgICAgICAgdmFyIHByb3RvY29sID0gZ2V0QWN0dWFsUHJvdG9jb2wod2luKTtcblx0ICAgICAgICAgICAgaWYgKCFwcm90b2NvbCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBwcm90b2NvbFwiKTtcblx0ICAgICAgICAgICAgaWYgKFwiZmlsZTpcIiA9PT0gcHJvdG9jb2wpIHJldHVybiBcImZpbGU6Ly9cIjtcblx0ICAgICAgICAgICAgaWYgKFwiYWJvdXQ6XCIgPT09IHByb3RvY29sKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KHdpbik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50ICYmIGNhblJlYWRGcm9tV2luZG93KCkgPyBnZXRBY3R1YWxEb21haW4ocGFyZW50KSA6IFwiYWJvdXQ6Ly9cIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgaG9zdCA9IGxvY2F0aW9uLmhvc3Q7XG5cdCAgICAgICAgICAgIGlmICghaG9zdCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBob3N0XCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBcIi8vXCIgKyBob3N0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXREb21haW4od2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICB2YXIgZG9tYWluID0gZ2V0QWN0dWFsRG9tYWluKHdpbik7XG5cdCAgICAgICAgICAgIHJldHVybiBkb21haW4gJiYgd2luLm1vY2tEb21haW4gJiYgMCA9PT0gd2luLm1vY2tEb21haW4uaW5kZXhPZihcIm1vY2s6XCIpID8gd2luLm1vY2tEb21haW4gOiBkb21haW47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzU2FtZURvbWFpbih3aW4pIHtcblx0ICAgICAgICAgICAgaWYgKCFmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW4sIFwibG9jYXRpb25cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgJiYgITEgPT09IGRlc2MuZW51bWVyYWJsZSkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNBYm91dFByb3RvY29sKHdpbikgJiYgY2FuUmVhZEZyb21XaW5kb3coKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtb2NrOlwiID09PSBnZXRQcm90b2NvbCh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0od2luKSAmJiBjYW5SZWFkRnJvbVdpbmRvdygpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChnZXRBY3R1YWxEb21haW4od2luKSA9PT0gZ2V0QWN0dWFsRG9tYWluKHdpbmRvdykpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgfSh3aW4pKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luID09PSB3aW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIGlmIChpc0Fib3V0UHJvdG9jb2wod2luKSAmJiBjYW5SZWFkRnJvbVdpbmRvdygpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICBpZiAoZ2V0RG9tYWluKHdpbmRvdykgPT09IGdldERvbWFpbih3aW4pKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBhc3NlcnRTYW1lRG9tYWluKHdpbikge1xuXHQgICAgICAgICAgICBpZiAoIWlzU2FtZURvbWFpbih3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB3aW5kb3cgdG8gYmUgc2FtZSBkb21haW5cIik7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzQW5jZXN0b3JQYXJlbnQocGFyZW50LCBjaGlsZCkge1xuXHQgICAgICAgICAgICBpZiAoIXBhcmVudCB8fCAhY2hpbGQpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgdmFyIGNoaWxkUGFyZW50ID0gZ2V0UGFyZW50KGNoaWxkKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGNoaWxkUGFyZW50ID8gY2hpbGRQYXJlbnQgPT09IHBhcmVudCA6IC0xICE9PSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICg7d2luLnBhcmVudCAhPT0gd2luOyApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god2luLnBhcmVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbiA9IHdpbi5wYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgfShjaGlsZCkuaW5kZXhPZihwYXJlbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFtZXMod2luKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgdmFyIGZyYW1lcztcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGZyYW1lcyA9IHdpbi5mcmFtZXM7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgZnJhbWVzID0gd2luO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBsZW47XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBsZW4gPSBmcmFtZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIGlmICgwID09PSBsZW4pIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIGlmIChsZW4pIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBmcmFtZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCAxMDA7IF9pKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IGZyYW1lc1tfaV07XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKCFfZnJhbWUpIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQucHVzaChfZnJhbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBpZnJhbWVXaW5kb3dzID0gW107XG5cdCAgICAgICAgdmFyIGlmcmFtZUZyYW1lcyA9IFtdO1xuXHQgICAgICAgIGZ1bmN0aW9uIGlzV2luZG93Q2xvc2VkKHdpbiwgYWxsb3dNb2NrKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gYWxsb3dNb2NrICYmIChhbGxvd01vY2sgPSAhMCk7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luID09PSB3aW5kb3cpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghd2luKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luLmNsb3NlZCkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhZXJyIHx8IGVyci5tZXNzYWdlICE9PSBJRV9XSU5fQUNDRVNTX0VSUk9SO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChhbGxvd01vY2sgJiYgaXNTYW1lRG9tYWluKHdpbikpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luLm1vY2tjbG9zZWQpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCF3aW4ucGFyZW50IHx8ICF3aW4udG9wKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgdmFyIGlmcmFtZUluZGV4ID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09PSBpdGVtKSByZXR1cm4gaTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICAgICAgfShpZnJhbWVXaW5kb3dzLCB3aW4pO1xuXHQgICAgICAgICAgICBpZiAoLTEgIT09IGlmcmFtZUluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBpZnJhbWVGcmFtZXNbaWZyYW1lSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZyYW1lICYmIGZ1bmN0aW9uKGZyYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFtZS5jb250ZW50V2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFtZS5wYXJlbnROb2RlKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IGZyYW1lLm93bmVyRG9jdW1lbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRvYyAmJiBkb2MuZG9jdW1lbnRFbGVtZW50ICYmICFkb2MuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGZyYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZnJhbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO3BhcmVudC5wYXJlbnROb2RlICYmIHBhcmVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQ7ICkgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50Lmhvc3QgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMocGFyZW50Lmhvc3QpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIH0oZnJhbWUpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRBbmNlc3Rvcih3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHJldHVybiBnZXRPcGVuZXIod2luID0gd2luIHx8IHdpbmRvdykgfHwgZ2V0UGFyZW50KHdpbikgfHwgdm9pZCAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBtYXRjaERvbWFpbihwYXR0ZXJuLCBvcmlnaW4pIHtcblx0ICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHBhdHRlcm4pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBvcmlnaW4pIHJldHVybiBcIipcIiA9PT0gcGF0dGVybiB8fCBvcmlnaW4gPT09IHBhdHRlcm47XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNSZWdleChvcmlnaW4pKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGlzUmVnZXgocGF0dGVybikgPyBpc1JlZ2V4KG9yaWdpbikgPyBwYXR0ZXJuLnRvU3RyaW5nKCkgPT09IG9yaWdpbi50b1N0cmluZygpIDogIUFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBCb29sZWFuKG9yaWdpbi5tYXRjaChwYXR0ZXJuKSkgOiAhIUFycmF5LmlzQXJyYXkocGF0dGVybikgJiYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSA/IEpTT04uc3RyaW5naWZ5KHBhdHRlcm4pID09PSBKU09OLnN0cmluZ2lmeShvcmlnaW4pIDogIWlzUmVnZXgob3JpZ2luKSAmJiBwYXR0ZXJuLnNvbWUoKGZ1bmN0aW9uKHN1YnBhdHRlcm4pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaERvbWFpbihzdWJwYXR0ZXJuLCBvcmlnaW4pO1xuXHQgICAgICAgICAgICB9KSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogPT09IHdpbmRvdykgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwiW29iamVjdCBXaW5kb3ddXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwob2JqKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5XaW5kb3cgJiYgb2JqIGluc3RhbmNlb2Ygd2luZG93LldpbmRvdykgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmouc2VsZiA9PT0gb2JqKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5wYXJlbnQgPT09IG9iaikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmoudG9wID09PSBvYmopIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogJiYgXCJfX3VubGlrZWx5X3ZhbHVlX19cIiA9PT0gb2JqLl9fY3Jvc3NfZG9tYWluX3V0aWxzX3dpbmRvd19jaGVja19fKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJwb3N0TWVzc2FnZVwiIGluIG9iaiAmJiBcInNlbGZcIiBpbiBvYmogJiYgXCJsb2NhdGlvblwiIGluIG9iaikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnJhbWVGb3JXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIGlmIChpc1NhbWVEb21haW4od2luKSkgcmV0dXJuIGFzc2VydFNhbWVEb21haW4od2luKS5mcmFtZUVsZW1lbnQ7XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pMjEgPSAwLCBfZG9jdW1lbnQkcXVlcnlTZWxlY3QyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlmcmFtZVwiKTsgX2kyMSA8IF9kb2N1bWVudCRxdWVyeVNlbGVjdDIubGVuZ3RoOyBfaTIxKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9kb2N1bWVudCRxdWVyeVNlbGVjdDJbX2kyMV07XG5cdCAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgZnJhbWUuY29udGVudFdpbmRvdyAmJiBmcmFtZS5jb250ZW50V2luZG93ID09PSB3aW4pIHJldHVybiBmcmFtZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBjbG9zZVdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihnZXRQYXJlbnQod2luKSk7XG5cdCAgICAgICAgICAgIH0od2luKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gZ2V0RnJhbWVGb3JXaW5kb3cod2luKTtcblx0ICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBmcmFtZS5wYXJlbnRFbGVtZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZnJhbWUucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChmcmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB3aW4uY2xvc2UoKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiB1dGlsc19pc1Byb21pc2UoaXRlbSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUHJvbWlzZSAmJiBpdGVtIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbmRvdy5XaW5kb3cgJiYgaXRlbSBpbnN0YW5jZW9mIHdpbmRvdy5XaW5kb3cpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW5kb3cuY29uc3RydWN0b3IgJiYgaXRlbSBpbnN0YW5jZW9mIHdpbmRvdy5jb25zdHJ1Y3RvcikgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgdmFyIF90b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgaWYgKF90b1N0cmluZykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3RvU3RyaW5nLmNhbGwoaXRlbSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFwiW29iamVjdCBXaW5kb3ddXCIgPT09IG5hbWUgfHwgXCJbb2JqZWN0IGdsb2JhbF1cIiA9PT0gbmFtZSB8fCBcIltvYmplY3QgRE9NV2luZG93XVwiID09PSBuYW1lKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtLnRoZW4pIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGlzcGF0Y2hlZEVycm9ycyA9IFtdO1xuXHQgICAgICAgIHZhciBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycyA9IFtdO1xuXHQgICAgICAgIHZhciBhY3RpdmVDb3VudCA9IDA7XG5cdCAgICAgICAgdmFyIGZsdXNoUHJvbWlzZTtcblx0ICAgICAgICBmdW5jdGlvbiBmbHVzaEFjdGl2ZSgpIHtcblx0ICAgICAgICAgICAgaWYgKCFhY3RpdmVDb3VudCAmJiBmbHVzaFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gZmx1c2hQcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgZmx1c2hQcm9taXNlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0YXJ0QWN0aXZlKCkge1xuXHQgICAgICAgICAgICBhY3RpdmVDb3VudCArPSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBlbmRBY3RpdmUoKSB7XG5cdCAgICAgICAgICAgIGFjdGl2ZUNvdW50IC09IDE7XG5cdCAgICAgICAgICAgIGZsdXNoQWN0aXZlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwcm9taXNlX1phbGdvUHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBaYWxnb1Byb21pc2UoaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zdGFjayA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSAhMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQgPSAhMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gITE7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG5cdCAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlzQXN5bmMgPSAhMTtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFydEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmMpIF90aGlzLnJlc29sdmUocmVzKTsgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0ID0gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmMpIF90aGlzLnJlamVjdChlcnIpOyBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lcnJvciA9IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpc0FzeW5jID0gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPyB0aGlzLnJlc29sdmUoX3Jlc3VsdCkgOiByZWplY3RlZCAmJiB0aGlzLnJlamVjdChfZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcHJvdG8gPSBaYWxnb1Byb21pc2UucHJvdG90eXBlO1xuXHQgICAgICAgICAgICBfcHJvdG8ucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWQgfHwgdGhpcy5yZWplY3RlZCkgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAodXRpbHNfaXNQcm9taXNlKHJlc3VsdCkpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggYW5vdGhlciBwcm9taXNlXCIpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8ucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWQgfHwgdGhpcy5yZWplY3RlZCkgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAodXRpbHNfaXNQcm9taXNlKGVycm9yKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWplY3QgcHJvbWlzZSB3aXRoIGFub3RoZXIgcHJvbWlzZVwiKTtcblx0ICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX2VyciA9IGVycm9yICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZXJyb3IudG9TdHJpbmcgPyBlcnJvci50b1N0cmluZygpIDoge30udG9TdHJpbmcuY2FsbChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCByZWplY3QgdG8gYmUgY2FsbGVkIHdpdGggRXJyb3IsIGdvdCBcIiArIF9lcnIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgfHwgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmVycm9ySGFuZGxlZCB8fCBmdW5jdGlvbihlcnIsIHByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSBkaXNwYXRjaGVkRXJyb3JzLmluZGV4T2YoZXJyKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlZEVycm9ycy5wdXNoKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLmxlbmd0aDsgaisrKSBwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVyc1tqXShlcnIsIHByb21pc2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfShlcnJvciwgX3RoaXMyKTtcblx0ICAgICAgICAgICAgICAgIH0pLCAxKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uYXN5bmNSZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZGlzcGF0Y2ggPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZWQsIHJlamVjdGVkID0gdGhpcy5yZWplY3RlZCwgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpc3BhdGNoaW5nICYmIChyZXNvbHZlZCB8fCByZWplY3RlZCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbihmaXJzdFByb21pc2UsIHNlY29uZFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0UHJvbWlzZS50aGVuKChmdW5jdGlvbihyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFByb21pc2UucmVzb2x2ZShyZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2hhbmRsZXJzJGkgPSBoYW5kbGVyc1tpXSwgb25TdWNjZXNzID0gX2hhbmRsZXJzJGkub25TdWNjZXNzLCBvbkVycm9yID0gX2hhbmRsZXJzJGkub25FcnJvciwgcHJvbWlzZSA9IF9oYW5kbGVycyRpLnByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVzdWx0MiA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdDIgPSBvblN1Y2Nlc3MgPyBvblN1Y2Nlc3ModGhpcy52YWx1ZSkgOiB0aGlzLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWplY3RlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbkVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QodGhpcy5lcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQyID0gb25FcnJvcih0aGlzLmVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXN1bHQyIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlICYmIChfcmVzdWx0Mi5yZXNvbHZlZCB8fCBfcmVzdWx0Mi5yZWplY3RlZCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlUmVzdWx0ID0gX3Jlc3VsdDI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzdWx0LnJlc29sdmVkID8gcHJvbWlzZS5yZXNvbHZlKHByb21pc2VSZXN1bHQudmFsdWUpIDogcHJvbWlzZS5yZWplY3QocHJvbWlzZVJlc3VsdC5lcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzdWx0LmVycm9ySGFuZGxlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdXRpbHNfaXNQcm9taXNlKF9yZXN1bHQyKSA/IF9yZXN1bHQyIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlICYmIChfcmVzdWx0Mi5yZXNvbHZlZCB8fCBfcmVzdWx0Mi5yZWplY3RlZCkgPyBfcmVzdWx0Mi5yZXNvbHZlZCA/IHByb21pc2UucmVzb2x2ZShfcmVzdWx0Mi52YWx1ZSkgOiBwcm9taXNlLnJlamVjdChfcmVzdWx0Mi5lcnJvcikgOiBjaGFpbihfcmVzdWx0MiwgcHJvbWlzZSkgOiBwcm9taXNlLnJlc29sdmUoX3Jlc3VsdDIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5sZW5ndGggPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSAhMTtcblx0ICAgICAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbihvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChvblN1Y2Nlc3MgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvblN1Y2Nlc3MgJiYgIW9uU3VjY2Vzcy5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRoZW4gZXhwZWN0ZWQgYSBmdW5jdGlvbiBmb3Igc3VjY2VzcyBoYW5kbGVyXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKG9uRXJyb3IgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvbkVycm9yICYmICFvbkVycm9yLmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UudGhlbiBleHBlY3RlZCBhIGZ1bmN0aW9uIGZvciBlcnJvciBoYW5kbGVyXCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuXHQgICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogb25TdWNjZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3Jcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uY2F0Y2ggPSBmdW5jdGlvbihvbkVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgb25FcnJvcik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5maW5hbGx5ID0gZnVuY3Rpb24ob25GaW5hbGx5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob25GaW5hbGx5ICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb25GaW5hbGx5ICYmICFvbkZpbmFsbHkuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS5maW5hbGx5IGV4cGVjdGVkIGEgZnVuY3Rpb25cIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbihyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnRyeShvbkZpbmFsbHkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS50cnkob25GaW5hbGx5KS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnRpbWVvdXQgPSBmdW5jdGlvbih0aW1lLCBlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWQgfHwgdGhpcy5yZWplY3RlZCkgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzMy5yZXNvbHZlZCB8fCBfdGhpczMucmVqZWN0ZWQgfHwgX3RoaXMzLnJlamVjdChlcnIgfHwgbmV3IEVycm9yKFwiUHJvbWlzZSB0aW1lZCBvdXQgYWZ0ZXIgXCIgKyB0aW1lICsgXCJtc1wiKSk7XG5cdCAgICAgICAgICAgICAgICB9KSwgdGltZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbihyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnRvUHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFByb21pc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb3VsZCBub3QgZmluZCBQcm9taXNlXCIpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmxhenkgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gITA7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlID8gdmFsdWUgOiB1dGlsc19pc1Byb21pc2UodmFsdWUpID8gbmV3IFphbGdvUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgIH0pKSA6IChuZXcgWmFsZ29Qcm9taXNlKS5yZXNvbHZlKHZhbHVlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBaYWxnb1Byb21pc2UpLnJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5hc3luY1JlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBaYWxnb1Byb21pc2UpLmFzeW5jUmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBwcm9taXNlcy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLnNsaWNlKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWNvdW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGNoYWluID0gZnVuY3Rpb24oaSwgZmlyc3RQcm9taXNlLCBzZWNvbmRQcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0UHJvbWlzZS50aGVuKChmdW5jdGlvbihyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgMCA9PSAoY291bnQgLT0gMSkgJiYgcHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbSA9IHByb21pc2VzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9tIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9tLnJlc29sdmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gcHJvbS52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV0aWxzX2lzUHJvbWlzZShwcm9tKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gcHJvbTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgLT0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNoYWluKGksIFphbGdvUHJvbWlzZS5yZXNvbHZlKHByb20pLCBwcm9taXNlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIDAgPT09IGNvdW50ICYmIHByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuaGFzaCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgICAgICAgICB2YXIgYXdhaXRQcm9taXNlcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvbWlzZXNba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHNfaXNQcm9taXNlKHZhbHVlKSA/IGF3YWl0UHJvbWlzZXMucHVzaCh2YWx1ZS50aGVuKChmdW5jdGlvbihyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSkpIDogcmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb21pc2VzKSBfbG9vcChrZXkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5hbGwoYXdhaXRQcm9taXNlcykudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLm1hcCA9IGZ1bmN0aW9uKGl0ZW1zLCBtZXRob2QpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UuYWxsKGl0ZW1zLm1hcChtZXRob2QpKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLm9uUG9zc2libHlVbmhhbmRsZWRFeGNlcHRpb24gPSBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLnNwbGljZShwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9KGhhbmRsZXIpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UudHJ5ID0gZnVuY3Rpb24obWV0aG9kLCBjb250ZXh0LCBhcmdzKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobWV0aG9kICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgbWV0aG9kICYmICFtZXRob2QuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS50cnkgZXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICBzdGFydEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJncyB8fCBbXSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnJlc29sdmUocmVzdWx0KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmRlbGF5ID0gZnVuY3Rpb24oX2RlbGF5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFphbGdvUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgX2RlbGF5KTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmlzUHJvbWlzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UpIHx8IHV0aWxzX2lzUHJvbWlzZSh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKFphbGdvKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmbHVzaFByb21pc2UgPSBmbHVzaFByb21pc2UgfHwgbmV3IFphbGdvO1xuXHQgICAgICAgICAgICAgICAgICAgIGZsdXNoQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICB9KFphbGdvUHJvbWlzZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2U7XG5cdCAgICAgICAgfSgpO1xuXHQgICAgICAgIGZ1bmN0aW9uIHV0aWxfc2FmZUluZGV4T2YoY29sbGVjdGlvbiwgaXRlbSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGlvbltpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIENyb3NzRG9tYWluU2FmZVdlYWtNYXAoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLndlYWttYXAgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmtleXMgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IFwiX193ZWFrbWFwX1wiICsgKDFlOSAqIE1hdGgucmFuZG9tKCkgPj4+IDApICsgXCJfX1wiO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gT2JqZWN0LmZyZWV6ZSkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0V2Vha01hcCA9IG5ldyBXZWFrTWFwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdEtleSA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHRlc3RLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0V2Vha01hcC5zZXQodGVzdEtleSwgXCJfX3Rlc3R2YWx1ZV9fXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJfX3Rlc3R2YWx1ZV9fXCIgPT09IHRlc3RXZWFrTWFwLmdldCh0ZXN0S2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0oKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLndlYWttYXAgPSBuZXcgV2Vha01hcDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMua2V5cyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgX3Byb3RvID0gQ3Jvc3NEb21haW5TYWZlV2Vha01hcC5wcm90b3R5cGU7XG5cdCAgICAgICAgICAgIF9wcm90by5fY2xlYW51cENsb3NlZFdpbmRvd3MgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvdyh2YWx1ZSkgJiYgaXNXaW5kb3dDbG9zZWQodmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Vha21hcC5kZWxldGUodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5pc1NhZmVUb1JlYWRXcml0ZSA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICFpc1dpbmRvdyhrZXkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLnNldChrZXksIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVtuYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gPSB2YWx1ZSA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrZXksIG5hbWUsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFsga2V5LCB2YWx1ZSBdLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITBcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB1dGlsX3NhZmVJbmRleE9mKGtleXMsIGtleSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoLTEgPT09IGluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcC5oYXMoa2V5KSkgcmV0dXJuIHdlYWttYXAuZ2V0KGtleSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdIDogdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHV0aWxfc2FmZUluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKC0xICE9PSBpbmRleCkgcmV0dXJuIHRoaXMudmFsdWVzW2luZGV4XTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmRlbGV0ZSA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLmRlbGV0ZShrZXkpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSAmJiAoZW50cnlbMF0gPSBlbnRyeVsxXSA9IHZvaWQgMCk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB1dGlsX3NhZmVJbmRleE9mKGtleXMsIGtleSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoLTEgIT09IGluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5oYXMgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIGV4cGVjdGVkIGtleVwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXAuaGFzKGtleSkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCFlbnRyeSB8fCBlbnRyeVswXSAhPT0ga2V5KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gLTEgIT09IHV0aWxfc2FmZUluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0T3JTZXQgPSBmdW5jdGlvbihrZXksIGdldHRlcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHJldHVybiB0aGlzLmdldChrZXkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyKCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIENyb3NzRG9tYWluU2FmZVdlYWtNYXA7XG5cdCAgICAgICAgfSgpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuXHQgICAgICAgICAgICByZXR1cm4gZm4ubmFtZSB8fCBmbi5fX25hbWVfXyB8fCBmbi5kaXNwbGF5TmFtZSB8fCBcImFub255bW91c1wiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXRGdW5jdGlvbk5hbWUoZm4sIG5hbWUpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBmbi5uYW1lO1xuXHQgICAgICAgICAgICAgICAgZm4ubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgZm4uX19uYW1lX18gPSBmbi5kaXNwbGF5TmFtZSA9IG5hbWU7XG5cdCAgICAgICAgICAgIHJldHVybiBmbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gdW5pcXVlSUQoKSB7XG5cdCAgICAgICAgICAgIHZhciBjaGFycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuXHQgICAgICAgICAgICByZXR1cm4gXCJ1aWRfXCIgKyBcInh4eHh4eHh4eHhcIi5yZXBsYWNlKC8uL2csIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG5cdCAgICAgICAgICAgIH0pKSArIFwiX1wiICsgZnVuY3Rpb24oc3RyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBidG9hKSByZXR1cm4gYnRvYShlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC8lKFswLTlBLUZdezJ9KS9nLCAoZnVuY3Rpb24obSwgcDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChwMSwgMTYpKTtcblx0ICAgICAgICAgICAgICAgIH0pKSkucmVwbGFjZSgvWz1dL2csIFwiXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEJ1ZmZlcikgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgXCJ1dGY4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpLnJlcGxhY2UoL1s9XS9nLCBcIlwiKTtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZmluZCB3aW5kb3cuYnRvYSBvciBCdWZmZXJcIik7XG5cdCAgICAgICAgICAgIH0oKG5ldyBEYXRlKS50b0lTT1N0cmluZygpLnNsaWNlKDExLCAxOSkucmVwbGFjZShcIlRcIiwgXCIuXCIpKS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgXCJcIikudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG9iamVjdElEcztcblx0ICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVBcmdzKGFyZ3MpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShbXS5zbGljZS5jYWxsKGFyZ3MpLCAoZnVuY3Rpb24oc3Via2V5LCB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWwgPyBcIm1lbW9pemVbXCIgKyBmdW5jdGlvbihvYmopIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SURzID0gb2JqZWN0SURzIHx8IG5ldyB3ZWFrbWFwX0Nyb3NzRG9tYWluU2FmZVdlYWtNYXA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IG9iaiB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBvYmogJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvYmopIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb2JqZWN0XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gb2JqZWN0SURzLmdldChvYmopO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVpZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkID0gdHlwZW9mIG9iaiArIFwiOlwiICsgdW5pcXVlSUQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdElEcy5zZXQob2JqLCB1aWQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1aWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh2YWwpICsgXCJdXCIgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgdmFsIGluc3RhbmNlb2Ygd2luZG93LkVsZW1lbnQgfHwgbnVsbCAhPT0gdmFsICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbCAmJiAxID09PSB2YWwubm9kZVR5cGUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsLnN0eWxlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbC5vd25lckRvY3VtZW50ID8ge30gOiB2YWw7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRzIG5vdCBzZXJpYWxpemFibGUgLS0gY2FuIG5vdCBiZSB1c2VkIHRvIG1lbW9pemVcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RW1wdHlPYmplY3QoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG1lbW9pemVHbG9iYWxJbmRleCA9IDA7XG5cdCAgICAgICAgdmFyIG1lbW9pemVHbG9iYWxJbmRleFZhbGlkRnJvbSA9IDA7XG5cdCAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZShtZXRob2QsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBvcHRpb25zICYmIChvcHRpb25zID0ge30pO1xuXHQgICAgICAgICAgICB2YXIgX29wdGlvbnMkdGhpc05hbWVzcGFjID0gb3B0aW9ucy50aGlzTmFtZXNwYWNlLCB0aGlzTmFtZXNwYWNlID0gdm9pZCAwICE9PSBfb3B0aW9ucyR0aGlzTmFtZXNwYWMgJiYgX29wdGlvbnMkdGhpc05hbWVzcGFjLCBjYWNoZVRpbWUgPSBvcHRpb25zLnRpbWU7XG5cdCAgICAgICAgICAgIHZhciBzaW1wbGVDYWNoZTtcblx0ICAgICAgICAgICAgdmFyIHRoaXNDYWNoZTtcblx0ICAgICAgICAgICAgdmFyIG1lbW9pemVJbmRleCA9IG1lbW9pemVHbG9iYWxJbmRleDtcblx0ICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4ICs9IDE7XG5cdCAgICAgICAgICAgIHZhciBtZW1vaXplZEZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICAgICAgICAgICAgICBpZiAobWVtb2l6ZUluZGV4IDwgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2ltcGxlQ2FjaGUgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNDYWNoZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZUluZGV4ID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgIG1lbW9pemVHbG9iYWxJbmRleCArPSAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGNhY2hlO1xuXHQgICAgICAgICAgICAgICAgY2FjaGUgPSB0aGlzTmFtZXNwYWNlID8gKHRoaXNDYWNoZSA9IHRoaXNDYWNoZSB8fCBuZXcgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwKS5nZXRPclNldCh0aGlzLCBnZXRFbXB0eU9iamVjdCkgOiBzaW1wbGVDYWNoZSA9IHNpbXBsZUNhY2hlIHx8IHt9O1xuXHQgICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5O1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSA9IHNlcmlhbGl6ZUFyZ3MoYXJncyk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGNhY2hlUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNhY2hlUmVzdWx0ICYmIGNhY2hlVGltZSAmJiBEYXRlLm5vdygpIC0gY2FjaGVSZXN1bHQudGltZSA8IGNhY2hlVGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtjYWNoZUtleV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FjaGVSZXN1bHQgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGNhY2hlUmVzdWx0KSByZXR1cm4gY2FjaGVSZXN1bHQudmFsdWU7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgbWVtb2l6ZWRGdW5jdGlvbi5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgc2ltcGxlQ2FjaGUgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgdGhpc0NhY2hlID0gbnVsbDtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldEZ1bmN0aW9uTmFtZShtZW1vaXplZEZ1bmN0aW9uLCAob3B0aW9ucy5uYW1lIHx8IGdldEZ1bmN0aW9uTmFtZShtZXRob2QpKSArIFwiOjptZW1vaXplZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbWVtb2l6ZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBtZW1vaXplR2xvYmFsSW5kZXhWYWxpZEZyb20gPSBtZW1vaXplR2xvYmFsSW5kZXg7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmdW5jdGlvbiBtZW1vaXplUHJvbWlzZShtZXRob2QpIHtcblx0ICAgICAgICAgICAgdmFyIGNhY2hlID0ge307XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIG1lbW9pemVkUHJvbWlzZUZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHMsIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleSA9IHNlcmlhbGl6ZUFyZ3MoYXJncyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuIGNhY2hlW2tleV07XG5cdCAgICAgICAgICAgICAgICBjYWNoZVtrZXldID0gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KF90aGlzLCBfYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgIH0pKS5maW5hbGx5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5XTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG1lbW9pemVkUHJvbWlzZUZ1bmN0aW9uLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBjYWNoZSA9IHt9O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0RnVuY3Rpb25OYW1lKG1lbW9pemVkUHJvbWlzZUZ1bmN0aW9uLCBnZXRGdW5jdGlvbk5hbWUobWV0aG9kKSArIFwiOjpwcm9taXNlTWVtb2l6ZWRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNyY191dGlsX25vb3AoKSB7fVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0cmluZ2lmeUVycm9yKGVyciwgbGV2ZWwpIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBsZXZlbCAmJiAobGV2ZWwgPSAxKTtcblx0ICAgICAgICAgICAgaWYgKGxldmVsID49IDMpIHJldHVybiBcInN0cmluZ2lmeUVycm9yIHN0YWNrIG92ZXJmbG93XCI7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWVycikgcmV0dXJuIFwiPHVua25vd24gZXJyb3I6IFwiICsge30udG9TdHJpbmcuY2FsbChlcnIpICsgXCI+XCI7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZXJyKSByZXR1cm4gZXJyO1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gZXJyICYmIGVyci5zdGFjaztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2sgJiYgbWVzc2FnZSkgcmV0dXJuIC0xICE9PSBzdGFjay5pbmRleE9mKG1lc3NhZ2UpID8gc3RhY2sgOiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjaykgcmV0dXJuIHN0YWNrO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSByZXR1cm4gbWVzc2FnZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBlcnIgJiYgZXJyLnRvU3RyaW5nICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZXJyLnRvU3RyaW5nID8gZXJyLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGVycik7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKG5ld0Vycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3Igd2hpbGUgc3RyaW5naWZ5aW5nIGVycm9yOiBcIiArIHN0cmluZ2lmeUVycm9yKG5ld0VyciwgbGV2ZWwgKyAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzdHJpbmdpZnkoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgaXRlbSA/IGl0ZW0gOiBpdGVtICYmIGl0ZW0udG9TdHJpbmcgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtLnRvU3RyaW5nID8gaXRlbS50b1N0cmluZygpIDoge30udG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24ob2JqKSB7XG5cdCAgICAgICAgICAgIGlmIChPYmplY3QudmFsdWVzKSByZXR1cm4gT2JqZWN0LnZhbHVlcyhvYmopO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHJlc3VsdC5wdXNoKG9ialtrZXldKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgZnVuY3Rpb24gdXRpbF9pc1JlZ2V4KGl0ZW0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBSZWdFeHBdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwoaXRlbSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHV0aWxfZ2V0T3JTZXQob2JqLCBrZXksIGdldHRlcikge1xuXHQgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybiBvYmpba2V5XTtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IGdldHRlcigpO1xuXHQgICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcblx0ICAgICAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXHQgICAgICAgICAgICBpZiAoIWJvZHkpIHRocm93IG5ldyBFcnJvcihcIkJvZHkgZWxlbWVudCBub3QgZm91bmRcIik7XG5cdCAgICAgICAgICAgIHJldHVybiBib2R5O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc0RvY3VtZW50UmVhZHkoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGRvY3VtZW50LmJvZHkpICYmIFwiY29tcGxldGVcIiA9PT0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNEb2N1bWVudEludGVyYWN0aXZlKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihkb2N1bWVudC5ib2R5KSAmJiBcImludGVyYWN0aXZlXCIgPT09IGRvY3VtZW50LnJlYWR5U3RhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG1lbW9pemUoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkgfHwgaXNEb2N1bWVudEludGVyYWN0aXZlKCkpIHJldHVybiByZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnRSZWFkeSgpIHx8IGlzRG9jdW1lbnRJbnRlcmFjdGl2ZSgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pLCAxMCk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRTY3JpcHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBkb2N1bWVudCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgOiBudWxsO1xuXHQgICAgICAgIHZhciBnZXRDdXJyZW50U2NyaXB0ID0gbWVtb2l6ZSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGlmIChjdXJyZW50U2NyaXB0KSByZXR1cm4gY3VycmVudFNjcmlwdDtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JpcHQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnIuc3RhY2sgfHwgXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tEZXRhaWxzID0gLy4qYXQgW14oXSpcXCgoLiopOiguKyk6KC4rKVxcKSQvZ2kuZXhlYyhzdGFjayk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjcmlwdExvY2F0aW9uID0gc3RhY2tEZXRhaWxzICYmIHN0YWNrRGV0YWlsc1sxXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXNjcmlwdExvY2F0aW9uKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMiA9IDAsIF9BcnJheSRwcm90b3R5cGUkc2xpYzIgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpKS5yZXZlcnNlKCk7IF9pMjIgPCBfQXJyYXkkcHJvdG90eXBlJHNsaWMyLmxlbmd0aDsgX2kyMisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBfQXJyYXkkcHJvdG90eXBlJHNsaWMyW19pMjJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NyaXB0LnNyYyAmJiBzY3JpcHQuc3JjID09PSBzY3JpcHRMb2NhdGlvbikgcmV0dXJuIHNjcmlwdDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIH0oKSkgcmV0dXJuIGN1cnJlbnRTY3JpcHQ7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGV0ZXJtaW5lIGN1cnJlbnQgc2NyaXB0XCIpO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICB2YXIgY3VycmVudFVJRCA9IHVuaXF1ZUlEKCk7XG5cdCAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBzY3JpcHQ7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBzY3JpcHQgPSBnZXRDdXJyZW50U2NyaXB0KCk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRVSUQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHVpZCA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVpZFwiKTtcblx0ICAgICAgICAgICAgaWYgKHVpZCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB1aWQpIHJldHVybiB1aWQ7XG5cdCAgICAgICAgICAgIGlmICgodWlkID0gc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtdWlkLWF1dG9cIikpICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHVpZCkgcmV0dXJuIHVpZDtcblx0ICAgICAgICAgICAgaWYgKHNjcmlwdC5zcmMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBoYXNoZWRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gc3RyW2ldLmNoYXJDb2RlQXQoMCkgKiBpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHJbaSArIDFdICYmICh0b3RhbCArPSBzdHJbaSArIDFdLmNoYXJDb2RlQXQoMCkgKiAoaSAtIDEpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgTWF0aC5hYnModG90YWwpICUgMjYpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICAgICAgICAgIH0oSlNPTi5zdHJpbmdpZnkoe1xuXHQgICAgICAgICAgICAgICAgICAgIHNyYzogc2NyaXB0LnNyYyxcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhc2V0OiBzY3JpcHQuZGF0YXNldFxuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgdWlkID0gXCJ1aWRfXCIgKyBoYXNoZWRTdHJpbmcuc2xpY2UoaGFzaGVkU3RyaW5nLmxlbmd0aCAtIDMwKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHVpZCA9IHVuaXF1ZUlEKCk7XG5cdCAgICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXVpZC1hdXRvXCIsIHVpZCk7XG5cdCAgICAgICAgICAgIHJldHVybiB1aWQ7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGdsb2JhbF9nZXRHbG9iYWwod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICB2YXIgZ2xvYmFsS2V5ID0gXCJfX3Bvc3Rfcm9ib3RfMTBfMF80Nl9fXCI7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW4gIT09IHdpbmRvdyA/IHdpbltnbG9iYWxLZXldIDogd2luW2dsb2JhbEtleV0gPSB3aW5bZ2xvYmFsS2V5XSB8fCB7fTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGdldE9iaiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmdW5jdGlvbiBnbG9iYWxTdG9yZShrZXksIGRlZlN0b3JlKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0ga2V5ICYmIChrZXkgPSBcInN0b3JlXCIpO1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGRlZlN0b3JlICYmIChkZWZTdG9yZSA9IGdldE9iaik7XG5cdCAgICAgICAgICAgIHJldHVybiB1dGlsX2dldE9yU2V0KGdsb2JhbF9nZXRHbG9iYWwoKSwga2V5LCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBkZWZTdG9yZSgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKHN0b3JlS2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShzdG9yZUtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKHN0b3JlS2V5LCBkZWZWYWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmhhc093blByb3BlcnR5KHN0b3JlS2V5KSA/IHN0b3JlW3N0b3JlS2V5XSA6IGRlZlZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oc3RvcmVLZXksIHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVtzdG9yZUtleV0gPSB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBkZWw6IGZ1bmN0aW9uKHN0b3JlS2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtzdG9yZUtleV07XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBnZXRPclNldDogZnVuY3Rpb24oc3RvcmVLZXksIGdldHRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF9nZXRPclNldChzdG9yZSwgc3RvcmVLZXksIGdldHRlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlID0gZGVmU3RvcmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RvcmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIFdpbGRDYXJkID0gZnVuY3Rpb24oKSB7fTtcblx0ICAgICAgICBmdW5jdGlvbiBnZXRXaWxkY2FyZCgpIHtcblx0ICAgICAgICAgICAgdmFyIGdsb2JhbCA9IGdsb2JhbF9nZXRHbG9iYWwoKTtcblx0ICAgICAgICAgICAgZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCA9IGdsb2JhbC5XSU5ET1dfV0lMRENBUkQgfHwgbmV3IFdpbGRDYXJkO1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsLldJTkRPV19XSUxEQ0FSRDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gd2luZG93U3RvcmUoa2V5LCBkZWZTdG9yZSkge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGtleSAmJiAoa2V5ID0gXCJzdG9yZVwiKTtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBkZWZTdG9yZSAmJiAoZGVmU3RvcmUgPSBnZXRPYmopO1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJ3aW5kb3dTdG9yZVwiKS5nZXRPclNldChrZXksIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5TdG9yZSA9IG5ldyB3ZWFrbWFwX0Nyb3NzRG9tYWluU2FmZVdlYWtNYXA7XG5cdCAgICAgICAgICAgICAgICB2YXIgZ2V0U3RvcmUgPSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luU3RvcmUuZ2V0T3JTZXQod2luLCBkZWZTdG9yZSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U3RvcmUod2luKS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbih3aW4sIGRlZlZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSBnZXRTdG9yZSh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuaGFzT3duUHJvcGVydHkoa2V5KSA/IHN0b3JlW2tleV0gOiBkZWZWYWw7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHdpbiwgdmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdldFN0b3JlKHdpbilba2V5XSA9IHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGRlbDogZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBnZXRTdG9yZSh3aW4pW2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBnZXRPclNldDogZnVuY3Rpb24od2luLCBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoZ2V0U3RvcmUod2luKSwga2V5LCBnZXR0ZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0SW5zdGFuY2VJRCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiaW5zdGFuY2VcIikuZ2V0T3JTZXQoXCJpbnN0YW5jZUlEXCIsIHVuaXF1ZUlEKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZUhlbGxvUHJvbWlzZSh3aW4sIF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF9yZWYuZG9tYWluO1xuXHQgICAgICAgICAgICB2YXIgaGVsbG9Qcm9taXNlcyA9IHdpbmRvd1N0b3JlKFwiaGVsbG9Qcm9taXNlc1wiKTtcblx0ICAgICAgICAgICAgdmFyIGV4aXN0aW5nUHJvbWlzZSA9IGhlbGxvUHJvbWlzZXMuZ2V0KHdpbik7XG5cdCAgICAgICAgICAgIGV4aXN0aW5nUHJvbWlzZSAmJiBleGlzdGluZ1Byb21pc2UucmVzb2x2ZSh7XG5cdCAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdmFyIG5ld1Byb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBoZWxsb1Byb21pc2VzLnNldCh3aW4sIG5ld1Byb21pc2UpO1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3UHJvbWlzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2F5SGVsbG8od2luLCBfcmVmNCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKDAsIF9yZWY0LnNlbmQpKHdpbiwgXCJwb3N0cm9ib3RfaGVsbG9cIiwge1xuXHQgICAgICAgICAgICAgICAgaW5zdGFuY2VJRDogZ2V0SW5zdGFuY2VJRCgpXG5cdCAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogXCIqXCIsXG5cdCAgICAgICAgICAgICAgICB0aW1lb3V0OiAtMVxuXHQgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmNSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IF9yZWY1Lm9yaWdpbiwgaW5zdGFuY2VJRCA9IF9yZWY1LmRhdGEuaW5zdGFuY2VJRDtcblx0ICAgICAgICAgICAgICAgIHJlc29sdmVIZWxsb1Byb21pc2Uod2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW5cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBpbnN0YW5jZUlEXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFdpbmRvd0luc3RhbmNlSUQod2luLCBfcmVmNikge1xuXHQgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY2LnNlbmQ7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW5kb3dTdG9yZShcIndpbmRvd0luc3RhbmNlSURQcm9taXNlc1wiKS5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzYXlIZWxsbyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmNykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNy5pbnN0YW5jZUlEO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG1hcmtXaW5kb3dLbm93bih3aW4pIHtcblx0ICAgICAgICAgICAgd2luZG93U3RvcmUoXCJrbm93bldpbmRvd3NcIikuc2V0KHdpbiwgITApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc1NlcmlhbGl6ZWRUeXBlKGl0ZW0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT0gdHlwZW9mIGl0ZW0gJiYgbnVsbCAhPT0gaXRlbSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBpdGVtLl9fdHlwZV9fO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBkZXRlcm1pbmVUeXBlKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSB2YWwgPyBcInVuZGVmaW5lZFwiIDogbnVsbCA9PT0gdmFsID8gXCJudWxsXCIgOiBBcnJheS5pc0FycmF5KHZhbCkgPyBcImFycmF5XCIgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHZhbCA/IFwiZnVuY3Rpb25cIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbCA/IHZhbCBpbnN0YW5jZW9mIEVycm9yID8gXCJlcnJvclwiIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWwudGhlbiA/IFwicHJvbWlzZVwiIDogXCJbb2JqZWN0IFJlZ0V4cF1cIiA9PT0ge30udG9TdHJpbmcuY2FsbCh2YWwpID8gXCJyZWdleFwiIDogXCJbb2JqZWN0IERhdGVdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwodmFsKSA/IFwiZGF0ZVwiIDogXCJvYmplY3RcIiA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCA/IFwic3RyaW5nXCIgOiBcIm51bWJlclwiID09IHR5cGVvZiB2YWwgPyBcIm51bWJlclwiIDogXCJib29sZWFuXCIgPT0gdHlwZW9mIHZhbCA/IFwiYm9vbGVhblwiIDogdm9pZCAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVUeXBlKHR5cGUsIHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgX190eXBlX186IHR5cGUsXG5cdCAgICAgICAgICAgICAgICBfX3ZhbF9fOiB2YWxcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIF9TRVJJQUxJWkVSO1xuXHQgICAgICAgIHZhciBTRVJJQUxJWkVSID0gKChfU0VSSUFMSVpFUiA9IHt9KS5mdW5jdGlvbiA9IGZ1bmN0aW9uKCkge30sIF9TRVJJQUxJWkVSLmVycm9yID0gZnVuY3Rpb24oX3JlZikge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImVycm9yXCIsIHtcblx0ICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF9yZWYubWVzc2FnZSxcblx0ICAgICAgICAgICAgICAgIHN0YWNrOiBfcmVmLnN0YWNrLFxuXHQgICAgICAgICAgICAgICAgY29kZTogX3JlZi5jb2RlLFxuXHQgICAgICAgICAgICAgICAgZGF0YTogX3JlZi5kYXRhXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLnByb21pc2UgPSBmdW5jdGlvbigpIHt9LCBfU0VSSUFMSVpFUi5yZWdleCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcInJlZ2V4XCIsIHZhbC5zb3VyY2UpO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLmRhdGUgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJkYXRlXCIsIHZhbC50b0pTT04oKSk7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIuYXJyYXkgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5zdHJpbmcgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5udW1iZXIgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5ib29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIubnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSW3ZvaWQgMF0gPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJ1bmRlZmluZWRcIiwgdmFsKTtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUik7XG5cdCAgICAgICAgdmFyIGRlZmF1bHRTZXJpYWxpemVycyA9IHt9O1xuXHQgICAgICAgIHZhciBfREVTRVJJQUxJWkVSO1xuXHQgICAgICAgIHZhciBERVNFUklBTElaRVIgPSAoKF9ERVNFUklBTElaRVIgPSB7fSkuZnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gc2VyaWFsaXphdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQ7IG5vdGhpbmcgdG8gZGVzZXJpYWxpemVcIik7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5lcnJvciA9IGZ1bmN0aW9uKF9yZWYyKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGFjayA9IF9yZWYyLnN0YWNrLCBjb2RlID0gX3JlZjIuY29kZSwgZGF0YSA9IF9yZWYyLmRhdGE7XG5cdCAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihfcmVmMi5tZXNzYWdlKTtcblx0ICAgICAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XG5cdCAgICAgICAgICAgIGRhdGEgJiYgKGVycm9yLmRhdGEgPSBkYXRhKTtcblx0ICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBzdGFjayArIFwiXFxuXFxuXCIgKyBlcnJvci5zdGFjaztcblx0ICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIucHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlIHNlcmlhbGl6YXRpb24gaXMgbm90IGltcGxlbWVudGVkOyBub3RoaW5nIHRvIGRlc2VyaWFsaXplXCIpO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIucmVnZXggPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodmFsKTtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmRhdGUgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbCk7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5hcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIub2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5zdHJpbmcgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLm51bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuYm9vbGVhbiA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIubnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVJbdm9pZCAwXSA9IGZ1bmN0aW9uKCkge30sIF9ERVNFUklBTElaRVIpO1xuXHQgICAgICAgIHZhciBkZWZhdWx0RGVzZXJpYWxpemVycyA9IHt9O1xuXHQgICAgICAgIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICBpZiAod2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5KSByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG5cdCAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmJvZHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pLCAxMCk7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGNsZWFudXBQcm94eVdpbmRvd3MoKSB7XG5cdCAgICAgICAgICAgIHZhciBpZFRvUHJveHlXaW5kb3cgPSBnbG9iYWxTdG9yZShcImlkVG9Qcm94eVdpbmRvd1wiKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2lkVG9Qcm94eVdpbmRvdyRrZXlzMiA9IGlkVG9Qcm94eVdpbmRvdy5rZXlzKCk7IF9pMiA8IF9pZFRvUHJveHlXaW5kb3cka2V5czIubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGlkID0gX2lkVG9Qcm94eVdpbmRvdyRrZXlzMltfaTJdO1xuXHQgICAgICAgICAgICAgICAgaWRUb1Byb3h5V2luZG93LmdldChpZCkuc2hvdWxkQ2xlYW4oKSAmJiBpZFRvUHJveHlXaW5kb3cuZGVsKGlkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRTZXJpYWxpemVkV2luZG93KHdpblByb21pc2UsIF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmLnNlbmQsIF9yZWYkaWQgPSBfcmVmLmlkLCBpZCA9IHZvaWQgMCA9PT0gX3JlZiRpZCA/IHVuaXF1ZUlEKCkgOiBfcmVmJGlkO1xuXHQgICAgICAgICAgICB2YXIgd2luZG93TmFtZVByb21pc2UgPSB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSByZXR1cm4gYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWU7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgdmFyIHdpbmRvd1R5cGVQcm9taXNlID0gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW5kb3cpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW5kb3cpKSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgaXMgY2xvc2VkLCBjYW4gbm90IGRldGVybWluZSB0eXBlXCIpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGdldE9wZW5lcih3aW5kb3cpID8gXCJwb3B1cFwiIDogXCJpZnJhbWVcIjtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB3aW5kb3dOYW1lUHJvbWlzZS5jYXRjaChzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICAgICAgd2luZG93VHlwZVByb21pc2UuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgICAgIHZhciBnZXROYW1lID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWlzV2luZG93Q2xvc2VkKHdpbikpIHJldHVybiBpc1NhbWVEb21haW4od2luKSA/IGFzc2VydFNhbWVEb21haW4od2luKS5uYW1lIDogd2luZG93TmFtZVByb21pc2U7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICBnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93VHlwZVByb21pc2U7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgZ2V0SW5zdGFuY2VJRDogbWVtb2l6ZVByb21pc2UoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V2luZG93SW5zdGFuY2VJRCh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpLFxuXHQgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oY2xvc2VXaW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGdldE5hbWU6IGdldE5hbWUsXG5cdCAgICAgICAgICAgICAgICBmb2N1czogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5mb2N1cygpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1dpbmRvd0Nsb3NlZCh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBzZXRMb2NhdGlvbjogZnVuY3Rpb24oaHJlZiwgb3B0cykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0cyAmJiAob3B0cyA9IHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX29wdHMkbWV0aG9kID0gb3B0cy5tZXRob2QsIG1ldGhvZCA9IHZvaWQgMCA9PT0gX29wdHMkbWV0aG9kID8gXCJnZXRcIiA6IF9vcHRzJG1ldGhvZCwgYm9keSA9IG9wdHMuYm9keTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGhyZWYuaW5kZXhPZihcIi9cIikpIGhyZWYgPSBcIlwiICsgZG9tYWluICsgaHJlZjsgZWxzZSBpZiAoIWhyZWYubWF0Y2goL15odHRwcz86XFwvXFwvLykgJiYgMCAhPT0gaHJlZi5pbmRleE9mKGRvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHVybCB0byBiZSBodHRwIG9yIGh0dHBzIHVybCwgb3IgYWJzb2x1dGUgcGF0aCwgZ290IFwiICsgSlNPTi5zdHJpbmdpZnkoaHJlZikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJwb3N0XCIgPT09IG1ldGhvZCkgcmV0dXJuIGdldE5hbWUoKS50aGVuKChmdW5jdGlvbihuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcG9zdCB0byB3aW5kb3cgd2l0aG91dCB0YXJnZXQgbmFtZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihfcmVmMykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBfcmVmMy51cmwsIHRhcmdldCA9IF9yZWYzLnRhcmdldCwgYm9keSA9IF9yZWYzLmJvZHksIF9yZWYzJG1ldGhvZCA9IF9yZWYzLm1ldGhvZCwgbWV0aG9kID0gdm9pZCAwID09PSBfcmVmMyRtZXRob2QgPyBcInBvc3RcIiA6IF9yZWYzJG1ldGhvZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsIHRhcmdldCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoXCJtZXRob2RcIiwgbWV0aG9kKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZShcImFjdGlvblwiLCB1cmwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5KSBmb3IgKHZhciBfaTI0ID0gMCwgX09iamVjdCRrZXlzNCA9IE9iamVjdC5rZXlzKGJvZHkpOyBfaTI0IDwgX09iamVjdCRrZXlzNC5sZW5ndGg7IF9pMjQrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2JvZHkka2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzNFtfaTI0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIG51bGwgPT0gKF9ib2R5JGtleSA9IGJvZHlba2V5XSkgPyB2b2lkIDAgOiBfYm9keSRrZXkudG9TdHJpbmcoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCb2R5KCkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCb2R5KCkucmVtb3ZlQ2hpbGQoZm9ybSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGhyZWYsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImdldFwiICE9PSBtZXRob2QpIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lRG9tYWluKHdpbikpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luLmxvY2F0aW9uICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygd2luLmxvY2F0aW9uLnJlcGxhY2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW4ubG9jYXRpb24ucmVwbGFjZShocmVmKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luLmxvY2F0aW9uID0gaHJlZjtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgc2V0TmFtZTogZnVuY3Rpb24obmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2FtZURvbWFpbiA9IGlzU2FtZURvbWFpbih3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBnZXRGcmFtZUZvcldpbmRvdyh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEb21haW4pIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3Qgc2V0IG5hbWUgZm9yIGNyb3NzLWRvbWFpbiB3aW5kb3c6IFwiICsgbmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFNhbWVEb21haW4od2luKS5uYW1lID0gbmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgJiYgZnJhbWUuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBuYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93TmFtZVByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5yZXNvbHZlKG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHdpbmRvd19Qcm94eVdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBQcm94eVdpbmRvdyhfcmVmMikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmMi5zZW5kLCB3aW4gPSBfcmVmMi53aW4sIHNlcmlhbGl6ZWRXaW5kb3cgPSBfcmVmMi5zZXJpYWxpemVkV2luZG93O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaXNQcm94eVdpbmRvdyA9ICEwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVkV2luZG93ID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3R1YWxXaW5kb3cgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlbmQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UgPSBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cgPSBzZXJpYWxpemVkV2luZG93IHx8IGdldFNlcmlhbGl6ZWRXaW5kb3codGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImlkVG9Qcm94eVdpbmRvd1wiKS5zZXQodGhpcy5nZXRJRCgpLCB0aGlzKTtcblx0ICAgICAgICAgICAgICAgIHdpbiAmJiB0aGlzLnNldFdpbmRvdyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgX3Byb3RvID0gUHJveHlXaW5kb3cucHJvdG90eXBlO1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0SUQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuaWQ7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRUeXBlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldFR5cGUoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmlzUG9wdXAgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKS50aGVuKChmdW5jdGlvbih0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicG9wdXBcIiA9PT0gdHlwZTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNldExvY2F0aW9uID0gZnVuY3Rpb24oaHJlZiwgb3B0cykge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuc2V0TG9jYXRpb24oaHJlZiwgb3B0cykudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0TmFtZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5nZXROYW1lKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXROYW1lID0gZnVuY3Rpb24obmFtZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LnNldE5hbWUobmFtZSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMjtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuY2xvc2UoKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZm9jdXMgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGlzUG9wdXBQcm9taXNlID0gdGhpcy5pc1BvcHVwKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgZ2V0TmFtZVByb21pc2UgPSB0aGlzLmdldE5hbWUoKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZW9wZW5Qcm9taXNlID0gcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG5cdCAgICAgICAgICAgICAgICAgICAgaXNQb3B1cDogaXNQb3B1cFByb21pc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgbmFtZTogZ2V0TmFtZVByb21pc2Vcblx0ICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWYzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIF9yZWYzLmlzUG9wdXAgJiYgbmFtZSAmJiB3aW5kb3cub3BlbihcIlwiLCBuYW1lLCBcIm5vb3BlbmVyXCIpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGZvY3VzUHJvbWlzZSA9IHRoaXMuc2VyaWFsaXplZFdpbmRvdy5mb2N1cygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmFsbChbIHJlb3BlblByb21pc2UsIGZvY3VzUHJvbWlzZSBdKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uaXNDbG9zZWQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuaXNDbG9zZWQoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsV2luZG93O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2V0V2luZG93ID0gZnVuY3Rpb24od2luLCBfcmVmNCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNC5zZW5kO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5hY3R1YWxXaW5kb3cgPSB3aW47XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UucmVzb2x2ZSh0aGlzLmFjdHVhbFdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cgPSBnZXRTZXJpYWxpemVkV2luZG93KHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmQsXG5cdCAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0SUQoKVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB3aW5kb3dTdG9yZShcIndpblRvUHJveHlXaW5kb3dcIikuc2V0KHdpbiwgdGhpcyk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5hd2FpdFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLm1hdGNoV2luZG93ID0gZnVuY3Rpb24od2luLCBfcmVmNSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY1LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1LmFjdHVhbFdpbmRvdyA/IHdpbiA9PT0gX3RoaXM1LmFjdHVhbFdpbmRvdyA6IHByb21pc2VfWmFsZ29Qcm9taXNlLmhhc2goe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm94eUluc3RhbmNlSUQ6IF90aGlzNS5nZXRJbnN0YW5jZUlEKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGtub3duV2luZG93SW5zdGFuY2VJRDogZ2V0V2luZG93SW5zdGFuY2VJRCh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihfcmVmNikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBfcmVmNi5wcm94eUluc3RhbmNlSUQgPT09IF9yZWY2Lmtub3duV2luZG93SW5zdGFuY2VJRDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggJiYgX3RoaXM1LnNldFdpbmRvdyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by51bndyYXAgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdHVhbFdpbmRvdyB8fCB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0SW5zdGFuY2VJRCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5nZXRJbnN0YW5jZUlEKCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zaG91bGRDbGVhbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5hY3R1YWxXaW5kb3cgJiYgaXNXaW5kb3dDbG9zZWQodGhpcy5hY3R1YWxXaW5kb3cpKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cudW53cmFwID0gZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyh3aW4pID8gd2luLnVud3JhcCgpIDogd2luO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy5zZXJpYWxpemUgPSBmdW5jdGlvbih3aW4sIF9yZWY3KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY3LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KS5zZXJpYWxpemUoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cuZGVzZXJpYWxpemUgPSBmdW5jdGlvbihzZXJpYWxpemVkV2luZG93LCBfcmVmOCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmOC5zZW5kO1xuXHQgICAgICAgICAgICAgICAgY2xlYW51cFByb3h5V2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiaWRUb1Byb3h5V2luZG93XCIpLmdldChzZXJpYWxpemVkV2luZG93LmlkKSB8fCBuZXcgUHJveHlXaW5kb3coe1xuXHQgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRXaW5kb3c6IHNlcmlhbGl6ZWRXaW5kb3csXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LmlzUHJveHlXaW5kb3cgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKG9iaiAmJiAhaXNXaW5kb3cob2JqKSAmJiBvYmouaXNQcm94eVdpbmRvdyk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LnRvUHJveHlXaW5kb3cgPSBmdW5jdGlvbih3aW4sIF9yZWY5KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY5LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyh3aW4pKSByZXR1cm4gd2luO1xuXHQgICAgICAgICAgICAgICAgdmFyIGFjdHVhbFdpbmRvdyA9IHdpbjtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dTdG9yZShcIndpblRvUHJveHlXaW5kb3dcIikuZ2V0KGFjdHVhbFdpbmRvdykgfHwgbmV3IFByb3h5V2luZG93KHtcblx0ICAgICAgICAgICAgICAgICAgICB3aW46IGFjdHVhbFdpbmRvdyxcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIFByb3h5V2luZG93O1xuXHQgICAgICAgIH0oKTtcblx0ICAgICAgICBmdW5jdGlvbiBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgc291cmNlLCBkb21haW4pIHtcblx0ICAgICAgICAgICAgdmFyIG1ldGhvZFN0b3JlID0gd2luZG93U3RvcmUoXCJtZXRob2RTdG9yZVwiKTtcblx0ICAgICAgICAgICAgdmFyIHByb3h5V2luZG93TWV0aG9kcyA9IGdsb2JhbFN0b3JlKFwicHJveHlXaW5kb3dNZXRob2RzXCIpO1xuXHQgICAgICAgICAgICBpZiAod2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3coc291cmNlKSkgcHJveHlXaW5kb3dNZXRob2RzLnNldChpZCwge1xuXHQgICAgICAgICAgICAgICAgdmFsOiB2YWwsXG5cdCAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG5cdCAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuXHQgICAgICAgICAgICB9KTsgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwcm94eVdpbmRvd01ldGhvZHMuZGVsKGlkKTtcblx0ICAgICAgICAgICAgICAgIG1ldGhvZFN0b3JlLmdldE9yU2V0KHNvdXJjZSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgICAgIH0pKVtpZF0gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG5cdCAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWw6IHZhbCxcblx0ICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBsb29rdXBNZXRob2Qoc291cmNlLCBpZCkge1xuXHQgICAgICAgICAgICB2YXIgbWV0aG9kU3RvcmUgPSB3aW5kb3dTdG9yZShcIm1ldGhvZFN0b3JlXCIpO1xuXHQgICAgICAgICAgICB2YXIgcHJveHlXaW5kb3dNZXRob2RzID0gZ2xvYmFsU3RvcmUoXCJwcm94eVdpbmRvd01ldGhvZHNcIik7XG5cdCAgICAgICAgICAgIHJldHVybiBtZXRob2RTdG9yZS5nZXRPclNldChzb3VyY2UsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgfSkpW2lkXSB8fCBwcm94eVdpbmRvd01ldGhvZHMuZ2V0KGlkKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZnVuY3Rpb25fc2VyaWFsaXplRnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIF9yZWYzKSB7XG5cdCAgICAgICAgICAgIG9uID0gKF9yZWYgPSB7XG5cdCAgICAgICAgICAgICAgICBvbjogX3JlZjMub24sXG5cdCAgICAgICAgICAgICAgICBzZW5kOiBfcmVmMy5zZW5kXG5cdCAgICAgICAgICAgIH0pLm9uLCBzZW5kID0gX3JlZi5zZW5kLCBnbG9iYWxTdG9yZShcImJ1aWx0aW5MaXN0ZW5lcnNcIikuZ2V0T3JTZXQoXCJmdW5jdGlvbkNhbGxzXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBvbihcInBvc3Ryb2JvdF9tZXRob2RcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogXCIqXCJcblx0ICAgICAgICAgICAgICAgIH0sIChmdW5jdGlvbihfcmVmMikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfcmVmMi5zb3VyY2UsIG9yaWdpbiA9IF9yZWYyLm9yaWdpbiwgZGF0YSA9IF9yZWYyLmRhdGE7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gZGF0YS5pZCwgbmFtZSA9IGRhdGEubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aCA9IGxvb2t1cE1ldGhvZChzb3VyY2UsIGlkKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGgpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG1ldGhvZCAnXCIgKyBuYW1lICsgXCInIHdpdGggaWQ6IFwiICsgZGF0YS5pZCArIFwiIGluIFwiICsgZ2V0RG9tYWluKHdpbmRvdykpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2RTb3VyY2UgPSBtZXRoLnNvdXJjZSwgZG9tYWluID0gbWV0aC5kb21haW4sIHZhbCA9IG1ldGgudmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKGRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kICdcIiArIGRhdGEubmFtZSArIFwiJyBkb21haW4gXCIgKyBKU09OLnN0cmluZ2lmeSh1dGlsX2lzUmVnZXgobWV0aC5kb21haW4pID8gbWV0aC5kb21haW4uc291cmNlIDogbWV0aC5kb21haW4pICsgXCIgZG9lcyBub3QgbWF0Y2ggb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyBnZXREb21haW4od2luZG93KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyhtZXRob2RTb3VyY2UpKSByZXR1cm4gbWV0aG9kU291cmNlLm1hdGNoV2luZG93KHNvdXJjZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihtYXRjaCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIGNhbGwgJ1wiICsgZGF0YS5uYW1lICsgXCInIGZhaWxlZCAtIHByb3h5IHdpbmRvdyBkb2VzIG5vdCBtYXRjaCBzb3VyY2UgaW4gXCIgKyBnZXREb21haW4od2luZG93KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuYXBwbHkoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBkYXRhLmFyZ3MpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5vbkVycm9yKSByZXR1cm4gdmFsLm9uRXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICYmIChlcnIuc3RhY2sgPSBcIlJlbW90ZSBjYWxsIHRvIFwiICsgbmFtZSArIFwiKFwiICsgZnVuY3Rpb24oYXJncykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gYXJncyAmJiAoYXJncyA9IFtdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGl0ZW0gPSBhcmdzLCBbXS5zbGljZS5jYWxsKGl0ZW0pKS5tYXAoKGZ1bmN0aW9uKGFyZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgYXJnID8gXCInXCIgKyBhcmcgKyBcIidcIiA6IHZvaWQgMCA9PT0gYXJnID8gXCJ1bmRlZmluZWRcIiA6IG51bGwgPT09IGFyZyA/IFwibnVsbFwiIDogXCJib29sZWFuXCIgPT0gdHlwZW9mIGFyZyA/IGFyZy50b1N0cmluZygpIDogQXJyYXkuaXNBcnJheShhcmcpID8gXCJbIC4uLiBdXCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiBhcmcgPyBcInsgLi4uIH1cIiA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYXJnID8gXCIoKSA9PiB7IC4uLiB9XCIgOiBcIjxcIiArIHR5cGVvZiBhcmcgKyBcIj5cIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuam9pbihcIiwgXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShkYXRhLmFyZ3MpICsgXCIpIGZhaWxlZFxcblxcblwiICsgZXJyLnN0YWNrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB2YXIgX3JlZiwgb24sIHNlbmQ7XG5cdCAgICAgICAgICAgIHZhciBpZCA9IHZhbC5fX2lkX18gfHwgdW5pcXVlSUQoKTtcblx0ICAgICAgICAgICAgZGVzdGluYXRpb24gPSB3aW5kb3dfUHJveHlXaW5kb3cudW53cmFwKGRlc3RpbmF0aW9uKTtcblx0ICAgICAgICAgICAgdmFyIG5hbWUgPSB2YWwuX19uYW1lX18gfHwgdmFsLm5hbWUgfHwga2V5O1xuXHQgICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiBuYW1lICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbmFtZS5pbmRleE9mICYmIDAgPT09IG5hbWUuaW5kZXhPZihcImFub255bW91czo6XCIpICYmIChuYW1lID0gbmFtZS5yZXBsYWNlKFwiYW5vbnltb3VzOjpcIiwga2V5ICsgXCI6OlwiKSk7XG5cdCAgICAgICAgICAgIGlmICh3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyhkZXN0aW5hdGlvbikpIHtcblx0ICAgICAgICAgICAgICAgIGFkZE1ldGhvZChpZCwgdmFsLCBuYW1lLCBkZXN0aW5hdGlvbiwgZG9tYWluKTtcblx0ICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmF3YWl0V2luZG93KCkudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIHdpbiwgZG9tYWluKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGFkZE1ldGhvZChpZCwgdmFsLCBuYW1lLCBkZXN0aW5hdGlvbiwgZG9tYWluKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJjcm9zc19kb21haW5fZnVuY3Rpb25cIiwge1xuXHQgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplTWVzc2FnZShkZXN0aW5hdGlvbiwgZG9tYWluLCBvYmosIF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIF9zZXJpYWxpemU7XG5cdCAgICAgICAgICAgIHZhciBvbiA9IF9yZWYub24sIHNlbmQgPSBfcmVmLnNlbmQ7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXJzKSB7XG5cdCAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHNlcmlhbGl6ZXJzICYmIChzZXJpYWxpemVycyA9IGRlZmF1bHRTZXJpYWxpemVycyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkob2JqLCAoZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXNba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh0aGlzKSkgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGRldGVybWluZVR5cGUodmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGUpIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc1t0eXBlXSB8fCBTRVJJQUxJWkVSW3R5cGVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVyID8gc2VyaWFsaXplcih2YWwsIGtleSkgOiB2YWw7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSByZXN1bHQgPyBcInVuZGVmaW5lZFwiIDogcmVzdWx0O1xuXHQgICAgICAgICAgICB9KG9iaiwgKChfc2VyaWFsaXplID0ge30pLnByb21pc2UgPSBmdW5jdGlvbih2YWwsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCBfcmVmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJjcm9zc19kb21haW5femFsZ29fcHJvbWlzZVwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uX3NlcmlhbGl6ZUZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSwga2V5LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogX3JlZi5vbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IF9yZWYuc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfShkZXN0aW5hdGlvbiwgZG9tYWluLCB2YWwsIGtleSwge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZS5mdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25fc2VyaWFsaXplRnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIF9zZXJpYWxpemUub2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaXNXaW5kb3codmFsKSB8fCB3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyh2YWwpID8gc2VyaWFsaXplVHlwZShcImNyb3NzX2RvbWFpbl93aW5kb3dcIiwgd2luZG93X1Byb3h5V2luZG93LnNlcmlhbGl6ZSh2YWwsIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KSkgOiB2YWw7XG5cdCAgICAgICAgICAgIH0sIF9zZXJpYWxpemUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemVNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCBfcmVmMikge1xuXHQgICAgICAgICAgICB2YXIgX2Rlc2VyaWFsaXplO1xuXHQgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYyLnNlbmQ7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdHIsIGRlc2VyaWFsaXplcnMpIHtcblx0ICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVzZXJpYWxpemVycyAmJiAoZGVzZXJpYWxpemVycyA9IGRlZmF1bHREZXNlcmlhbGl6ZXJzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSBzdHIpIHJldHVybiBKU09OLnBhcnNlKHN0ciwgKGZ1bmN0aW9uKGtleSwgdmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFR5cGUodGhpcykpIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRUeXBlKHZhbCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHZhbC5fX3R5cGVfXztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWwuX192YWxfXztcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gZGV0ZXJtaW5lVHlwZSh2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlKSByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2VyaWFsaXplciA9IGRlc2VyaWFsaXplcnNbdHlwZV0gfHwgREVTRVJJQUxJWkVSW3R5cGVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZXIgPyBkZXNlcmlhbGl6ZXIodmFsdWUsIGtleSkgOiB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfShtZXNzYWdlLCAoKF9kZXNlcmlhbGl6ZSA9IHt9KS5jcm9zc19kb21haW5femFsZ29fcHJvbWlzZSA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRQcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBvcmlnaW4sIF9yZWYyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZShfcmVmMi50aGVuKTtcblx0ICAgICAgICAgICAgICAgIH0oMCwgMCwgc2VyaWFsaXplZFByb21pc2UpO1xuXHQgICAgICAgICAgICB9LCBfZGVzZXJpYWxpemUuY3Jvc3NfZG9tYWluX2Z1bmN0aW9uID0gZnVuY3Rpb24oc2VyaWFsaXplZEZ1bmN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlLCBvcmlnaW4sIF9yZWY0LCBfcmVmNSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IF9yZWY0LmlkLCBuYW1lID0gX3JlZjQubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY1LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdldERlc2VyaWFsaXplZEZ1bmN0aW9uID0gZnVuY3Rpb24ob3B0cykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG9wdHMgJiYgKG9wdHMgPSB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93LnRvUHJveHlXaW5kb3coc291cmNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aCA9IGxvb2t1cE1ldGhvZCh3aW4sIGlkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aCAmJiBtZXRoLnZhbCAhPT0gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIpIHJldHVybiBtZXRoLnZhbC5hcHBseSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogd2luZG93LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbigpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2FyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hcmdzID0gW10uc2xpY2UuY2FsbChfYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0cy5maXJlQW5kRm9yZ2V0ID8gc2VuZCh3aW4sIFwicG9zdHJvYm90X21ldGhvZFwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogX2FyZ3Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiAhMFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogc2VuZCh3aW4sIFwicG9zdHJvYm90X21ldGhvZFwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogX2FyZ3Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiAhMVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRhdGEucmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLl9fbmFtZV9fID0gbmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19vcmlnaW5fXyA9IG9yaWdpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19zb3VyY2VfXyA9IHNvdXJjZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19pZF9fID0gaWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLm9yaWdpbiA9IG9yaWdpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyID0gZ2V0RGVzZXJpYWxpemVkRnVuY3Rpb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5maXJlQW5kRm9yZ2V0ID0gZ2V0RGVzZXJpYWxpemVkRnVuY3Rpb24oe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiAhMFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcjtcblx0ICAgICAgICAgICAgICAgIH0oc291cmNlLCBvcmlnaW4sIHNlcmlhbGl6ZWRGdW5jdGlvbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCBfZGVzZXJpYWxpemUuY3Jvc3NfZG9tYWluX3dpbmRvdyA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRXaW5kb3cpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cuZGVzZXJpYWxpemUoc2VyaWFsaXplZFdpbmRvdywge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCBfZGVzZXJpYWxpemUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTID0ge307XG5cdCAgICAgICAgU0VORF9NRVNTQUdFX1NUUkFURUdJRVMucG9zdHJvYm90X3Bvc3RfbWVzc2FnZSA9IGZ1bmN0aW9uKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbikge1xuXHQgICAgICAgICAgICAwID09PSBkb21haW4uaW5kZXhPZihcImZpbGU6XCIpICYmIChkb21haW4gPSBcIipcIik7XG5cdCAgICAgICAgICAgIHdpbi5wb3N0TWVzc2FnZShzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIHNlbmRfc2VuZE1lc3NhZ2Uod2luLCBkb21haW4sIG1lc3NhZ2UsIF9yZWYyKSB7XG5cdCAgICAgICAgICAgIHZhciBvbiA9IF9yZWYyLm9uLCBzZW5kID0gX3JlZjIuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZG9tYWluQnVmZmVyID0gd2luZG93U3RvcmUoKS5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICBkb21haW5CdWZmZXIuYnVmZmVyID0gZG9tYWluQnVmZmVyLmJ1ZmZlciB8fCBbXTtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbkJ1ZmZlci5idWZmZXIucHVzaChtZXNzYWdlKTtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbkJ1ZmZlci5mbHVzaCA9IGRvbWFpbkJ1ZmZlci5mbHVzaCB8fCBwcm9taXNlX1phbGdvUHJvbWlzZS5mbHVzaCgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgaXMgY2xvc2VkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkTWVzc2FnZSA9IHNlcmlhbGl6ZU1lc3NhZ2Uod2luLCBkb21haW4sICgoX3JlZiA9IHt9KS5fX3Bvc3Rfcm9ib3RfMTBfMF80Nl9fID0gZG9tYWluQnVmZmVyLmJ1ZmZlciB8fCBbXSwgXG5cdCAgICAgICAgICAgICAgICAgICAgX3JlZiksIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbkJ1ZmZlci5idWZmZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmF0ZWdpZXMgPSBPYmplY3Qua2V5cyhTRU5EX01FU1NBR0VfU1RSQVRFR0lFUyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHN0cmF0ZWdpZXMubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyYXRlZ3lOYW1lID0gc3RyYXRlZ2llc1tfaTJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgU0VORF9NRVNTQUdFX1NUUkFURUdJRVNbc3RyYXRlZ3lOYW1lXSh3aW4sIHNlcmlhbGl6ZWRNZXNzYWdlLCBkb21haW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT09IHN0cmF0ZWdpZXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJBbGwgcG9zdC1yb2JvdCBtZXNzYWdpbmcgc3RyYXRlZ2llcyBmYWlsZWQ6XFxuXFxuXCIgKyBlcnJvcnMubWFwKChmdW5jdGlvbihlcnIsIGkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKyBcIi4gXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKS5qb2luKFwiXFxuXFxuXCIpKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkb21haW5CdWZmZXIuZmx1c2gudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbkJ1ZmZlci5mbHVzaDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSkpLnRoZW4oc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFJlc3BvbnNlTGlzdGVuZXIoaGFzaCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKS5nZXQoaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZVJlc3BvbnNlTGlzdGVuZXIoaGFzaCkge1xuXHQgICAgICAgICAgICBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpLmRlbChoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZChoYXNoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcImVycm9yZWRSZXNwb25zZUxpc3RlbmVyc1wiKS5oYXMoaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFJlcXVlc3RMaXN0ZW5lcihfcmVmKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLCB3aW4gPSBfcmVmLndpbiwgZG9tYWluID0gX3JlZi5kb21haW47XG5cdCAgICAgICAgICAgIHZhciByZXF1ZXN0TGlzdGVuZXJzID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0TGlzdGVuZXJzXCIpO1xuXHQgICAgICAgICAgICBcIipcIiA9PT0gd2luICYmICh3aW4gPSBudWxsKTtcblx0ICAgICAgICAgICAgXCIqXCIgPT09IGRvbWFpbiAmJiAoZG9tYWluID0gbnVsbCk7XG5cdCAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSByZXF1aXJlZCB0byBnZXQgcmVxdWVzdCBsaXN0ZW5lclwiKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX3JlZjMgPSBbIHdpbiwgZ2V0V2lsZGNhcmQoKSBdOyBfaTQgPCBfcmVmMy5sZW5ndGg7IF9pNCsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luUXVhbGlmaWVyID0gX3JlZjNbX2k0XTtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW5RdWFsaWZpZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZUxpc3RlbmVycyA9IHJlcXVlc3RMaXN0ZW5lcnMuZ2V0KHdpblF1YWxpZmllcik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVMaXN0ZW5lcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbkxpc3RlbmVycyA9IG5hbWVMaXN0ZW5lcnNbbmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVyc1tkb21haW5dKSByZXR1cm4gZG9tYWluTGlzdGVuZXJzW2RvbWFpbl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVycy5fX2RvbWFpbl9yZWdleF9fKSBmb3IgKHZhciBfaTYgPSAwLCBfZG9tYWluTGlzdGVuZXJzJF9fRE8yID0gZG9tYWluTGlzdGVuZXJzLl9fZG9tYWluX3JlZ2V4X187IF9pNiA8IF9kb21haW5MaXN0ZW5lcnMkX19ETzIubGVuZ3RoOyBfaTYrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2RvbWFpbkxpc3RlbmVycyRfX0RPMyA9IF9kb21haW5MaXN0ZW5lcnMkX19ETzJbX2k2XSwgbGlzdGVuZXIgPSBfZG9tYWluTGlzdGVuZXJzJF9fRE8zLmxpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hEb21haW4oX2RvbWFpbkxpc3RlbmVycyRfX0RPMy5yZWdleCwgZG9tYWluKSkgcmV0dXJuIGxpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnNbXCIqXCJdKSByZXR1cm4gZG9tYWluTGlzdGVuZXJzW1wiKlwiXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCBfcmVmKSB7XG5cdCAgICAgICAgICAgIHZhciBvbiA9IF9yZWYub24sIHNlbmQgPSBfcmVmLnNlbmQ7XG5cdCAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0UmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSxcblx0ICAgICAgICAgICAgICAgIHdpbjogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW5cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHZhciBsb2dOYW1lID0gXCJwb3N0cm9ib3RfbWV0aG9kXCIgPT09IG1lc3NhZ2UubmFtZSAmJiBtZXNzYWdlLmRhdGEgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgbWVzc2FnZS5kYXRhLm5hbWUgPyBtZXNzYWdlLmRhdGEubmFtZSArIFwiKClcIiA6IG1lc3NhZ2UubmFtZTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc2VuZFJlc3BvbnNlKGFjaywgZGF0YSwgZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5mbHVzaCgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5maXJlQW5kRm9yZ2V0ICYmICFpc1dpbmRvd0Nsb3NlZChzb3VyY2UpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZF9zZW5kTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHVuaXF1ZUlEKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbih3aW5kb3cpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb3N0cm9ib3RfbWVzc2FnZV9yZXNwb25zZVwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogbWVzc2FnZS5oYXNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNrOiBhY2ssXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgcmVzcG9uc2UgbWVzc2FnZSBmYWlsZWQgZm9yIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIlxcblxcblwiICsgc3RyaW5naWZ5RXJyb3IoZXJyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwoWyBwcm9taXNlX1phbGdvUHJvbWlzZS5mbHVzaCgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmZpcmVBbmRGb3JnZXQgJiYgIWlzV2luZG93Q2xvc2VkKHNvdXJjZSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRfc2VuZE1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHVuaXF1ZUlEKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKHdpbmRvdyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicG9zdHJvYm90X21lc3NhZ2VfYWNrXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IG1lc3NhZ2UuaGFzaCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lXG5cdCAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgYWNrIG1lc3NhZ2UgZmFpbGVkIGZvciBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCJcXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KSksIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZTogXCIgKyBtZXNzYWdlLm5hbWUgKyBcIiBmcm9tIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5oYW5kbGVyKHtcblx0ICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlLmRhdGFcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZShcInN1Y2Nlc3NcIiwgZGF0YSk7XG5cdCAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzZW5kUmVzcG9uc2UoXCJlcnJvclwiLCBudWxsLCBlcnJvcik7XG5cdCAgICAgICAgICAgIH0pKSBdKS50aGVuKHNyY191dGlsX25vb3ApLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGFuZGxlRXJyb3IpIHJldHVybiBvcHRpb25zLmhhbmRsZUVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaGFuZGxlQWNrKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSB7XG5cdCAgICAgICAgICAgIGlmICghaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZChtZXNzYWdlLmhhc2gpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldFJlc3BvbnNlTGlzdGVuZXIobWVzc2FnZS5oYXNoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKFwiTm8gaGFuZGxlciBmb3VuZCBmb3IgcG9zdCBtZXNzYWdlIGFjayBmb3IgbWVzc2FnZTogXCIgKyBtZXNzYWdlLm5hbWUgKyBcIiBmcm9tIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4ob3B0aW9ucy5kb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIkFjayBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyBvcHRpb25zLmRvbWFpbi50b1N0cmluZygpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSBvcHRpb25zLndpbikgdGhyb3cgbmV3IEVycm9yKFwiQWNrIHNvdXJjZSBkb2VzIG5vdCBtYXRjaCByZWdpc3RlcmVkIHdpbmRvd1wiKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuYWNrID0gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgaWYgKCFpc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkKG1lc3NhZ2UuaGFzaCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0UmVzcG9uc2VMaXN0ZW5lcihtZXNzYWdlLmhhc2gpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgcmVzcG9uc2UgZm9yIG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbihvcHRpb25zLmRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2Ugb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgZG9lcyBub3QgbWF0Y2ggZG9tYWluIFwiICsgKHBhdHRlcm4gPSBvcHRpb25zLmRvbWFpbiwgXG5cdCAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHBhdHRlcm4pID8gXCIoXCIgKyBwYXR0ZXJuLmpvaW4oXCIgfCBcIikgKyBcIilcIiA6IGlzUmVnZXgocGF0dGVybikgPyBcIlJlZ0V4cChcIiArIHBhdHRlcm4udG9TdHJpbmcoKSArIFwiKVwiIDogcGF0dGVybi50b1N0cmluZygpKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGF0dGVybjtcblx0ICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IG9wdGlvbnMud2luKSB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBzb3VyY2UgZG9lcyBub3QgbWF0Y2ggcmVnaXN0ZXJlZCB3aW5kb3dcIik7XG5cdCAgICAgICAgICAgICAgICBkZWxldGVSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG5cdCAgICAgICAgICAgICAgICBcImVycm9yXCIgPT09IG1lc3NhZ2UuYWNrID8gb3B0aW9ucy5wcm9taXNlLnJlamVjdChtZXNzYWdlLmVycm9yKSA6IFwic3VjY2Vzc1wiID09PSBtZXNzYWdlLmFjayAmJiBvcHRpb25zLnByb21pc2UucmVzb2x2ZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YTogbWVzc2FnZS5kYXRhXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiByZWNlaXZlX3JlY2VpdmVNZXNzYWdlKGV2ZW50LCBfcmVmMikge1xuXHQgICAgICAgICAgICB2YXIgb24gPSBfcmVmMi5vbiwgc2VuZCA9IF9yZWYyLnNlbmQ7XG5cdCAgICAgICAgICAgIHZhciByZWNlaXZlZE1lc3NhZ2VzID0gZ2xvYmFsU3RvcmUoXCJyZWNlaXZlZE1lc3NhZ2VzXCIpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cgfHwgd2luZG93LmNsb3NlZCB8fCAhZXZlbnQuc291cmNlKSByZXR1cm47XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UsIG9yaWdpbiA9IGV2ZW50Lm9yaWdpbjtcblx0ICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gZnVuY3Rpb24obWVzc2FnZSwgc291cmNlLCBvcmlnaW4sIF9yZWYpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWYub24sIHNlbmQgPSBfcmVmLnNlbmQ7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyc2VkTWVzc2FnZTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyc2VkTWVzc2FnZSA9IGRlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChwYXJzZWRNZXNzYWdlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHBhcnNlZE1lc3NhZ2UgJiYgbnVsbCAhPT0gcGFyc2VkTWVzc2FnZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZU1lc3NhZ2VzID0gcGFyc2VkTWVzc2FnZS5fX3Bvc3Rfcm9ib3RfMTBfMF80Nl9fO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlTWVzc2FnZXMpKSByZXR1cm4gcGFyc2VNZXNzYWdlcztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfShldmVudC5kYXRhLCBzb3VyY2UsIG9yaWdpbiwge1xuXHQgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG5cdCAgICAgICAgICAgICAgICBtYXJrV2luZG93S25vd24oc291cmNlKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG1lc3NhZ2VzLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW19pMl07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkTWVzc2FnZXMuaGFzKG1lc3NhZ2UuaWQpKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWRNZXNzYWdlcy5zZXQobWVzc2FnZS5pZCwgITApO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZChzb3VyY2UpICYmICFtZXNzYWdlLmZpcmVBbmRGb3JnZXQpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAwID09PSBtZXNzYWdlLm9yaWdpbi5pbmRleE9mKFwiZmlsZTpcIikgJiYgKG9yaWdpbiA9IFwiZmlsZTovL1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInBvc3Ryb2JvdF9tZXNzYWdlX3JlcXVlc3RcIiA9PT0gbWVzc2FnZS50eXBlID8gaGFuZGxlUmVxdWVzdChzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSA6IFwicG9zdHJvYm90X21lc3NhZ2VfcmVzcG9uc2VcIiA9PT0gbWVzc2FnZS50eXBlID8gaGFuZGxlUmVzcG9uc2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIDogXCJwb3N0cm9ib3RfbWVzc2FnZV9hY2tcIiA9PT0gbWVzc2FnZS50eXBlICYmIGhhbmRsZUFjayhzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG9uX29uKG5hbWUsIG9wdGlvbnMsIGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBuYW1lXCIpO1xuXHQgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pKSB7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyID0gb3B0aW9ucztcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGhhbmRsZXJcIik7XG5cdCAgICAgICAgICAgIHZhciByZXF1ZXN0TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRSZXF1ZXN0TGlzdGVuZXIoX3JlZjQsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWY0Lm5hbWUsIHdpbkNhbmRpZGF0ZSA9IF9yZWY0LndpbiwgZG9tYWluID0gX3JlZjQuZG9tYWluO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lcnMgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RMaXN0ZW5lcnNcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW5hbWUgfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSByZXF1aXJlZCB0byBhZGQgcmVxdWVzdCBsaXN0ZW5lclwiKTtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW5DYW5kaWRhdGUgJiYgXCIqXCIgIT09IHdpbkNhbmRpZGF0ZSAmJiB3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyh3aW5DYW5kaWRhdGUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lclByb21pc2UgPSB3aW5DYW5kaWRhdGUuYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbihhY3R1YWxXaW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZFJlcXVlc3RMaXN0ZW5lcih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luOiBhY3R1YWxXaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TGlzdGVuZXJQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHJlcXVlc3RMaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0TGlzdGVuZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIHdpbiA9IHdpbkNhbmRpZGF0ZTtcblx0ICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdpbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzQ29sbGVjdGlvbiA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pOCA9IDAsIF93aW4yID0gd2luOyBfaTggPCBfd2luMi5sZW5ndGg7IF9pOCsrKSBsaXN0ZW5lcnNDb2xsZWN0aW9uLnB1c2goYWRkUmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogX3dpbjJbX2k4XVxuXHQgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgbGlzdGVuZXJzQ29sbGVjdGlvbi5sZW5ndGg7IF9pMTArKykgbGlzdGVuZXJzQ29sbGVjdGlvbltfaTEwXS5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkb21haW4pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9saXN0ZW5lcnNDb2xsZWN0aW9uID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxMiA9IDAsIF9kb21haW4yID0gZG9tYWluOyBfaTEyIDwgX2RvbWFpbjIubGVuZ3RoOyBfaTEyKyspIF9saXN0ZW5lcnNDb2xsZWN0aW9uLnB1c2goYWRkUmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luOiB3aW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogX2RvbWFpbjJbX2kxMl1cblx0ICAgICAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lcikpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTE0ID0gMDsgX2kxNCA8IF9saXN0ZW5lcnNDb2xsZWN0aW9uLmxlbmd0aDsgX2kxNCsrKSBfbGlzdGVuZXJzQ29sbGVjdGlvbltfaTE0XS5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdMaXN0ZW5lciA9IGdldFJlcXVlc3RMaXN0ZW5lcih7XG5cdCAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB3aW4gJiYgXCIqXCIgIT09IHdpbiB8fCAod2luID0gZ2V0V2lsZGNhcmQoKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RyRG9tYWluID0gKGRvbWFpbiA9IGRvbWFpbiB8fCBcIipcIikudG9TdHJpbmcoKTtcblx0ICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0xpc3RlbmVyKSB0aHJvdyB3aW4gJiYgZG9tYWluID8gbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lICsgXCIgb24gZG9tYWluIFwiICsgZG9tYWluLnRvU3RyaW5nKCkgKyBcIiBmb3IgXCIgKyAod2luID09PSBnZXRXaWxkY2FyZCgpID8gXCJ3aWxkY2FyZFwiIDogXCJzcGVjaWZpZWRcIikgKyBcIiB3aW5kb3dcIikgOiB3aW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBmb3IgXCIgKyAod2luID09PSBnZXRXaWxkY2FyZCgpID8gXCJ3aWxkY2FyZFwiIDogXCJzcGVjaWZpZWRcIikgKyBcIiB3aW5kb3dcIikgOiBkb21haW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBvbiBkb21haW4gXCIgKyBkb21haW4udG9TdHJpbmcoKSkgOiBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVMaXN0ZW5lcnMgPSByZXF1ZXN0TGlzdGVuZXJzLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lRG9tYWluTGlzdGVuZXJzID0gdXRpbF9nZXRPclNldCh3aW5OYW1lTGlzdGVuZXJzLCBuYW1lLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycztcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgIHV0aWxfaXNSZWdleChkb21haW4pID8gKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycyA9IHV0aWxfZ2V0T3JTZXQod2luTmFtZURvbWFpbkxpc3RlbmVycywgXCJfX2RvbWFpbl9yZWdleF9fXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgICAgICAgICB9KSkpLnB1c2god2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXIgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVnZXg6IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcblx0ICAgICAgICAgICAgICAgIH0pIDogd2luTmFtZURvbWFpbkxpc3RlbmVyc1tzdHJEb21haW5dID0gbGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5OYW1lRG9tYWluTGlzdGVuZXJzW3N0ckRvbWFpbl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzLnNwbGljZSh3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnMuaW5kZXhPZih3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lciwgMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzLmxlbmd0aCB8fCBkZWxldGUgd2luTmFtZURvbWFpbkxpc3RlbmVycy5fX2RvbWFpbl9yZWdleF9fO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHdpbk5hbWVEb21haW5MaXN0ZW5lcnMpLmxlbmd0aCB8fCBkZWxldGUgd2luTmFtZUxpc3RlbmVyc1tuYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luICYmICFPYmplY3Qua2V5cyh3aW5OYW1lTGlzdGVuZXJzKS5sZW5ndGggJiYgcmVxdWVzdExpc3RlbmVycy5kZWwod2luKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KHtcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICB3aW46IG9wdGlvbnMud2luZG93LFxuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBvcHRpb25zLmRvbWFpbiB8fCBcIipcIlxuXHQgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyIHx8IG9wdGlvbnMuaGFuZGxlcixcblx0ICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yOiBvcHRpb25zLmVycm9ySGFuZGxlciB8fCBmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TGlzdGVuZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG9uX29uY2UobmFtZSwgb3B0aW9ucywgaGFuZGxlcikge1xuXHQgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pKSB7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyID0gb3B0aW9ucztcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgdmFyIGxpc3RlbmVyO1xuXHQgICAgICAgICAgICBvcHRpb25zLmVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBsaXN0ZW5lciA9IG9uX29uKG5hbWUsIG9wdGlvbnMsIChmdW5jdGlvbihldmVudCkge1xuXHQgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHJldHVybiBoYW5kbGVyKGV2ZW50KTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICBwcm9taXNlLmNhbmNlbCA9IGxpc3RlbmVyLmNhbmNlbDtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzZW5kX3NlbmQgPSBmdW5jdGlvbiBzZW5kKHdpbk9yUHJveHlXaW4sIG5hbWUsIGRhdGEsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIGRvbWFpbk1hdGNoZXIgPSAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pLmRvbWFpbiB8fCBcIipcIjtcblx0ICAgICAgICAgICAgdmFyIHJlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCAtMTtcblx0ICAgICAgICAgICAgdmFyIGNoaWxkVGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCA1ZTM7XG5cdCAgICAgICAgICAgIHZhciBmaXJlQW5kRm9yZ2V0ID0gb3B0aW9ucy5maXJlQW5kRm9yZ2V0IHx8ICExO1xuXHQgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93LnRvUHJveHlXaW5kb3cod2luT3JQcm94eVdpbiwge1xuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICB9KS5hd2FpdFdpbmRvdygpLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKG5hbWUsIHdpbiwgZG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbmFtZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBkb21haW4gJiYgIUFycmF5LmlzQXJyYXkoZG9tYWluKSAmJiAhdXRpbF9pc1JlZ2V4KGRvbWFpbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IHNlbmQgXCIgKyBuYW1lICsgXCIuIEV4cGVjdGVkIGRvbWFpbiBcIiArIEpTT04uc3RyaW5naWZ5KGRvbWFpbikgKyBcIiB0byBiZSBhIHN0cmluZywgYXJyYXksIG9yIHJlZ2V4XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZW5kIFwiICsgbmFtZSArIFwiLiBUYXJnZXQgd2luZG93IGlzIGNsb3NlZFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KG5hbWUsIHdpbiwgZG9tYWluTWF0Y2hlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKHBhcmVudCwgY2hpbGQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdHVhbFBhcmVudCA9IGdldEFuY2VzdG9yKGNoaWxkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdHVhbFBhcmVudCkgcmV0dXJuIGFjdHVhbFBhcmVudCA9PT0gcGFyZW50O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbi50b3ApIHJldHVybiB3aW4udG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldFBhcmVudCh3aW4pID09PSB3aW4pIHJldHVybiB3aW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FuY2VzdG9yUGFyZW50KHdpbmRvdywgd2luKSAmJiB3aW5kb3cudG9wKSByZXR1cm4gd2luZG93LnRvcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQW5jZXN0b3JQYXJlbnQod2luLCB3aW5kb3cpICYmIHdpbmRvdy50b3ApIHJldHVybiB3aW5kb3cudG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k3ID0gMCwgX2dldEFsbENoaWxkRnJhbWVzNCA9IGZ1bmN0aW9uIGdldEFsbENoaWxkRnJhbWVzKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwLCBfZ2V0RnJhbWVzMiA9IGdldEZyYW1lcyh3aW4pOyBfaTMgPCBfZ2V0RnJhbWVzMi5sZW5ndGg7IF9pMysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9nZXRGcmFtZXMyW19pM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMCwgX2dldEFsbENoaWxkRnJhbWVzMiA9IGdldEFsbENoaWxkRnJhbWVzKGZyYW1lKTsgX2k1IDwgX2dldEFsbENoaWxkRnJhbWVzMi5sZW5ndGg7IF9pNSsrKSByZXN1bHQucHVzaChfZ2V0QWxsQ2hpbGRGcmFtZXMyW19pNV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW4pOyBfaTcgPCBfZ2V0QWxsQ2hpbGRGcmFtZXM0Lmxlbmd0aDsgX2k3KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBfZ2V0QWxsQ2hpbGRGcmFtZXM0W19pN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lLnRvcCkgcmV0dXJuIGZyYW1lLnRvcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldFBhcmVudChmcmFtZSkgPT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0oY2hpbGQpID09PSBjaGlsZCkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTE1ID0gMCwgX2dldEZyYW1lczggPSBnZXRGcmFtZXMocGFyZW50KTsgX2kxNSA8IF9nZXRGcmFtZXM4Lmxlbmd0aDsgX2kxNSsrKSBpZiAoX2dldEZyYW1lczhbX2kxNV0gPT09IGNoaWxkKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgICAgICB9KHdpbmRvdywgd2luKSkgcmV0dXJuIGZ1bmN0aW9uKHdpbiwgdGltZW91dCwgbmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHRpbWVvdXQgJiYgKHRpbWVvdXQgPSA1ZTMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IG5hbWUgJiYgKG5hbWUgPSBcIldpbmRvd1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dTdG9yZShcImhlbGxvUHJvbWlzZXNcIikuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAtMSAhPT0gdGltZW91dCAmJiAocHJvbWlzZSA9IHByb21pc2UudGltZW91dCh0aW1lb3V0LCBuZXcgRXJyb3IobmFtZSArIFwiIGRpZCBub3QgbG9hZCBhZnRlciBcIiArIHRpbWVvdXQgKyBcIm1zXCIpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0od2luLCBjaGlsZFRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKF90ZW1wKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHdpbiwgdGFyZ2V0RG9tYWluLCBhY3R1YWxEb21haW4sIF9yZWYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmLnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHRhcmdldERvbWFpbiA/IHRhcmdldERvbWFpbiA6IHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbERvbWFpbiB8fCBzYXlIZWxsbyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWYyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmMi5kb21haW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKG5vcm1hbGl6ZWREb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKHRhcmdldERvbWFpbiwgdGFyZ2V0RG9tYWluKSkgdGhyb3cgbmV3IEVycm9yKFwiRG9tYWluIFwiICsgc3RyaW5naWZ5KHRhcmdldERvbWFpbikgKyBcIiBkb2VzIG5vdCBtYXRjaCBcIiArIHN0cmluZ2lmeSh0YXJnZXREb21haW4pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZERvbWFpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0od2luLCBkb21haW5NYXRjaGVyLCAodm9pZCAwID09PSBfdGVtcCA/IHt9IDogX3RlbXApLmRvbWFpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24odGFyZ2V0RG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHRhcmdldERvbWFpbjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbG9nTmFtZSA9IFwicG9zdHJvYm90X21ldGhvZFwiID09PSBuYW1lICYmIGRhdGEgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZGF0YS5uYW1lID8gZGF0YS5uYW1lICsgXCIoKVwiIDogbmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IG5hbWUgKyBcIl9cIiArIHVuaXF1ZUlEKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJlQW5kRm9yZ2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZUxpc3RlbmVyID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBwcm9taXNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihoYXNoLCBsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKS5zZXQoaGFzaCwgbGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KGhhc2gsIHJlc3BvbnNlTGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxUHJvbWlzZXMgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RQcm9taXNlc1wiKS5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXFQcm9taXNlcy5wdXNoKHByb21pc2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmNhdGNoKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihoYXNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoXCJlcnJvcmVkUmVzcG9uc2VMaXN0ZW5lcnNcIikuc2V0KGhhc2gsICEwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oaGFzaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZXNwb25zZUxpc3RlbmVyKGhhc2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbEFja1RpbWVvdXQgPSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dTdG9yZShcImtub3duV2luZG93c1wiKS5nZXQod2luLCAhMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0od2luKSA/IDFlNCA6IDJlMztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsUmVzVGltZW91dCA9IHJlc3BvbnNlVGltZW91dDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFja1RpbWVvdXQgPSB0b3RhbEFja1RpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNUaW1lb3V0ID0gdG90YWxSZXNUaW1lb3V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBmdW5jdGlvbihtZXRob2QsIHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uIGxvb3AoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkgcmV0dXJuIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldpbmRvdyBjbG9zZWQgZm9yIFwiICsgbmFtZSArIFwiIGJlZm9yZSBcIiArIChyZXNwb25zZUxpc3RlbmVyLmFjayA/IFwicmVzcG9uc2VcIiA6IFwiYWNrXCIpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VMaXN0ZW5lci5jYW5jZWxsZWQpIHJldHVybiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJSZXNwb25zZSBsaXN0ZW5lciB3YXMgY2FuY2VsbGVkIGZvciBcIiArIG5hbWUpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFja1RpbWVvdXQgPSBNYXRoLm1heChhY2tUaW1lb3V0IC0gNTAwLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xICE9PSByZXNUaW1lb3V0ICYmIChyZXNUaW1lb3V0ID0gTWF0aC5tYXgocmVzVGltZW91dCAtIDUwMCwgMCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VMaXN0ZW5lci5hY2sgfHwgMCAhPT0gYWNrVGltZW91dCA/IDAgPT09IHJlc1RpbWVvdXQgJiYgcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gcmVzcG9uc2UgZm9yIHBvc3RNZXNzYWdlIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIiBpbiBcIiArIHRvdGFsUmVzVGltZW91dCArIFwibXNcIikpIDogcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gYWNrIGZvciBwb3N0TWVzc2FnZSBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCIgaW4gXCIgKyB0b3RhbEFja1RpbWVvdXQgKyBcIm1zXCIpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDUwMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuZmluYWxseSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbC5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcVByb21pc2VzLnNwbGljZShyZXFQcm9taXNlcy5pbmRleE9mKHByb21pc2UsIDEpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZF9zZW5kTWVzc2FnZSh3aW4sIGRvbWFpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZDogdW5pcXVlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4od2luZG93KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb3N0cm9ib3RfbWVzc2FnZV9yZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6IGZpcmVBbmRGb3JnZXRcblx0ICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyZUFuZEZvcmdldCA/IHByb21pc2UucmVzb2x2ZSgpIDogcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZW5kIHJlcXVlc3QgbWVzc2FnZSBmYWlsZWQgZm9yIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIlxcblxcblwiICsgc3RyaW5naWZ5RXJyb3IoZXJyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmdW5jdGlvbiBzZXR1cF9zZXJpYWxpemVNZXNzYWdlKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaikge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplTWVzc2FnZShkZXN0aW5hdGlvbiwgZG9tYWluLCBvYmosIHtcblx0ICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0dXBfZGVzZXJpYWxpemVNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIHtcblx0ICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gY3JlYXRlUHJveHlXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93X1Byb3h5V2luZG93KHtcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZCxcblx0ICAgICAgICAgICAgICAgIHdpbjogd2luXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXR1cF90b1Byb3h5V2luZG93KHdpbikge1xuXHQgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93LnRvUHJveHlXaW5kb3cod2luLCB7XG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNldHVwKCkge1xuXHQgICAgICAgICAgICBpZiAoIWdsb2JhbF9nZXRHbG9iYWwoKS5pbml0aWFsaXplZCkge1xuXHQgICAgICAgICAgICAgICAgZ2xvYmFsX2dldEdsb2JhbCgpLmluaXRpYWxpemVkID0gITA7XG5cdCAgICAgICAgICAgICAgICBvbiA9IChfcmVmMyA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgICAgICB9KS5vbiwgc2VuZCA9IF9yZWYzLnNlbmQsIChnbG9iYWwgPSBnbG9iYWxfZ2V0R2xvYmFsKCkpLnJlY2VpdmVNZXNzYWdlID0gZ2xvYmFsLnJlY2VpdmVNZXNzYWdlIHx8IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWl2ZV9yZWNlaXZlTWVzc2FnZShtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICFmdW5jdGlvbihfcmVmNSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWY1Lm9uLCBzZW5kID0gX3JlZjUuc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZSgpLmdldE9yU2V0KFwicG9zdE1lc3NhZ2VMaXN0ZW5lclwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIGV2ZW50LCBoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbmRvdywgMCwgKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oZXZlbnQsIF9yZWY0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZjQub24sIHNlbmQgPSBfcmVmNC5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwgZXZlbnQuc291cmNlRWxlbWVudDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IGV2ZW50Lm9yaWdpbiB8fCBldmVudC5vcmlnaW5hbEV2ZW50ICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQub3JpZ2luO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibnVsbFwiID09PSBvcmlnaW4gJiYgKG9yaWdpbiA9IFwiZmlsZTovL1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcmlnaW4pIHRocm93IG5ldyBFcnJvcihcIlBvc3QgbWVzc2FnZSBkaWQgbm90IGhhdmUgb3JpZ2luIGRvbWFpblwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2Uoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGV2ZW50LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSh7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAhZnVuY3Rpb24oX3JlZjgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmOC5vbiwgc2VuZCA9IF9yZWY4LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoXCJidWlsdGluTGlzdGVuZXJzXCIpLmdldE9yU2V0KFwiaGVsbG9MaXN0ZW5lclwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IG9uKFwicG9zdHJvYm90X2hlbGxvXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogXCIqXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgKGZ1bmN0aW9uKF9yZWYzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSGVsbG9Qcm9taXNlKF9yZWYzLnNvdXJjZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogX3JlZjMub3JpZ2luXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJRDogZ2V0SW5zdGFuY2VJRCgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBnZXRBbmNlc3RvcigpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgJiYgc2F5SGVsbG8ocGFyZW50LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChmdW5jdGlvbihlcnIpIHt9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgX3JlZjMsIG9uLCBzZW5kLCBnbG9iYWw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdCAgICAgICAgICAgICFmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXNwb25zZUxpc3RlbmVycyA9IGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIik7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfcmVzcG9uc2VMaXN0ZW5lcnMka2UyID0gcmVzcG9uc2VMaXN0ZW5lcnMua2V5cygpOyBfaTIgPCBfcmVzcG9uc2VMaXN0ZW5lcnMka2UyLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IF9yZXNwb25zZUxpc3RlbmVycyRrZTJbX2kyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSByZXNwb25zZUxpc3RlbmVycy5nZXQoaGFzaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgJiYgKGxpc3RlbmVyLmNhbmNlbGxlZCA9ICEwKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXNwb25zZUxpc3RlbmVycy5kZWwoaGFzaCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgKGxpc3RlbmVyID0gZ2xvYmFsU3RvcmUoKS5nZXQoXCJwb3N0TWVzc2FnZUxpc3RlbmVyXCIpKSAmJiBsaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgdmFyIGxpc3RlbmVyO1xuXHQgICAgICAgICAgICBkZWxldGUgd2luZG93Ll9fcG9zdF9yb2JvdF8xMF8wXzQ2X187XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzcmNfdHlwZXNfVFlQRVNfMCA9ICEwO1xuXHQgICAgICAgIGZ1bmN0aW9uIGNsZWFuVXBXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9yZXF1ZXN0UHJvbWlzZXMkZ2V0MiA9IHdpbmRvd1N0b3JlKFwicmVxdWVzdFByb21pc2VzXCIpLmdldCh3aW4sIFtdKTsgX2kyIDwgX3JlcXVlc3RQcm9taXNlcyRnZXQyLmxlbmd0aDsgX2kyKyspIF9yZXF1ZXN0UHJvbWlzZXMkZ2V0MltfaTJdLnJlamVjdChuZXcgRXJyb3IoXCJXaW5kb3cgXCIgKyAoaXNXaW5kb3dDbG9zZWQod2luKSA/IFwiY2xvc2VkXCIgOiBcImNsZWFuZWQgdXBcIikgKyBcIiBiZWZvcmUgcmVzcG9uc2VcIikpLmNhdGNoKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzZXR1cCgpO1xuXHQgICAgfSBdKTtcblx0fSkpOyBcbn0gKHBvc3RSb2JvdCkpO1xuXG52YXIgcG9zdFJvYm90RXhwb3J0cyQxID0gcG9zdFJvYm90LmV4cG9ydHM7XG5cbi8qIEBmbG93ICovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG5cdC8vICRGbG93Rml4TWVcblx0bW9kdWxlLmV4cG9ydHMgPSBwb3N0Um9ib3RFeHBvcnRzJDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLWNvbW1vbmpzXG5cblx0Ly8gJEZsb3dGaXhNZVxuXHRtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLWNvbW1vbmpzIFxufSAocG9zdFJvYm90JDEpKTtcblxudmFyIHBvc3RSb2JvdEV4cG9ydHMgPSBwb3N0Um9ib3QkMS5leHBvcnRzO1xudmFyIGluZGV4ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHBvc3RSb2JvdEV4cG9ydHMpO1xuXG52YXIgaW5kZXgkMSA9IC8qI19fUFVSRV9fKi9fbWVyZ2VOYW1lc3BhY2VzKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRkZWZhdWx0OiBpbmRleFxufSwgW3Bvc3RSb2JvdEV4cG9ydHNdKTtcblxuZXhwb3J0IHsgaW5kZXgkMSBhcyBpIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/index-DD_kndDs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/sdk.js":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/sdk.js ***!
  \************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommunicationTypes: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   EthereumProvider: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   EthereumProviderConnectionTimeoutError: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   FamilyAccountsSdk: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   SdkStatus: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   SessionCreateResult: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   SessionStatus: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   UsernameType: () => (/* binding */ UsernameType),\n/* harmony export */   createFamilyAccountsClient: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   familyAccountsConnector: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   familyAccountsCustomActions: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   production: () => (/* reexport safe */ _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__.p)\n/* harmony export */ });\n/* harmony import */ var _family_accounts_connector_BEWV2sFJ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./family-accounts-connector-BEWV2sFJ.js */ \"(ssr)/./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/family-accounts-connector-BEWV2sFJ.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n\n\n\n\nvar UsernameType = /* @__PURE__ */ ((UsernameType2) => {\n  UsernameType2[\"EMAIL\"] = \"EMAIL\";\n  UsernameType2[\"PHONE\"] = \"PHONE\";\n  return UsernameType2;\n})(UsernameType || {});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZmFtaWx5QDAuMS4zX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfdmllbUAyLjM3LjZfYnVmZmVydXRpbEA0LjAuOV90X2Y1MzMyMzkxYTY3YTZmYTRlYTg0YzYxMTVjYWRmZTk3L25vZGVfbW9kdWxlcy9mYW1pbHkvbGliL3Nkay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUE4VjtBQUNoVjtBQUNFOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9COztBQUVHIiwic291cmNlcyI6WyIvVXNlcnMvZWxlbWVuL3NvbGlkaXR5L3NvbGlkaXR5LW5leHQtanMtdGVtcGxhdGUvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL2ZhbWlseUAwLjEuM19yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3ZpZW1AMi4zNy42X2J1ZmZlcnV0aWxANC4wLjlfdF9mNTMzMjM5MWE2N2E2ZmE0ZWE4NGM2MTE1Y2FkZmU5Ny9ub2RlX21vZHVsZXMvZmFtaWx5L2xpYi9zZGsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQyBhcyBDb21tdW5pY2F0aW9uVHlwZXMsIGQgYXMgRXRoZXJldW1Qcm92aWRlciwgRSBhcyBFdGhlcmV1bVByb3ZpZGVyQ29ubmVjdGlvblRpbWVvdXRFcnJvciwgRiBhcyBGYW1pbHlBY2NvdW50c1NkaywgYSBhcyBTZGtTdGF0dXMsIGIgYXMgU2Vzc2lvbkNyZWF0ZVJlc3VsdCwgUyBhcyBTZXNzaW9uU3RhdHVzLCBjIGFzIGNyZWF0ZUZhbWlseUFjY291bnRzQ2xpZW50LCBlIGFzIGZhbWlseUFjY291bnRzQ29ubmVjdG9yLCBmIGFzIGZhbWlseUFjY291bnRzQ3VzdG9tQWN0aW9ucywgcCBhcyBwcm9kdWN0aW9uIH0gZnJvbSAnLi9mYW1pbHktYWNjb3VudHMtY29ubmVjdG9yLUJFV1Yyc0ZKLmpzJztcbmltcG9ydCAndmllbSc7XG5pbXBvcnQgJ2V2ZW50cyc7XG5cbnZhciBVc2VybmFtZVR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChVc2VybmFtZVR5cGUyKSA9PiB7XG4gIFVzZXJuYW1lVHlwZTJbXCJFTUFJTFwiXSA9IFwiRU1BSUxcIjtcbiAgVXNlcm5hbWVUeXBlMltcIlBIT05FXCJdID0gXCJQSE9ORVwiO1xuICByZXR1cm4gVXNlcm5hbWVUeXBlMjtcbn0pKFVzZXJuYW1lVHlwZSB8fCB7fSk7XG5cbmV4cG9ydCB7IFVzZXJuYW1lVHlwZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/sdk.js\n");

/***/ })

};
;