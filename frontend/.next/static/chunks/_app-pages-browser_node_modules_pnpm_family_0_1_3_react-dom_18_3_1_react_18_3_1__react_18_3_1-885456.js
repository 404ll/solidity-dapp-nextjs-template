"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_pnpm_family_0_1_3_react-dom_18_3_1_react_18_3_1__react_18_3_1-885456"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/index-DD_kndDs.js":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/index-DD_kndDs.js ***!
  \***********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ index$1)\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js\")[\"Buffer\"];\nfunction _mergeNamespaces(n, m) {\n\tm.forEach(function (e) {\n\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\treturn Object.freeze(n);\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar postRobot$1 = {exports: {}};\n\nvar postRobot = {exports: {}};\n\n(function (module, exports) {\n\t!function(root, factory) {\n\t    module.exports = factory() ;\n\t}(\"undefined\" != typeof self ? self : commonjsGlobal, (function() {\n\t    return function(modules) {\n\t        var installedModules = {};\n\t        function __nested_webpack_require_1042__(moduleId) {\n\t            if (installedModules[moduleId]) return installedModules[moduleId].exports;\n\t            var module = installedModules[moduleId] = {\n\t                i: moduleId,\n\t                l: !1,\n\t                exports: {}\n\t            };\n\t            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1042__);\n\t            module.l = !0;\n\t            return module.exports;\n\t        }\n\t        __nested_webpack_require_1042__.m = modules;\n\t        __nested_webpack_require_1042__.c = installedModules;\n\t        __nested_webpack_require_1042__.d = function(exports, name, getter) {\n\t            __nested_webpack_require_1042__.o(exports, name) || Object.defineProperty(exports, name, {\n\t                enumerable: !0,\n\t                get: getter\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.r = function(exports) {\n\t            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n\t                value: \"Module\"\n\t            });\n\t            Object.defineProperty(exports, \"__esModule\", {\n\t                value: !0\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.t = function(value, mode) {\n\t            1 & mode && (value = __nested_webpack_require_1042__(value));\n\t            if (8 & mode) return value;\n\t            if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value;\n\t            var ns = Object.create(null);\n\t            __nested_webpack_require_1042__.r(ns);\n\t            Object.defineProperty(ns, \"default\", {\n\t                enumerable: !0,\n\t                value: value\n\t            });\n\t            if (2 & mode && \"string\" != typeof value) for (var key in value) __nested_webpack_require_1042__.d(ns, key, function(key) {\n\t                return value[key];\n\t            }.bind(null, key));\n\t            return ns;\n\t        };\n\t        __nested_webpack_require_1042__.n = function(module) {\n\t            var getter = module && module.__esModule ? function() {\n\t                return module.default;\n\t            } : function() {\n\t                return module;\n\t            };\n\t            __nested_webpack_require_1042__.d(getter, \"a\", getter);\n\t            return getter;\n\t        };\n\t        __nested_webpack_require_1042__.o = function(object, property) {\n\t            return {}.hasOwnProperty.call(object, property);\n\t        };\n\t        __nested_webpack_require_1042__.p = \"\";\n\t        return __nested_webpack_require_1042__(__nested_webpack_require_1042__.s = 0);\n\t    }([ function(module, __nested_webpack_exports__, __nested_webpack_require_3506__) {\n\t        __nested_webpack_require_3506__.r(__nested_webpack_exports__);\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"Promise\", (function() {\n\t            return promise_ZalgoPromise;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"TYPES\", (function() {\n\t            return src_types_TYPES_0;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"ProxyWindow\", (function() {\n\t            return window_ProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"setup\", (function() {\n\t            return setup;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"destroy\", (function() {\n\t            return destroy;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"serializeMessage\", (function() {\n\t            return setup_serializeMessage;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"deserializeMessage\", (function() {\n\t            return setup_deserializeMessage;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"createProxyWindow\", (function() {\n\t            return createProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"toProxyWindow\", (function() {\n\t            return setup_toProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"on\", (function() {\n\t            return on_on;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"once\", (function() {\n\t            return on_once;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"send\", (function() {\n\t            return send_send;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"markWindowKnown\", (function() {\n\t            return markWindowKnown;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"cleanUpWindow\", (function() {\n\t            return cleanUpWindow;\n\t        }));\n\t        __nested_webpack_require_3506__.d(__nested_webpack_exports__, \"bridge\", (function() {}));\n\t        function isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        var IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\t        function getActualProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return win.location.protocol;\n\t        }\n\t        function getProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            if (win.mockDomain) {\n\t                var protocol = win.mockDomain.split(\"//\")[0];\n\t                if (protocol) return protocol;\n\t            }\n\t            return getActualProtocol(win);\n\t        }\n\t        function isAboutProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return \"about:\" === getProtocol(win);\n\t        }\n\t        function getParent(win) {\n\t            void 0 === win && (win = window);\n\t            if (win) try {\n\t                if (win.parent && win.parent !== win) return win.parent;\n\t            } catch (err) {}\n\t        }\n\t        function getOpener(win) {\n\t            void 0 === win && (win = window);\n\t            if (win && !getParent(win)) try {\n\t                return win.opener;\n\t            } catch (err) {}\n\t        }\n\t        function canReadFromWindow(win) {\n\t            try {\n\t                return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function getActualDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var location = win.location;\n\t            if (!location) throw new Error(\"Can not read window location\");\n\t            var protocol = getActualProtocol(win);\n\t            if (!protocol) throw new Error(\"Can not read window protocol\");\n\t            if (\"file:\" === protocol) return \"file://\";\n\t            if (\"about:\" === protocol) {\n\t                var parent = getParent(win);\n\t                return parent && canReadFromWindow() ? getActualDomain(parent) : \"about://\";\n\t            }\n\t            var host = location.host;\n\t            if (!host) throw new Error(\"Can not read window host\");\n\t            return protocol + \"//\" + host;\n\t        }\n\t        function getDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var domain = getActualDomain(win);\n\t            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(\"mock:\") ? win.mockDomain : domain;\n\t        }\n\t        function isSameDomain(win) {\n\t            if (!function(win) {\n\t                try {\n\t                    if (win === window) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    var desc = Object.getOwnPropertyDescriptor(win, \"location\");\n\t                    if (desc && !1 === desc.enumerable) return !1;\n\t                } catch (err) {}\n\t                try {\n\t                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (function(win) {\n\t                        void 0 === win && (win = window);\n\t                        return \"mock:\" === getProtocol(win);\n\t                    }(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (getActualDomain(win) === getActualDomain(window)) return !0;\n\t                } catch (err) {}\n\t                return !1;\n\t            }(win)) return !1;\n\t            try {\n\t                if (win === window) return !0;\n\t                if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                if (getDomain(window) === getDomain(win)) return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function assertSameDomain(win) {\n\t            if (!isSameDomain(win)) throw new Error(\"Expected window to be same domain\");\n\t            return win;\n\t        }\n\t        function isAncestorParent(parent, child) {\n\t            if (!parent || !child) return !1;\n\t            var childParent = getParent(child);\n\t            return childParent ? childParent === parent : -1 !== function(win) {\n\t                var result = [];\n\t                try {\n\t                    for (;win.parent !== win; ) {\n\t                        result.push(win.parent);\n\t                        win = win.parent;\n\t                    }\n\t                } catch (err) {}\n\t                return result;\n\t            }(child).indexOf(parent);\n\t        }\n\t        function getFrames(win) {\n\t            var result = [];\n\t            var frames;\n\t            try {\n\t                frames = win.frames;\n\t            } catch (err) {\n\t                frames = win;\n\t            }\n\t            var len;\n\t            try {\n\t                len = frames.length;\n\t            } catch (err) {}\n\t            if (0 === len) return result;\n\t            if (len) {\n\t                for (var i = 0; i < len; i++) {\n\t                    var frame = void 0;\n\t                    try {\n\t                        frame = frames[i];\n\t                    } catch (err) {\n\t                        continue;\n\t                    }\n\t                    result.push(frame);\n\t                }\n\t                return result;\n\t            }\n\t            for (var _i = 0; _i < 100; _i++) {\n\t                var _frame = void 0;\n\t                try {\n\t                    _frame = frames[_i];\n\t                } catch (err) {\n\t                    return result;\n\t                }\n\t                if (!_frame) return result;\n\t                result.push(_frame);\n\t            }\n\t            return result;\n\t        }\n\t        var iframeWindows = [];\n\t        var iframeFrames = [];\n\t        function isWindowClosed(win, allowMock) {\n\t            void 0 === allowMock && (allowMock = !0);\n\t            try {\n\t                if (win === window) return !1;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (!win) return !0;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (win.closed) return !0;\n\t            } catch (err) {\n\t                return !err || err.message !== IE_WIN_ACCESS_ERROR;\n\t            }\n\t            if (allowMock && isSameDomain(win)) try {\n\t                if (win.mockclosed) return !0;\n\t            } catch (err) {}\n\t            try {\n\t                if (!win.parent || !win.top) return !0;\n\t            } catch (err) {}\n\t            var iframeIndex = function(collection, item) {\n\t                for (var i = 0; i < collection.length; i++) try {\n\t                    if (collection[i] === item) return i;\n\t                } catch (err) {}\n\t                return -1;\n\t            }(iframeWindows, win);\n\t            if (-1 !== iframeIndex) {\n\t                var frame = iframeFrames[iframeIndex];\n\t                if (frame && function(frame) {\n\t                    if (!frame.contentWindow) return !0;\n\t                    if (!frame.parentNode) return !0;\n\t                    var doc = frame.ownerDocument;\n\t                    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n\t                        var parent = frame;\n\t                        for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;\n\t                        if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;\n\t                    }\n\t                    return !1;\n\t                }(frame)) return !0;\n\t            }\n\t            return !1;\n\t        }\n\t        function getAncestor(win) {\n\t            void 0 === win && (win = window);\n\t            return getOpener(win = win || window) || getParent(win) || void 0;\n\t        }\n\t        function matchDomain(pattern, origin) {\n\t            if (\"string\" == typeof pattern) {\n\t                if (\"string\" == typeof origin) return \"*\" === pattern || origin === pattern;\n\t                if (isRegex(origin)) return !1;\n\t                if (Array.isArray(origin)) return !1;\n\t            }\n\t            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {\n\t                return matchDomain(subpattern, origin);\n\t            })));\n\t        }\n\t        function isWindow(obj) {\n\t            try {\n\t                if (obj === window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (\"[object Window]\" === {}.toString.call(obj)) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (window.Window && obj instanceof window.Window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.self === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.parent === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && obj.top === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;\n\t            }\n\t            try {\n\t                if (obj && \"__unlikely_value__\" === obj.__cross_domain_utils_window_check__) return !1;\n\t            } catch (err) {\n\t                return !0;\n\t            }\n\t            try {\n\t                if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) return !0;\n\t            } catch (err) {}\n\t            return !1;\n\t        }\n\t        function getFrameForWindow(win) {\n\t            if (isSameDomain(win)) return assertSameDomain(win).frameElement;\n\t            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll(\"iframe\"); _i21 < _document$querySelect2.length; _i21++) {\n\t                var frame = _document$querySelect2[_i21];\n\t                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;\n\t            }\n\t        }\n\t        function closeWindow(win) {\n\t            if (function(win) {\n\t                void 0 === win && (win = window);\n\t                return Boolean(getParent(win));\n\t            }(win)) {\n\t                var frame = getFrameForWindow(win);\n\t                if (frame && frame.parentElement) {\n\t                    frame.parentElement.removeChild(frame);\n\t                    return;\n\t                }\n\t            }\n\t            try {\n\t                win.close();\n\t            } catch (err) {}\n\t        }\n\t        function utils_isPromise(item) {\n\t            try {\n\t                if (!item) return !1;\n\t                if (\"undefined\" != typeof Promise && item instanceof Promise) return !0;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.Window && item instanceof window.Window) return !1;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.constructor && item instanceof window.constructor) return !1;\n\t                var _toString = {}.toString;\n\t                if (_toString) {\n\t                    var name = _toString.call(item);\n\t                    if (\"[object Window]\" === name || \"[object global]\" === name || \"[object DOMWindow]\" === name) return !1;\n\t                }\n\t                if (\"function\" == typeof item.then) return !0;\n\t            } catch (err) {\n\t                return !1;\n\t            }\n\t            return !1;\n\t        }\n\t        var dispatchedErrors = [];\n\t        var possiblyUnhandledPromiseHandlers = [];\n\t        var activeCount = 0;\n\t        var flushPromise;\n\t        function flushActive() {\n\t            if (!activeCount && flushPromise) {\n\t                var promise = flushPromise;\n\t                flushPromise = null;\n\t                promise.resolve();\n\t            }\n\t        }\n\t        function startActive() {\n\t            activeCount += 1;\n\t        }\n\t        function endActive() {\n\t            activeCount -= 1;\n\t            flushActive();\n\t        }\n\t        var promise_ZalgoPromise = function() {\n\t            function ZalgoPromise(handler) {\n\t                var _this = this;\n\t                this.resolved = void 0;\n\t                this.rejected = void 0;\n\t                this.errorHandled = void 0;\n\t                this.value = void 0;\n\t                this.error = void 0;\n\t                this.handlers = void 0;\n\t                this.dispatching = void 0;\n\t                this.stack = void 0;\n\t                this.resolved = !1;\n\t                this.rejected = !1;\n\t                this.errorHandled = !1;\n\t                this.handlers = [];\n\t                if (handler) {\n\t                    var _result;\n\t                    var _error;\n\t                    var resolved = !1;\n\t                    var rejected = !1;\n\t                    var isAsync = !1;\n\t                    startActive();\n\t                    try {\n\t                        handler((function(res) {\n\t                            if (isAsync) _this.resolve(res); else {\n\t                                resolved = !0;\n\t                                _result = res;\n\t                            }\n\t                        }), (function(err) {\n\t                            if (isAsync) _this.reject(err); else {\n\t                                rejected = !0;\n\t                                _error = err;\n\t                            }\n\t                        }));\n\t                    } catch (err) {\n\t                        endActive();\n\t                        this.reject(err);\n\t                        return;\n\t                    }\n\t                    endActive();\n\t                    isAsync = !0;\n\t                    resolved ? this.resolve(_result) : rejected && this.reject(_error);\n\t                }\n\t            }\n\t            var _proto = ZalgoPromise.prototype;\n\t            _proto.resolve = function(result) {\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(result)) throw new Error(\"Can not resolve promise with another promise\");\n\t                this.resolved = !0;\n\t                this.value = result;\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.reject = function(error) {\n\t                var _this2 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(error)) throw new Error(\"Can not reject promise with another promise\");\n\t                if (!error) {\n\t                    var _err = error && \"function\" == typeof error.toString ? error.toString() : {}.toString.call(error);\n\t                    error = new Error(\"Expected reject to be called with Error, got \" + _err);\n\t                }\n\t                this.rejected = !0;\n\t                this.error = error;\n\t                this.errorHandled || setTimeout((function() {\n\t                    _this2.errorHandled || function(err, promise) {\n\t                        if (-1 === dispatchedErrors.indexOf(err)) {\n\t                            dispatchedErrors.push(err);\n\t                            setTimeout((function() {\n\t                                throw err;\n\t                            }), 1);\n\t                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);\n\t                        }\n\t                    }(error, _this2);\n\t                }), 1);\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.asyncReject = function(error) {\n\t                this.errorHandled = !0;\n\t                this.reject(error);\n\t                return this;\n\t            };\n\t            _proto.dispatch = function() {\n\t                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;\n\t                if (!this.dispatching && (resolved || rejected)) {\n\t                    this.dispatching = !0;\n\t                    startActive();\n\t                    var chain = function(firstPromise, secondPromise) {\n\t                        return firstPromise.then((function(res) {\n\t                            secondPromise.resolve(res);\n\t                        }), (function(err) {\n\t                            secondPromise.reject(err);\n\t                        }));\n\t                    };\n\t                    for (var i = 0; i < handlers.length; i++) {\n\t                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;\n\t                        var _result2 = void 0;\n\t                        if (resolved) try {\n\t                            _result2 = onSuccess ? onSuccess(this.value) : this.value;\n\t                        } catch (err) {\n\t                            promise.reject(err);\n\t                            continue;\n\t                        } else if (rejected) {\n\t                            if (!onError) {\n\t                                promise.reject(this.error);\n\t                                continue;\n\t                            }\n\t                            try {\n\t                                _result2 = onError(this.error);\n\t                            } catch (err) {\n\t                                promise.reject(err);\n\t                                continue;\n\t                            }\n\t                        }\n\t                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {\n\t                            var promiseResult = _result2;\n\t                            promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);\n\t                            promiseResult.errorHandled = !0;\n\t                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);\n\t                    }\n\t                    handlers.length = 0;\n\t                    this.dispatching = !1;\n\t                    endActive();\n\t                }\n\t            };\n\t            _proto.then = function(onSuccess, onError) {\n\t                if (onSuccess && \"function\" != typeof onSuccess && !onSuccess.call) throw new Error(\"Promise.then expected a function for success handler\");\n\t                if (onError && \"function\" != typeof onError && !onError.call) throw new Error(\"Promise.then expected a function for error handler\");\n\t                var promise = new ZalgoPromise;\n\t                this.handlers.push({\n\t                    promise: promise,\n\t                    onSuccess: onSuccess,\n\t                    onError: onError\n\t                });\n\t                this.errorHandled = !0;\n\t                this.dispatch();\n\t                return promise;\n\t            };\n\t            _proto.catch = function(onError) {\n\t                return this.then(void 0, onError);\n\t            };\n\t            _proto.finally = function(onFinally) {\n\t                if (onFinally && \"function\" != typeof onFinally && !onFinally.call) throw new Error(\"Promise.finally expected a function\");\n\t                return this.then((function(result) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        return result;\n\t                    }));\n\t                }), (function(err) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        throw err;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.timeout = function(time, err) {\n\t                var _this3 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                var timeout = setTimeout((function() {\n\t                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error(\"Promise timed out after \" + time + \"ms\"));\n\t                }), time);\n\t                return this.then((function(result) {\n\t                    clearTimeout(timeout);\n\t                    return result;\n\t                }));\n\t            };\n\t            _proto.toPromise = function() {\n\t                if (\"undefined\" == typeof Promise) throw new TypeError(\"Could not find Promise\");\n\t                return Promise.resolve(this);\n\t            };\n\t            _proto.lazy = function() {\n\t                this.errorHandled = !0;\n\t                return this;\n\t            };\n\t            ZalgoPromise.resolve = function(value) {\n\t                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {\n\t                    return value.then(resolve, reject);\n\t                })) : (new ZalgoPromise).resolve(value);\n\t            };\n\t            ZalgoPromise.reject = function(error) {\n\t                return (new ZalgoPromise).reject(error);\n\t            };\n\t            ZalgoPromise.asyncReject = function(error) {\n\t                return (new ZalgoPromise).asyncReject(error);\n\t            };\n\t            ZalgoPromise.all = function(promises) {\n\t                var promise = new ZalgoPromise;\n\t                var count = promises.length;\n\t                var results = [].slice();\n\t                if (!count) {\n\t                    promise.resolve(results);\n\t                    return promise;\n\t                }\n\t                var chain = function(i, firstPromise, secondPromise) {\n\t                    return firstPromise.then((function(res) {\n\t                        results[i] = res;\n\t                        0 == (count -= 1) && promise.resolve(results);\n\t                    }), (function(err) {\n\t                        secondPromise.reject(err);\n\t                    }));\n\t                };\n\t                for (var i = 0; i < promises.length; i++) {\n\t                    var prom = promises[i];\n\t                    if (prom instanceof ZalgoPromise) {\n\t                        if (prom.resolved) {\n\t                            results[i] = prom.value;\n\t                            count -= 1;\n\t                            continue;\n\t                        }\n\t                    } else if (!utils_isPromise(prom)) {\n\t                        results[i] = prom;\n\t                        count -= 1;\n\t                        continue;\n\t                    }\n\t                    chain(i, ZalgoPromise.resolve(prom), promise);\n\t                }\n\t                0 === count && promise.resolve(results);\n\t                return promise;\n\t            };\n\t            ZalgoPromise.hash = function(promises) {\n\t                var result = {};\n\t                var awaitPromises = [];\n\t                var _loop = function(key) {\n\t                    if (promises.hasOwnProperty(key)) {\n\t                        var value = promises[key];\n\t                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {\n\t                            result[key] = res;\n\t                        }))) : result[key] = value;\n\t                    }\n\t                };\n\t                for (var key in promises) _loop(key);\n\t                return ZalgoPromise.all(awaitPromises).then((function() {\n\t                    return result;\n\t                }));\n\t            };\n\t            ZalgoPromise.map = function(items, method) {\n\t                return ZalgoPromise.all(items.map(method));\n\t            };\n\t            ZalgoPromise.onPossiblyUnhandledException = function(handler) {\n\t                return function(handler) {\n\t                    possiblyUnhandledPromiseHandlers.push(handler);\n\t                    return {\n\t                        cancel: function() {\n\t                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n\t                        }\n\t                    };\n\t                }(handler);\n\t            };\n\t            ZalgoPromise.try = function(method, context, args) {\n\t                if (method && \"function\" != typeof method && !method.call) throw new Error(\"Promise.try expected a function\");\n\t                var result;\n\t                startActive();\n\t                try {\n\t                    result = method.apply(context, args || []);\n\t                } catch (err) {\n\t                    endActive();\n\t                    return ZalgoPromise.reject(err);\n\t                }\n\t                endActive();\n\t                return ZalgoPromise.resolve(result);\n\t            };\n\t            ZalgoPromise.delay = function(_delay) {\n\t                return new ZalgoPromise((function(resolve) {\n\t                    setTimeout(resolve, _delay);\n\t                }));\n\t            };\n\t            ZalgoPromise.isPromise = function(value) {\n\t                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);\n\t            };\n\t            ZalgoPromise.flush = function() {\n\t                return function(Zalgo) {\n\t                    var promise = flushPromise = flushPromise || new Zalgo;\n\t                    flushActive();\n\t                    return promise;\n\t                }(ZalgoPromise);\n\t            };\n\t            return ZalgoPromise;\n\t        }();\n\t        function util_safeIndexOf(collection, item) {\n\t            for (var i = 0; i < collection.length; i++) try {\n\t                if (collection[i] === item) return i;\n\t            } catch (err) {}\n\t            return -1;\n\t        }\n\t        var weakmap_CrossDomainSafeWeakMap = function() {\n\t            function CrossDomainSafeWeakMap() {\n\t                this.name = void 0;\n\t                this.weakmap = void 0;\n\t                this.keys = void 0;\n\t                this.values = void 0;\n\t                this.name = \"__weakmap_\" + (1e9 * Math.random() >>> 0) + \"__\";\n\t                if (function() {\n\t                    if (\"undefined\" == typeof WeakMap) return !1;\n\t                    if (void 0 === Object.freeze) return !1;\n\t                    try {\n\t                        var testWeakMap = new WeakMap;\n\t                        var testKey = {};\n\t                        Object.freeze(testKey);\n\t                        testWeakMap.set(testKey, \"__testvalue__\");\n\t                        return \"__testvalue__\" === testWeakMap.get(testKey);\n\t                    } catch (err) {\n\t                        return !1;\n\t                    }\n\t                }()) try {\n\t                    this.weakmap = new WeakMap;\n\t                } catch (err) {}\n\t                this.keys = [];\n\t                this.values = [];\n\t            }\n\t            var _proto = CrossDomainSafeWeakMap.prototype;\n\t            _proto._cleanupClosedWindows = function() {\n\t                var weakmap = this.weakmap;\n\t                var keys = this.keys;\n\t                for (var i = 0; i < keys.length; i++) {\n\t                    var value = keys[i];\n\t                    if (isWindow(value) && isWindowClosed(value)) {\n\t                        if (weakmap) try {\n\t                            weakmap.delete(value);\n\t                        } catch (err) {}\n\t                        keys.splice(i, 1);\n\t                        this.values.splice(i, 1);\n\t                        i -= 1;\n\t                    }\n\t                }\n\t            };\n\t            _proto.isSafeToReadWrite = function(key) {\n\t                return !isWindow(key);\n\t            };\n\t            _proto.set = function(key, value) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.set(key, value);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var name = this.name;\n\t                    var entry = key[name];\n\t                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {\n\t                        value: [ key, value ],\n\t                        writable: !0\n\t                    });\n\t                    return;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var values = this.values;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 === index) {\n\t                    keys.push(key);\n\t                    values.push(value);\n\t                } else values[index] = value;\n\t            };\n\t            _proto.get = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return weakmap.get(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return entry && entry[0] === key ? entry[1] : void 0;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var index = util_safeIndexOf(this.keys, key);\n\t                if (-1 !== index) return this.values[index];\n\t            };\n\t            _proto.delete = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.delete(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 !== index) {\n\t                    keys.splice(index, 1);\n\t                    this.values.splice(index, 1);\n\t                }\n\t            };\n\t            _proto.has = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return !0;\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return !(!entry || entry[0] !== key);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                return -1 !== util_safeIndexOf(this.keys, key);\n\t            };\n\t            _proto.getOrSet = function(key, getter) {\n\t                if (this.has(key)) return this.get(key);\n\t                var value = getter();\n\t                this.set(key, value);\n\t                return value;\n\t            };\n\t            return CrossDomainSafeWeakMap;\n\t        }();\n\t        function getFunctionName(fn) {\n\t            return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n\t        }\n\t        function setFunctionName(fn, name) {\n\t            try {\n\t                delete fn.name;\n\t                fn.name = name;\n\t            } catch (err) {}\n\t            fn.__name__ = fn.displayName = name;\n\t            return fn;\n\t        }\n\t        function uniqueID() {\n\t            var chars = \"0123456789abcdef\";\n\t            return \"uid_\" + \"xxxxxxxxxx\".replace(/./g, (function() {\n\t                return chars.charAt(Math.floor(Math.random() * chars.length));\n\t            })) + \"_\" + function(str) {\n\t                if (\"function\" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {\n\t                    return String.fromCharCode(parseInt(p1, 16));\n\t                }))).replace(/[=]/g, \"\");\n\t                if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n\t                throw new Error(\"Can not find window.btoa or Buffer\");\n\t            }((new Date).toISOString().slice(11, 19).replace(\"T\", \".\")).replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n\t        }\n\t        var objectIDs;\n\t        function serializeArgs(args) {\n\t            try {\n\t                return JSON.stringify([].slice.call(args), (function(subkey, val) {\n\t                    return \"function\" == typeof val ? \"memoize[\" + function(obj) {\n\t                        objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;\n\t                        if (null == obj || \"object\" != typeof obj && \"function\" != typeof obj) throw new Error(\"Invalid object\");\n\t                        var uid = objectIDs.get(obj);\n\t                        if (!uid) {\n\t                            uid = typeof obj + \":\" + uniqueID();\n\t                            objectIDs.set(obj, uid);\n\t                        }\n\t                        return uid;\n\t                    }(val) + \"]\" : \"undefined\" != typeof window && val instanceof window.Element || null !== val && \"object\" == typeof val && 1 === val.nodeType && \"object\" == typeof val.style && \"object\" == typeof val.ownerDocument ? {} : val;\n\t                }));\n\t            } catch (err) {\n\t                throw new Error(\"Arguments not serializable -- can not be used to memoize\");\n\t            }\n\t        }\n\t        function getEmptyObject() {\n\t            return {};\n\t        }\n\t        var memoizeGlobalIndex = 0;\n\t        var memoizeGlobalIndexValidFrom = 0;\n\t        function memoize(method, options) {\n\t            void 0 === options && (options = {});\n\t            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;\n\t            var simpleCache;\n\t            var thisCache;\n\t            var memoizeIndex = memoizeGlobalIndex;\n\t            memoizeGlobalIndex += 1;\n\t            var memoizedFunction = function() {\n\t                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\t                if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n\t                    simpleCache = null;\n\t                    thisCache = null;\n\t                    memoizeIndex = memoizeGlobalIndex;\n\t                    memoizeGlobalIndex += 1;\n\t                }\n\t                var cache;\n\t                cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};\n\t                var cacheKey;\n\t                try {\n\t                    cacheKey = serializeArgs(args);\n\t                } catch (_unused) {\n\t                    return method.apply(this, arguments);\n\t                }\n\t                var cacheResult = cache[cacheKey];\n\t                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n\t                    delete cache[cacheKey];\n\t                    cacheResult = null;\n\t                }\n\t                if (cacheResult) return cacheResult.value;\n\t                var time = Date.now();\n\t                var value = method.apply(this, arguments);\n\t                cache[cacheKey] = {\n\t                    time: time,\n\t                    value: value\n\t                };\n\t                return value;\n\t            };\n\t            memoizedFunction.reset = function() {\n\t                simpleCache = null;\n\t                thisCache = null;\n\t            };\n\t            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + \"::memoized\");\n\t        }\n\t        memoize.clear = function() {\n\t            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n\t        };\n\t        function memoizePromise(method) {\n\t            var cache = {};\n\t            function memoizedPromiseFunction() {\n\t                var _arguments = arguments, _this = this;\n\t                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n\t                var key = serializeArgs(args);\n\t                if (cache.hasOwnProperty(key)) return cache[key];\n\t                cache[key] = promise_ZalgoPromise.try((function() {\n\t                    return method.apply(_this, _arguments);\n\t                })).finally((function() {\n\t                    delete cache[key];\n\t                }));\n\t                return cache[key];\n\t            }\n\t            memoizedPromiseFunction.reset = function() {\n\t                cache = {};\n\t            };\n\t            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + \"::promiseMemoized\");\n\t        }\n\t        function src_util_noop() {}\n\t        function stringifyError(err, level) {\n\t            void 0 === level && (level = 1);\n\t            if (level >= 3) return \"stringifyError stack overflow\";\n\t            try {\n\t                if (!err) return \"<unknown error: \" + {}.toString.call(err) + \">\";\n\t                if (\"string\" == typeof err) return err;\n\t                if (err instanceof Error) {\n\t                    var stack = err && err.stack;\n\t                    var message = err && err.message;\n\t                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + \"\\n\" + stack;\n\t                    if (stack) return stack;\n\t                    if (message) return message;\n\t                }\n\t                return err && err.toString && \"function\" == typeof err.toString ? err.toString() : {}.toString.call(err);\n\t            } catch (newErr) {\n\t                return \"Error while stringifying error: \" + stringifyError(newErr, level + 1);\n\t            }\n\t        }\n\t        function stringify(item) {\n\t            return \"string\" == typeof item ? item : item && item.toString && \"function\" == typeof item.toString ? item.toString() : {}.toString.call(item);\n\t        }\n\t        memoize((function(obj) {\n\t            if (Object.values) return Object.values(obj);\n\t            var result = [];\n\t            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);\n\t            return result;\n\t        }));\n\t        function util_isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        function util_getOrSet(obj, key, getter) {\n\t            if (obj.hasOwnProperty(key)) return obj[key];\n\t            var val = getter();\n\t            obj[key] = val;\n\t            return val;\n\t        }\n\t        function getBody() {\n\t            var body = document.body;\n\t            if (!body) throw new Error(\"Body element not found\");\n\t            return body;\n\t        }\n\t        function isDocumentReady() {\n\t            return Boolean(document.body) && \"complete\" === document.readyState;\n\t        }\n\t        function isDocumentInteractive() {\n\t            return Boolean(document.body) && \"interactive\" === document.readyState;\n\t        }\n\t        memoize((function() {\n\t            return new promise_ZalgoPromise((function(resolve) {\n\t                if (isDocumentReady() || isDocumentInteractive()) return resolve();\n\t                var interval = setInterval((function() {\n\t                    if (isDocumentReady() || isDocumentInteractive()) {\n\t                        clearInterval(interval);\n\t                        return resolve();\n\t                    }\n\t                }), 10);\n\t            }));\n\t        }));\n\t        var currentScript = \"undefined\" != typeof document ? document.currentScript : null;\n\t        var getCurrentScript = memoize((function() {\n\t            if (currentScript) return currentScript;\n\t            if (currentScript = function() {\n\t                try {\n\t                    var stack = function() {\n\t                        try {\n\t                            throw new Error(\"_\");\n\t                        } catch (err) {\n\t                            return err.stack || \"\";\n\t                        }\n\t                    }();\n\t                    var stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n\t                    var scriptLocation = stackDetails && stackDetails[1];\n\t                    if (!scriptLocation) return;\n\t                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName(\"script\")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {\n\t                        var script = _Array$prototype$slic2[_i22];\n\t                        if (script.src && script.src === scriptLocation) return script;\n\t                    }\n\t                } catch (err) {}\n\t            }()) return currentScript;\n\t            throw new Error(\"Can not determine current script\");\n\t        }));\n\t        var currentUID = uniqueID();\n\t        memoize((function() {\n\t            var script;\n\t            try {\n\t                script = getCurrentScript();\n\t            } catch (err) {\n\t                return currentUID;\n\t            }\n\t            var uid = script.getAttribute(\"data-uid\");\n\t            if (uid && \"string\" == typeof uid) return uid;\n\t            if ((uid = script.getAttribute(\"data-uid-auto\")) && \"string\" == typeof uid) return uid;\n\t            if (script.src) {\n\t                var hashedString = function(str) {\n\t                    var hash = \"\";\n\t                    for (var i = 0; i < str.length; i++) {\n\t                        var total = str[i].charCodeAt(0) * i;\n\t                        str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));\n\t                        hash += String.fromCharCode(97 + Math.abs(total) % 26);\n\t                    }\n\t                    return hash;\n\t                }(JSON.stringify({\n\t                    src: script.src,\n\t                    dataset: script.dataset\n\t                }));\n\t                uid = \"uid_\" + hashedString.slice(hashedString.length - 30);\n\t            } else uid = uniqueID();\n\t            script.setAttribute(\"data-uid-auto\", uid);\n\t            return uid;\n\t        }));\n\t        function global_getGlobal(win) {\n\t            void 0 === win && (win = window);\n\t            var globalKey = \"__post_robot_10_0_46__\";\n\t            return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};\n\t        }\n\t        var getObj = function() {\n\t            return {};\n\t        };\n\t        function globalStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return util_getOrSet(global_getGlobal(), key, (function() {\n\t                var store = defStore();\n\t                return {\n\t                    has: function(storeKey) {\n\t                        return store.hasOwnProperty(storeKey);\n\t                    },\n\t                    get: function(storeKey, defVal) {\n\t                        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n\t                    },\n\t                    set: function(storeKey, val) {\n\t                        store[storeKey] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(storeKey) {\n\t                        delete store[storeKey];\n\t                    },\n\t                    getOrSet: function(storeKey, getter) {\n\t                        return util_getOrSet(store, storeKey, getter);\n\t                    },\n\t                    reset: function() {\n\t                        store = defStore();\n\t                    },\n\t                    keys: function() {\n\t                        return Object.keys(store);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        var WildCard = function() {};\n\t        function getWildcard() {\n\t            var global = global_getGlobal();\n\t            global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard;\n\t            return global.WINDOW_WILDCARD;\n\t        }\n\t        function windowStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return globalStore(\"windowStore\").getOrSet(key, (function() {\n\t                var winStore = new weakmap_CrossDomainSafeWeakMap;\n\t                var getStore = function(win) {\n\t                    return winStore.getOrSet(win, defStore);\n\t                };\n\t                return {\n\t                    has: function(win) {\n\t                        return getStore(win).hasOwnProperty(key);\n\t                    },\n\t                    get: function(win, defVal) {\n\t                        var store = getStore(win);\n\t                        return store.hasOwnProperty(key) ? store[key] : defVal;\n\t                    },\n\t                    set: function(win, val) {\n\t                        getStore(win)[key] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(win) {\n\t                        delete getStore(win)[key];\n\t                    },\n\t                    getOrSet: function(win, getter) {\n\t                        return util_getOrSet(getStore(win), key, getter);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        function getInstanceID() {\n\t            return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n\t        }\n\t        function resolveHelloPromise(win, _ref) {\n\t            var domain = _ref.domain;\n\t            var helloPromises = windowStore(\"helloPromises\");\n\t            var existingPromise = helloPromises.get(win);\n\t            existingPromise && existingPromise.resolve({\n\t                domain: domain\n\t            });\n\t            var newPromise = promise_ZalgoPromise.resolve({\n\t                domain: domain\n\t            });\n\t            helloPromises.set(win, newPromise);\n\t            return newPromise;\n\t        }\n\t        function sayHello(win, _ref4) {\n\t            return (0, _ref4.send)(win, \"postrobot_hello\", {\n\t                instanceID: getInstanceID()\n\t            }, {\n\t                domain: \"*\",\n\t                timeout: -1\n\t            }).then((function(_ref5) {\n\t                var origin = _ref5.origin, instanceID = _ref5.data.instanceID;\n\t                resolveHelloPromise(win, {\n\t                    domain: origin\n\t                });\n\t                return {\n\t                    win: win,\n\t                    domain: origin,\n\t                    instanceID: instanceID\n\t                };\n\t            }));\n\t        }\n\t        function getWindowInstanceID(win, _ref6) {\n\t            var send = _ref6.send;\n\t            return windowStore(\"windowInstanceIDPromises\").getOrSet(win, (function() {\n\t                return sayHello(win, {\n\t                    send: send\n\t                }).then((function(_ref7) {\n\t                    return _ref7.instanceID;\n\t                }));\n\t            }));\n\t        }\n\t        function markWindowKnown(win) {\n\t            windowStore(\"knownWindows\").set(win, !0);\n\t        }\n\t        function isSerializedType(item) {\n\t            return \"object\" == typeof item && null !== item && \"string\" == typeof item.__type__;\n\t        }\n\t        function determineType(val) {\n\t            return void 0 === val ? \"undefined\" : null === val ? \"null\" : Array.isArray(val) ? \"array\" : \"function\" == typeof val ? \"function\" : \"object\" == typeof val ? val instanceof Error ? \"error\" : \"function\" == typeof val.then ? \"promise\" : \"[object RegExp]\" === {}.toString.call(val) ? \"regex\" : \"[object Date]\" === {}.toString.call(val) ? \"date\" : \"object\" : \"string\" == typeof val ? \"string\" : \"number\" == typeof val ? \"number\" : \"boolean\" == typeof val ? \"boolean\" : void 0;\n\t        }\n\t        function serializeType(type, val) {\n\t            return {\n\t                __type__: type,\n\t                __val__: val\n\t            };\n\t        }\n\t        var _SERIALIZER;\n\t        var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {\n\t            return serializeType(\"error\", {\n\t                message: _ref.message,\n\t                stack: _ref.stack,\n\t                code: _ref.code,\n\t                data: _ref.data\n\t            });\n\t        }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {\n\t            return serializeType(\"regex\", val.source);\n\t        }, _SERIALIZER.date = function(val) {\n\t            return serializeType(\"date\", val.toJSON());\n\t        }, _SERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _SERIALIZER[void 0] = function(val) {\n\t            return serializeType(\"undefined\", val);\n\t        }, _SERIALIZER);\n\t        var defaultSerializers = {};\n\t        var _DESERIALIZER;\n\t        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {\n\t            throw new Error(\"Function serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.error = function(_ref2) {\n\t            var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;\n\t            var error = new Error(_ref2.message);\n\t            error.code = code;\n\t            data && (error.data = data);\n\t            error.stack = stack + \"\\n\\n\" + error.stack;\n\t            return error;\n\t        }, _DESERIALIZER.promise = function() {\n\t            throw new Error(\"Promise serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.regex = function(val) {\n\t            return new RegExp(val);\n\t        }, _DESERIALIZER.date = function(val) {\n\t            return new Date(val);\n\t        }, _DESERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER[void 0] = function() {}, _DESERIALIZER);\n\t        var defaultDeserializers = {};\n\t        new promise_ZalgoPromise((function(resolve) {\n\t            if (window.document && window.document.body) return resolve(window.document.body);\n\t            var interval = setInterval((function() {\n\t                if (window.document && window.document.body) {\n\t                    clearInterval(interval);\n\t                    return resolve(window.document.body);\n\t                }\n\t            }), 10);\n\t        }));\n\t        function cleanupProxyWindows() {\n\t            var idToProxyWindow = globalStore(\"idToProxyWindow\");\n\t            for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {\n\t                var id = _idToProxyWindow$keys2[_i2];\n\t                idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);\n\t            }\n\t        }\n\t        function getSerializedWindow(winPromise, _ref) {\n\t            var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;\n\t            var windowNamePromise = winPromise.then((function(win) {\n\t                if (isSameDomain(win)) return assertSameDomain(win).name;\n\t            }));\n\t            var windowTypePromise = winPromise.then((function(window) {\n\t                if (isWindowClosed(window)) throw new Error(\"Window is closed, can not determine type\");\n\t                return getOpener(window) ? \"popup\" : \"iframe\";\n\t            }));\n\t            windowNamePromise.catch(src_util_noop);\n\t            windowTypePromise.catch(src_util_noop);\n\t            var getName = function() {\n\t                return winPromise.then((function(win) {\n\t                    if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;\n\t                }));\n\t            };\n\t            return {\n\t                id: id,\n\t                getType: function() {\n\t                    return windowTypePromise;\n\t                },\n\t                getInstanceID: memoizePromise((function() {\n\t                    return winPromise.then((function(win) {\n\t                        return getWindowInstanceID(win, {\n\t                            send: send\n\t                        });\n\t                    }));\n\t                })),\n\t                close: function() {\n\t                    return winPromise.then(closeWindow);\n\t                },\n\t                getName: getName,\n\t                focus: function() {\n\t                    return winPromise.then((function(win) {\n\t                        win.focus();\n\t                    }));\n\t                },\n\t                isClosed: function() {\n\t                    return winPromise.then((function(win) {\n\t                        return isWindowClosed(win);\n\t                    }));\n\t                },\n\t                setLocation: function(href, opts) {\n\t                    void 0 === opts && (opts = {});\n\t                    return winPromise.then((function(win) {\n\t                        var domain = window.location.protocol + \"//\" + window.location.host;\n\t                        var _opts$method = opts.method, method = void 0 === _opts$method ? \"get\" : _opts$method, body = opts.body;\n\t                        if (0 === href.indexOf(\"/\")) href = \"\" + domain + href; else if (!href.match(/^https?:\\/\\//) && 0 !== href.indexOf(domain)) throw new Error(\"Expected url to be http or https url, or absolute path, got \" + JSON.stringify(href));\n\t                        if (\"post\" === method) return getName().then((function(name) {\n\t                            if (!name) throw new Error(\"Can not post to window without target name\");\n\t                            !function(_ref3) {\n\t                                var url = _ref3.url, target = _ref3.target, body = _ref3.body, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? \"post\" : _ref3$method;\n\t                                var form = document.createElement(\"form\");\n\t                                form.setAttribute(\"target\", target);\n\t                                form.setAttribute(\"method\", method);\n\t                                form.setAttribute(\"action\", url);\n\t                                form.style.display = \"none\";\n\t                                if (body) for (var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++) {\n\t                                    var _body$key;\n\t                                    var key = _Object$keys4[_i24];\n\t                                    var input = document.createElement(\"input\");\n\t                                    input.setAttribute(\"name\", key);\n\t                                    input.setAttribute(\"value\", null == (_body$key = body[key]) ? void 0 : _body$key.toString());\n\t                                    form.appendChild(input);\n\t                                }\n\t                                getBody().appendChild(form);\n\t                                form.submit();\n\t                                getBody().removeChild(form);\n\t                            }({\n\t                                url: href,\n\t                                target: name,\n\t                                method: method,\n\t                                body: body\n\t                            });\n\t                        }));\n\t                        if (\"get\" !== method) throw new Error(\"Unsupported method: \" + method);\n\t                        if (isSameDomain(win)) try {\n\t                            if (win.location && \"function\" == typeof win.location.replace) {\n\t                                win.location.replace(href);\n\t                                return;\n\t                            }\n\t                        } catch (err) {}\n\t                        win.location = href;\n\t                    }));\n\t                },\n\t                setName: function(name) {\n\t                    return winPromise.then((function(win) {\n\t                        var sameDomain = isSameDomain(win);\n\t                        var frame = getFrameForWindow(win);\n\t                        if (!sameDomain) throw new Error(\"Can not set name for cross-domain window: \" + name);\n\t                        assertSameDomain(win).name = name;\n\t                        frame && frame.setAttribute(\"name\", name);\n\t                        windowNamePromise = promise_ZalgoPromise.resolve(name);\n\t                    }));\n\t                }\n\t            };\n\t        }\n\t        var window_ProxyWindow = function() {\n\t            function ProxyWindow(_ref2) {\n\t                var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;\n\t                this.id = void 0;\n\t                this.isProxyWindow = !0;\n\t                this.serializedWindow = void 0;\n\t                this.actualWindow = void 0;\n\t                this.actualWindowPromise = void 0;\n\t                this.send = void 0;\n\t                this.name = void 0;\n\t                this.actualWindowPromise = new promise_ZalgoPromise;\n\t                this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send\n\t                });\n\t                globalStore(\"idToProxyWindow\").set(this.getID(), this);\n\t                win && this.setWindow(win, {\n\t                    send: send\n\t                });\n\t            }\n\t            var _proto = ProxyWindow.prototype;\n\t            _proto.getID = function() {\n\t                return this.serializedWindow.id;\n\t            };\n\t            _proto.getType = function() {\n\t                return this.serializedWindow.getType();\n\t            };\n\t            _proto.isPopup = function() {\n\t                return this.getType().then((function(type) {\n\t                    return \"popup\" === type;\n\t                }));\n\t            };\n\t            _proto.setLocation = function(href, opts) {\n\t                var _this = this;\n\t                return this.serializedWindow.setLocation(href, opts).then((function() {\n\t                    return _this;\n\t                }));\n\t            };\n\t            _proto.getName = function() {\n\t                return this.serializedWindow.getName();\n\t            };\n\t            _proto.setName = function(name) {\n\t                var _this2 = this;\n\t                return this.serializedWindow.setName(name).then((function() {\n\t                    return _this2;\n\t                }));\n\t            };\n\t            _proto.close = function() {\n\t                var _this3 = this;\n\t                return this.serializedWindow.close().then((function() {\n\t                    return _this3;\n\t                }));\n\t            };\n\t            _proto.focus = function() {\n\t                var _this4 = this;\n\t                var isPopupPromise = this.isPopup();\n\t                var getNamePromise = this.getName();\n\t                var reopenPromise = promise_ZalgoPromise.hash({\n\t                    isPopup: isPopupPromise,\n\t                    name: getNamePromise\n\t                }).then((function(_ref3) {\n\t                    var name = _ref3.name;\n\t                    _ref3.isPopup && name && window.open(\"\", name, \"noopener\");\n\t                }));\n\t                var focusPromise = this.serializedWindow.focus();\n\t                return promise_ZalgoPromise.all([ reopenPromise, focusPromise ]).then((function() {\n\t                    return _this4;\n\t                }));\n\t            };\n\t            _proto.isClosed = function() {\n\t                return this.serializedWindow.isClosed();\n\t            };\n\t            _proto.getWindow = function() {\n\t                return this.actualWindow;\n\t            };\n\t            _proto.setWindow = function(win, _ref4) {\n\t                var send = _ref4.send;\n\t                this.actualWindow = win;\n\t                this.actualWindowPromise.resolve(this.actualWindow);\n\t                this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send,\n\t                    id: this.getID()\n\t                });\n\t                windowStore(\"winToProxyWindow\").set(win, this);\n\t            };\n\t            _proto.awaitWindow = function() {\n\t                return this.actualWindowPromise;\n\t            };\n\t            _proto.matchWindow = function(win, _ref5) {\n\t                var _this5 = this;\n\t                var send = _ref5.send;\n\t                return promise_ZalgoPromise.try((function() {\n\t                    return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({\n\t                        proxyInstanceID: _this5.getInstanceID(),\n\t                        knownWindowInstanceID: getWindowInstanceID(win, {\n\t                            send: send\n\t                        })\n\t                    }).then((function(_ref6) {\n\t                        var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;\n\t                        match && _this5.setWindow(win, {\n\t                            send: send\n\t                        });\n\t                        return match;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.unwrap = function() {\n\t                return this.actualWindow || this;\n\t            };\n\t            _proto.getInstanceID = function() {\n\t                return this.serializedWindow.getInstanceID();\n\t            };\n\t            _proto.shouldClean = function() {\n\t                return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n\t            };\n\t            _proto.serialize = function() {\n\t                return this.serializedWindow;\n\t            };\n\t            ProxyWindow.unwrap = function(win) {\n\t                return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;\n\t            };\n\t            ProxyWindow.serialize = function(win, _ref7) {\n\t                var send = _ref7.send;\n\t                cleanupProxyWindows();\n\t                return ProxyWindow.toProxyWindow(win, {\n\t                    send: send\n\t                }).serialize();\n\t            };\n\t            ProxyWindow.deserialize = function(serializedWindow, _ref8) {\n\t                var send = _ref8.send;\n\t                cleanupProxyWindows();\n\t                return globalStore(\"idToProxyWindow\").get(serializedWindow.id) || new ProxyWindow({\n\t                    serializedWindow: serializedWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            ProxyWindow.isProxyWindow = function(obj) {\n\t                return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n\t            };\n\t            ProxyWindow.toProxyWindow = function(win, _ref9) {\n\t                var send = _ref9.send;\n\t                cleanupProxyWindows();\n\t                if (ProxyWindow.isProxyWindow(win)) return win;\n\t                var actualWindow = win;\n\t                return windowStore(\"winToProxyWindow\").get(actualWindow) || new ProxyWindow({\n\t                    win: actualWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            return ProxyWindow;\n\t        }();\n\t        function addMethod(id, val, name, source, domain) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {\n\t                val: val,\n\t                name: name,\n\t                domain: domain,\n\t                source: source\n\t            }); else {\n\t                proxyWindowMethods.del(id);\n\t                methodStore.getOrSet(source, (function() {\n\t                    return {};\n\t                }))[id] = {\n\t                    domain: domain,\n\t                    name: name,\n\t                    val: val,\n\t                    source: source\n\t                };\n\t            }\n\t        }\n\t        function lookupMethod(source, id) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            return methodStore.getOrSet(source, (function() {\n\t                return {};\n\t            }))[id] || proxyWindowMethods.get(id);\n\t        }\n\t        function function_serializeFunction(destination, domain, val, key, _ref3) {\n\t            on = (_ref = {\n\t                on: _ref3.on,\n\t                send: _ref3.send\n\t            }).on, send = _ref.send, globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", (function() {\n\t                return on(\"postrobot_method\", {\n\t                    domain: \"*\"\n\t                }, (function(_ref2) {\n\t                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;\n\t                    var id = data.id, name = data.name;\n\t                    var meth = lookupMethod(source, id);\n\t                    if (!meth) throw new Error(\"Could not find method '\" + name + \"' with id: \" + data.id + \" in \" + getDomain(window));\n\t                    var methodSource = meth.source, domain = meth.domain, val = meth.val;\n\t                    return promise_ZalgoPromise.try((function() {\n\t                        if (!matchDomain(domain, origin)) throw new Error(\"Method '\" + data.name + \"' domain \" + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + \" does not match origin \" + origin + \" in \" + getDomain(window));\n\t                        if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {\n\t                            send: send\n\t                        }).then((function(match) {\n\t                            if (!match) throw new Error(\"Method call '\" + data.name + \"' failed - proxy window does not match source in \" + getDomain(window));\n\t                        }));\n\t                    })).then((function() {\n\t                        return val.apply({\n\t                            source: source,\n\t                            origin: origin\n\t                        }, data.args);\n\t                    }), (function(err) {\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            if (val.onError) return val.onError(err);\n\t                        })).then((function() {\n\t                            err.stack && (err.stack = \"Remote call to \" + name + \"(\" + function(args) {\n\t                                void 0 === args && (args = []);\n\t                                return (item = args, [].slice.call(item)).map((function(arg) {\n\t                                    return \"string\" == typeof arg ? \"'\" + arg + \"'\" : void 0 === arg ? \"undefined\" : null === arg ? \"null\" : \"boolean\" == typeof arg ? arg.toString() : Array.isArray(arg) ? \"[ ... ]\" : \"object\" == typeof arg ? \"{ ... }\" : \"function\" == typeof arg ? \"() => { ... }\" : \"<\" + typeof arg + \">\";\n\t                                })).join(\", \");\n\t                                var item;\n\t                            }(data.args) + \") failed\\n\\n\" + err.stack);\n\t                            throw err;\n\t                        }));\n\t                    })).then((function(result) {\n\t                        return {\n\t                            result: result,\n\t                            id: id,\n\t                            name: name\n\t                        };\n\t                    }));\n\t                }));\n\t            }));\n\t            var _ref, on, send;\n\t            var id = val.__id__ || uniqueID();\n\t            destination = window_ProxyWindow.unwrap(destination);\n\t            var name = val.__name__ || val.name || key;\n\t            \"string\" == typeof name && \"function\" == typeof name.indexOf && 0 === name.indexOf(\"anonymous::\") && (name = name.replace(\"anonymous::\", key + \"::\"));\n\t            if (window_ProxyWindow.isProxyWindow(destination)) {\n\t                addMethod(id, val, name, destination, domain);\n\t                destination.awaitWindow().then((function(win) {\n\t                    addMethod(id, val, name, win, domain);\n\t                }));\n\t            } else addMethod(id, val, name, destination, domain);\n\t            return serializeType(\"cross_domain_function\", {\n\t                id: id,\n\t                name: name\n\t            });\n\t        }\n\t        function serializeMessage(destination, domain, obj, _ref) {\n\t            var _serialize;\n\t            var on = _ref.on, send = _ref.send;\n\t            return function(obj, serializers) {\n\t                void 0 === serializers && (serializers = defaultSerializers);\n\t                var result = JSON.stringify(obj, (function(key) {\n\t                    var val = this[key];\n\t                    if (isSerializedType(this)) return val;\n\t                    var type = determineType(val);\n\t                    if (!type) return val;\n\t                    var serializer = serializers[type] || SERIALIZER[type];\n\t                    return serializer ? serializer(val, key) : val;\n\t                }));\n\t                return void 0 === result ? \"undefined\" : result;\n\t            }(obj, ((_serialize = {}).promise = function(val, key) {\n\t                return function(destination, domain, val, key, _ref) {\n\t                    return serializeType(\"cross_domain_zalgo_promise\", {\n\t                        then: function_serializeFunction(destination, domain, (function(resolve, reject) {\n\t                            return val.then(resolve, reject);\n\t                        }), key, {\n\t                            on: _ref.on,\n\t                            send: _ref.send\n\t                        })\n\t                    });\n\t                }(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.function = function(val, key) {\n\t                return function_serializeFunction(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.object = function(val) {\n\t                return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType(\"cross_domain_window\", window_ProxyWindow.serialize(val, {\n\t                    send: send\n\t                })) : val;\n\t            }, _serialize));\n\t        }\n\t        function deserializeMessage(source, origin, message, _ref2) {\n\t            var _deserialize;\n\t            var send = _ref2.send;\n\t            return function(str, deserializers) {\n\t                void 0 === deserializers && (deserializers = defaultDeserializers);\n\t                if (\"undefined\" !== str) return JSON.parse(str, (function(key, val) {\n\t                    if (isSerializedType(this)) return val;\n\t                    var type;\n\t                    var value;\n\t                    if (isSerializedType(val)) {\n\t                        type = val.__type__;\n\t                        value = val.__val__;\n\t                    } else {\n\t                        type = determineType(val);\n\t                        value = val;\n\t                    }\n\t                    if (!type) return value;\n\t                    var deserializer = deserializers[type] || DESERIALIZER[type];\n\t                    return deserializer ? deserializer(value, key) : value;\n\t                }));\n\t            }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {\n\t                return function(source, origin, _ref2) {\n\t                    return new promise_ZalgoPromise(_ref2.then);\n\t                }(0, 0, serializedPromise);\n\t            }, _deserialize.cross_domain_function = function(serializedFunction) {\n\t                return function(source, origin, _ref4, _ref5) {\n\t                    var id = _ref4.id, name = _ref4.name;\n\t                    var send = _ref5.send;\n\t                    var getDeserializedFunction = function(opts) {\n\t                        void 0 === opts && (opts = {});\n\t                        function crossDomainFunctionWrapper() {\n\t                            var _arguments = arguments;\n\t                            return window_ProxyWindow.toProxyWindow(source, {\n\t                                send: send\n\t                            }).awaitWindow().then((function(win) {\n\t                                var meth = lookupMethod(win, id);\n\t                                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({\n\t                                    source: window,\n\t                                    origin: getDomain()\n\t                                }, _arguments);\n\t                                var _args = [].slice.call(_arguments);\n\t                                return opts.fireAndForget ? send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: !0\n\t                                }) : send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: !1\n\t                                }).then((function(res) {\n\t                                    return res.data.result;\n\t                                }));\n\t                            })).catch((function(err) {\n\t                                throw err;\n\t                            }));\n\t                        }\n\t                        crossDomainFunctionWrapper.__name__ = name;\n\t                        crossDomainFunctionWrapper.__origin__ = origin;\n\t                        crossDomainFunctionWrapper.__source__ = source;\n\t                        crossDomainFunctionWrapper.__id__ = id;\n\t                        crossDomainFunctionWrapper.origin = origin;\n\t                        return crossDomainFunctionWrapper;\n\t                    };\n\t                    var crossDomainFunctionWrapper = getDeserializedFunction();\n\t                    crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n\t                        fireAndForget: !0\n\t                    });\n\t                    return crossDomainFunctionWrapper;\n\t                }(source, origin, serializedFunction, {\n\t                    send: send\n\t                });\n\t            }, _deserialize.cross_domain_window = function(serializedWindow) {\n\t                return window_ProxyWindow.deserialize(serializedWindow, {\n\t                    send: send\n\t                });\n\t            }, _deserialize));\n\t        }\n\t        var SEND_MESSAGE_STRATEGIES = {};\n\t        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {\n\t            0 === domain.indexOf(\"file:\") && (domain = \"*\");\n\t            win.postMessage(serializedMessage, domain);\n\t        };\n\t        function send_sendMessage(win, domain, message, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            return promise_ZalgoPromise.try((function() {\n\t                var domainBuffer = windowStore().getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                domainBuffer.buffer = domainBuffer.buffer || [];\n\t                domainBuffer.buffer.push(message);\n\t                domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then((function() {\n\t                    if (isWindowClosed(win)) throw new Error(\"Window is closed\");\n\t                    var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_46__ = domainBuffer.buffer || [], \n\t                    _ref), {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                    var _ref;\n\t                    delete domainBuffer.buffer;\n\t                    var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n\t                    var errors = [];\n\t                    for (var _i2 = 0; _i2 < strategies.length; _i2++) {\n\t                        var strategyName = strategies[_i2];\n\t                        try {\n\t                            SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n\t                        } catch (err) {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                    if (errors.length === strategies.length) throw new Error(\"All post-robot messaging strategies failed:\\n\\n\" + errors.map((function(err, i) {\n\t                        return i + \". \" + stringifyError(err);\n\t                    })).join(\"\\n\\n\"));\n\t                }));\n\t                return domainBuffer.flush.then((function() {\n\t                    delete domainBuffer.flush;\n\t                }));\n\t            })).then(src_util_noop);\n\t        }\n\t        function getResponseListener(hash) {\n\t            return globalStore(\"responseListeners\").get(hash);\n\t        }\n\t        function deleteResponseListener(hash) {\n\t            globalStore(\"responseListeners\").del(hash);\n\t        }\n\t        function isResponseListenerErrored(hash) {\n\t            return globalStore(\"erroredResponseListeners\").has(hash);\n\t        }\n\t        function getRequestListener(_ref) {\n\t            var name = _ref.name, win = _ref.win, domain = _ref.domain;\n\t            var requestListeners = windowStore(\"requestListeners\");\n\t            \"*\" === win && (win = null);\n\t            \"*\" === domain && (domain = null);\n\t            if (!name) throw new Error(\"Name required to get request listener\");\n\t            for (var _i4 = 0, _ref3 = [ win, getWildcard() ]; _i4 < _ref3.length; _i4++) {\n\t                var winQualifier = _ref3[_i4];\n\t                if (winQualifier) {\n\t                    var nameListeners = requestListeners.get(winQualifier);\n\t                    if (nameListeners) {\n\t                        var domainListeners = nameListeners[name];\n\t                        if (domainListeners) {\n\t                            if (domain && \"string\" == typeof domain) {\n\t                                if (domainListeners[domain]) return domainListeners[domain];\n\t                                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {\n\t                                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;\n\t                                    if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;\n\t                                }\n\t                            }\n\t                            if (domainListeners[\"*\"]) return domainListeners[\"*\"];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function handleRequest(source, origin, message, _ref) {\n\t            var on = _ref.on, send = _ref.send;\n\t            var options = getRequestListener({\n\t                name: message.name,\n\t                win: source,\n\t                domain: origin\n\t            });\n\t            var logName = \"postrobot_method\" === message.name && message.data && \"string\" == typeof message.data.name ? message.data.name + \"()\" : message.name;\n\t            function sendResponse(ack, data, error) {\n\t                return promise_ZalgoPromise.flush().then((function() {\n\t                    if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                        return send_sendMessage(source, origin, {\n\t                            id: uniqueID(),\n\t                            origin: getDomain(window),\n\t                            type: \"postrobot_message_response\",\n\t                            hash: message.hash,\n\t                            name: message.name,\n\t                            ack: ack,\n\t                            data: data,\n\t                            error: error\n\t                        }, {\n\t                            on: on,\n\t                            send: send\n\t                        });\n\t                    } catch (err) {\n\t                        throw new Error(\"Send response message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }\n\t                }));\n\t            }\n\t            return promise_ZalgoPromise.all([ promise_ZalgoPromise.flush().then((function() {\n\t                if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                    return send_sendMessage(source, origin, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_ack\",\n\t                        hash: message.hash,\n\t                        name: message.name\n\t                    }, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    throw new Error(\"Send ack message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                }\n\t            })), promise_ZalgoPromise.try((function() {\n\t                if (!options) throw new Error(\"No handler found for post message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                return options.handler({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            })).then((function(data) {\n\t                return sendResponse(\"success\", data);\n\t            }), (function(error) {\n\t                return sendResponse(\"error\", null, error);\n\t            })) ]).then(src_util_noop).catch((function(err) {\n\t                if (options && options.handleError) return options.handleError(err);\n\t                throw err;\n\t            }));\n\t        }\n\t        function handleAck(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message ack for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                try {\n\t                    if (!matchDomain(options.domain, origin)) throw new Error(\"Ack origin \" + origin + \" does not match domain \" + options.domain.toString());\n\t                    if (source !== options.win) throw new Error(\"Ack source does not match registered window\");\n\t                } catch (err) {\n\t                    options.promise.reject(err);\n\t                }\n\t                options.ack = !0;\n\t            }\n\t        }\n\t        function handleResponse(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message response for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                if (!matchDomain(options.domain, origin)) throw new Error(\"Response origin \" + origin + \" does not match domain \" + (pattern = options.domain, \n\t                Array.isArray(pattern) ? \"(\" + pattern.join(\" | \") + \")\" : isRegex(pattern) ? \"RegExp(\" + pattern.toString() + \")\" : pattern.toString()));\n\t                var pattern;\n\t                if (source !== options.win) throw new Error(\"Response source does not match registered window\");\n\t                deleteResponseListener(message.hash);\n\t                \"error\" === message.ack ? options.promise.reject(message.error) : \"success\" === message.ack && options.promise.resolve({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            }\n\t        }\n\t        function receive_receiveMessage(event, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            var receivedMessages = globalStore(\"receivedMessages\");\n\t            try {\n\t                if (!window || window.closed || !event.source) return;\n\t            } catch (err) {\n\t                return;\n\t            }\n\t            var source = event.source, origin = event.origin;\n\t            var messages = function(message, source, origin, _ref) {\n\t                var on = _ref.on, send = _ref.send;\n\t                var parsedMessage;\n\t                try {\n\t                    parsedMessage = deserializeMessage(source, origin, message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    return;\n\t                }\n\t                if (parsedMessage && \"object\" == typeof parsedMessage && null !== parsedMessage) {\n\t                    var parseMessages = parsedMessage.__post_robot_10_0_46__;\n\t                    if (Array.isArray(parseMessages)) return parseMessages;\n\t                }\n\t            }(event.data, source, origin, {\n\t                on: on,\n\t                send: send\n\t            });\n\t            if (messages) {\n\t                markWindowKnown(source);\n\t                for (var _i2 = 0; _i2 < messages.length; _i2++) {\n\t                    var message = messages[_i2];\n\t                    if (receivedMessages.has(message.id)) return;\n\t                    receivedMessages.set(message.id, !0);\n\t                    if (isWindowClosed(source) && !message.fireAndForget) return;\n\t                    0 === message.origin.indexOf(\"file:\") && (origin = \"file://\");\n\t                    try {\n\t                        \"postrobot_message_request\" === message.type ? handleRequest(source, origin, message, {\n\t                            on: on,\n\t                            send: send\n\t                        }) : \"postrobot_message_response\" === message.type ? handleResponse(source, origin, message) : \"postrobot_message_ack\" === message.type && handleAck(source, origin, message);\n\t                    } catch (err) {\n\t                        setTimeout((function() {\n\t                            throw err;\n\t                        }), 0);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function on_on(name, options, handler) {\n\t            if (!name) throw new Error(\"Expected name\");\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            if (!handler) throw new Error(\"Expected handler\");\n\t            var requestListener = function addRequestListener(_ref4, listener) {\n\t                var name = _ref4.name, winCandidate = _ref4.win, domain = _ref4.domain;\n\t                var requestListeners = windowStore(\"requestListeners\");\n\t                if (!name || \"string\" != typeof name) throw new Error(\"Name required to add request listener\");\n\t                if (winCandidate && \"*\" !== winCandidate && window_ProxyWindow.isProxyWindow(winCandidate)) {\n\t                    var requestListenerPromise = winCandidate.awaitWindow().then((function(actualWin) {\n\t                        return addRequestListener({\n\t                            name: name,\n\t                            win: actualWin,\n\t                            domain: domain\n\t                        }, listener);\n\t                    }));\n\t                    return {\n\t                        cancel: function() {\n\t                            requestListenerPromise.then((function(requestListener) {\n\t                                return requestListener.cancel();\n\t                            }), src_util_noop);\n\t                        }\n\t                    };\n\t                }\n\t                var win = winCandidate;\n\t                if (Array.isArray(win)) {\n\t                    var listenersCollection = [];\n\t                    for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        domain: domain,\n\t                        win: _win2[_i8]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                if (Array.isArray(domain)) {\n\t                    var _listenersCollection = [];\n\t                    for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        win: win,\n\t                        domain: _domain2[_i12]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                var existingListener = getRequestListener({\n\t                    name: name,\n\t                    win: win,\n\t                    domain: domain\n\t                });\n\t                win && \"*\" !== win || (win = getWildcard());\n\t                var strDomain = (domain = domain || \"*\").toString();\n\t                if (existingListener) throw win && domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString() + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : win ? new Error(\"Request listener already exists for \" + name + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString()) : new Error(\"Request listener already exists for \" + name);\n\t                var winNameListeners = requestListeners.getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainListeners = util_getOrSet(winNameListeners, name, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainRegexListeners;\n\t                var winNameDomainRegexListener;\n\t                util_isRegex(domain) ? (winNameDomainRegexListeners = util_getOrSet(winNameDomainListeners, \"__domain_regex__\", (function() {\n\t                    return [];\n\t                }))).push(winNameDomainRegexListener = {\n\t                    regex: domain,\n\t                    listener: listener\n\t                }) : winNameDomainListeners[strDomain] = listener;\n\t                return {\n\t                    cancel: function() {\n\t                        delete winNameDomainListeners[strDomain];\n\t                        if (winNameDomainRegexListener) {\n\t                            winNameDomainRegexListeners.splice(winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1));\n\t                            winNameDomainRegexListeners.length || delete winNameDomainListeners.__domain_regex__;\n\t                        }\n\t                        Object.keys(winNameDomainListeners).length || delete winNameListeners[name];\n\t                        win && !Object.keys(winNameListeners).length && requestListeners.del(win);\n\t                    }\n\t                };\n\t            }({\n\t                name: name,\n\t                win: options.window,\n\t                domain: options.domain || \"*\"\n\t            }, {\n\t                handler: handler || options.handler,\n\t                handleError: options.errorHandler || function(err) {\n\t                    throw err;\n\t                }\n\t            });\n\t            return {\n\t                cancel: function() {\n\t                    requestListener.cancel();\n\t                }\n\t            };\n\t        }\n\t        function on_once(name, options, handler) {\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            var promise = new promise_ZalgoPromise;\n\t            var listener;\n\t            options.errorHandler = function(err) {\n\t                listener.cancel();\n\t                promise.reject(err);\n\t            };\n\t            listener = on_on(name, options, (function(event) {\n\t                listener.cancel();\n\t                promise.resolve(event);\n\t                if (handler) return handler(event);\n\t            }));\n\t            promise.cancel = listener.cancel;\n\t            return promise;\n\t        }\n\t        var send_send = function send(winOrProxyWin, name, data, options) {\n\t            var domainMatcher = (options = options || {}).domain || \"*\";\n\t            var responseTimeout = options.timeout || -1;\n\t            var childTimeout = options.timeout || 5e3;\n\t            var fireAndForget = options.fireAndForget || !1;\n\t            return window_ProxyWindow.toProxyWindow(winOrProxyWin, {\n\t                send: send\n\t            }).awaitWindow().then((function(win) {\n\t                return promise_ZalgoPromise.try((function() {\n\t                    !function(name, win, domain) {\n\t                        if (!name) throw new Error(\"Expected name\");\n\t                        if (domain && \"string\" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError(\"Can not send \" + name + \". Expected domain \" + JSON.stringify(domain) + \" to be a string, array, or regex\");\n\t                        if (isWindowClosed(win)) throw new Error(\"Can not send \" + name + \". Target window is closed\");\n\t                    }(name, win, domainMatcher);\n\t                    if (function(parent, child) {\n\t                        var actualParent = getAncestor(child);\n\t                        if (actualParent) return actualParent === parent;\n\t                        if (child === parent) return !1;\n\t                        if (function(win) {\n\t                            void 0 === win && (win = window);\n\t                            try {\n\t                                if (win.top) return win.top;\n\t                            } catch (err) {}\n\t                            if (getParent(win) === win) return win;\n\t                            try {\n\t                                if (isAncestorParent(window, win) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            try {\n\t                                if (isAncestorParent(win, window) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            for (var _i7 = 0, _getAllChildFrames4 = function getAllChildFrames(win) {\n\t                                var result = [];\n\t                                for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n\t                                    var frame = _getFrames2[_i3];\n\t                                    result.push(frame);\n\t                                    for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);\n\t                                }\n\t                                return result;\n\t                            }(win); _i7 < _getAllChildFrames4.length; _i7++) {\n\t                                var frame = _getAllChildFrames4[_i7];\n\t                                try {\n\t                                    if (frame.top) return frame.top;\n\t                                } catch (err) {}\n\t                                if (getParent(frame) === frame) return frame;\n\t                            }\n\t                        }(child) === child) return !1;\n\t                        for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return !0;\n\t                        return !1;\n\t                    }(window, win)) return function(win, timeout, name) {\n\t                        void 0 === timeout && (timeout = 5e3);\n\t                        void 0 === name && (name = \"Window\");\n\t                        var promise = function(win) {\n\t                            return windowStore(\"helloPromises\").getOrSet(win, (function() {\n\t                                return new promise_ZalgoPromise;\n\t                            }));\n\t                        }(win);\n\t                        -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + \" did not load after \" + timeout + \"ms\")));\n\t                        return promise;\n\t                    }(win, childTimeout);\n\t                })).then((function(_temp) {\n\t                    return function(win, targetDomain, actualDomain, _ref) {\n\t                        var send = _ref.send;\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            return \"string\" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try((function() {\n\t                                return actualDomain || sayHello(win, {\n\t                                    send: send\n\t                                }).then((function(_ref2) {\n\t                                    return _ref2.domain;\n\t                                }));\n\t                            })).then((function(normalizedDomain) {\n\t                                if (!matchDomain(targetDomain, targetDomain)) throw new Error(\"Domain \" + stringify(targetDomain) + \" does not match \" + stringify(targetDomain));\n\t                                return normalizedDomain;\n\t                            }));\n\t                        }));\n\t                    }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {\n\t                        send: send\n\t                    });\n\t                })).then((function(targetDomain) {\n\t                    var domain = targetDomain;\n\t                    var logName = \"postrobot_method\" === name && data && \"string\" == typeof data.name ? data.name + \"()\" : name;\n\t                    var promise = new promise_ZalgoPromise;\n\t                    var hash = name + \"_\" + uniqueID();\n\t                    if (!fireAndForget) {\n\t                        var responseListener = {\n\t                            name: name,\n\t                            win: win,\n\t                            domain: domain,\n\t                            promise: promise\n\t                        };\n\t                        !function(hash, listener) {\n\t                            globalStore(\"responseListeners\").set(hash, listener);\n\t                        }(hash, responseListener);\n\t                        var reqPromises = windowStore(\"requestPromises\").getOrSet(win, (function() {\n\t                            return [];\n\t                        }));\n\t                        reqPromises.push(promise);\n\t                        promise.catch((function() {\n\t                            !function(hash) {\n\t                                globalStore(\"erroredResponseListeners\").set(hash, !0);\n\t                            }(hash);\n\t                            deleteResponseListener(hash);\n\t                        }));\n\t                        var totalAckTimeout = function(win) {\n\t                            return windowStore(\"knownWindows\").get(win, !1);\n\t                        }(win) ? 1e4 : 2e3;\n\t                        var totalResTimeout = responseTimeout;\n\t                        var ackTimeout = totalAckTimeout;\n\t                        var resTimeout = totalResTimeout;\n\t                        var interval = function(method, time) {\n\t                            var timeout;\n\t                            !function loop() {\n\t                                timeout = setTimeout((function() {\n\t                                    !function() {\n\t                                        if (isWindowClosed(win)) return promise.reject(new Error(\"Window closed for \" + name + \" before \" + (responseListener.ack ? \"response\" : \"ack\")));\n\t                                        if (responseListener.cancelled) return promise.reject(new Error(\"Response listener was cancelled for \" + name));\n\t                                        ackTimeout = Math.max(ackTimeout - 500, 0);\n\t                                        -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));\n\t                                        responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout && promise.reject(new Error(\"No response for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalResTimeout + \"ms\")) : promise.reject(new Error(\"No ack for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalAckTimeout + \"ms\"));\n\t                                    }();\n\t                                    loop();\n\t                                }), 500);\n\t                            }();\n\t                            return {\n\t                                cancel: function() {\n\t                                    clearTimeout(timeout);\n\t                                }\n\t                            };\n\t                        }();\n\t                        promise.finally((function() {\n\t                            interval.cancel();\n\t                            reqPromises.splice(reqPromises.indexOf(promise, 1));\n\t                        })).catch(src_util_noop);\n\t                    }\n\t                    return send_sendMessage(win, domain, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_request\",\n\t                        hash: hash,\n\t                        name: name,\n\t                        data: data,\n\t                        fireAndForget: fireAndForget\n\t                    }, {\n\t                        on: on_on,\n\t                        send: send\n\t                    }).then((function() {\n\t                        return fireAndForget ? promise.resolve() : promise;\n\t                    }), (function(err) {\n\t                        throw new Error(\"Send request message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }));\n\t                }));\n\t            }));\n\t        };\n\t        function setup_serializeMessage(destination, domain, obj) {\n\t            return serializeMessage(destination, domain, obj, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup_deserializeMessage(source, origin, message) {\n\t            return deserializeMessage(source, origin, message, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function createProxyWindow(win) {\n\t            return new window_ProxyWindow({\n\t                send: send_send,\n\t                win: win\n\t            });\n\t        }\n\t        function setup_toProxyWindow(win) {\n\t            return window_ProxyWindow.toProxyWindow(win, {\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup() {\n\t            if (!global_getGlobal().initialized) {\n\t                global_getGlobal().initialized = !0;\n\t                on = (_ref3 = {\n\t                    on: on_on,\n\t                    send: send_send\n\t                }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function(message) {\n\t                    return receive_receiveMessage(message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                };\n\t                !function(_ref5) {\n\t                    var on = _ref5.on, send = _ref5.send;\n\t                    globalStore().getOrSet(\"postMessageListener\", (function() {\n\t                        return function(obj, event, handler) {\n\t                            obj.addEventListener(\"message\", handler);\n\t                            return {\n\t                                cancel: function() {\n\t                                    obj.removeEventListener(\"message\", handler);\n\t                                }\n\t                            };\n\t                        }(window, 0, (function(event) {\n\t                            !function(event, _ref4) {\n\t                                var on = _ref4.on, send = _ref4.send;\n\t                                promise_ZalgoPromise.try((function() {\n\t                                    var source = event.source || event.sourceElement;\n\t                                    var origin = event.origin || event.originalEvent && event.originalEvent.origin;\n\t                                    var data = event.data;\n\t                                    \"null\" === origin && (origin = \"file://\");\n\t                                    if (source) {\n\t                                        if (!origin) throw new Error(\"Post message did not have origin domain\");\n\t                                        receive_receiveMessage({\n\t                                            source: source,\n\t                                            origin: origin,\n\t                                            data: data\n\t                                        }, {\n\t                                            on: on,\n\t                                            send: send\n\t                                        });\n\t                                    }\n\t                                }));\n\t                            }(event, {\n\t                                on: on,\n\t                                send: send\n\t                            });\n\t                        }));\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t                !function(_ref8) {\n\t                    var on = _ref8.on, send = _ref8.send;\n\t                    globalStore(\"builtinListeners\").getOrSet(\"helloListener\", (function() {\n\t                        var listener = on(\"postrobot_hello\", {\n\t                            domain: \"*\"\n\t                        }, (function(_ref3) {\n\t                            resolveHelloPromise(_ref3.source, {\n\t                                domain: _ref3.origin\n\t                            });\n\t                            return {\n\t                                instanceID: getInstanceID()\n\t                            };\n\t                        }));\n\t                        var parent = getAncestor();\n\t                        parent && sayHello(parent, {\n\t                            send: send\n\t                        }).catch((function(err) {}));\n\t                        return listener;\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t            }\n\t            var _ref3, on, send, global;\n\t        }\n\t        function destroy() {\n\t            !function() {\n\t                var responseListeners = globalStore(\"responseListeners\");\n\t                for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {\n\t                    var hash = _responseListeners$ke2[_i2];\n\t                    var listener = responseListeners.get(hash);\n\t                    listener && (listener.cancelled = !0);\n\t                    responseListeners.del(hash);\n\t                }\n\t            }();\n\t            (listener = globalStore().get(\"postMessageListener\")) && listener.cancel();\n\t            var listener;\n\t            delete window.__post_robot_10_0_46__;\n\t        }\n\t        var src_types_TYPES_0 = !0;\n\t        function cleanUpWindow(win) {\n\t            for (var _i2 = 0, _requestPromises$get2 = windowStore(\"requestPromises\").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error(\"Window \" + (isWindowClosed(win) ? \"closed\" : \"cleaned up\") + \" before response\")).catch(src_util_noop);\n\t        }\n\t        setup();\n\t    } ]);\n\t})); \n} (postRobot));\n\nvar postRobotExports$1 = postRobot.exports;\n\n/* @flow */\n\n(function (module) {\n\t// $FlowFixMe\n\tmodule.exports = postRobotExports$1; // eslint-disable-line import/no-commonjs\n\n\t// $FlowFixMe\n\tmodule.exports.default = module.exports; // eslint-disable-line import/no-commonjs \n} (postRobot$1));\n\nvar postRobotExports = postRobot$1.exports;\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postRobotExports);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n\t__proto__: null,\n\tdefault: index\n}, [postRobotExports]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9mYW1pbHlAMC4xLjNfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV92aWVtQDIuMzcuNl9idWZmZXJ1dGlsQDQuMC45X3RfZjUzMzIzOTFhNjdhNmZhNGVhODRjNjExNWNhZGZlOTcvbm9kZV9tb2R1bGVzL2ZhbWlseS9saWIvaW5kZXgtRERfa25kRHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLGtCQUFrQiwrQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLCtCQUFtQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixTQUFTLCtCQUFtQjtBQUM1QixTQUFTLCtCQUFtQjtBQUM1QixhQUFhLCtCQUFtQjtBQUNoQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUIsa0NBQWtDLCtCQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsOEVBQThFLCtCQUFtQjtBQUNqRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCLGdCQUFnQiwrQkFBbUIsQ0FBQywrQkFBbUI7QUFDdkQsTUFBTSxvQkFBb0IsMEJBQW1CLEVBQUUsK0JBQW1CO0FBQ2xFLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xELFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CO0FBQ2xEO0FBQ0EsVUFBVTtBQUNWLFNBQVMsK0JBQW1CLEdBQUcsMEJBQW1CLDBCQUEwQjtBQUM1RTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtREFBbUQ7QUFDbEY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLHNDQUFzQztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw2Q0FBNkMsNkNBQTZDO0FBQzFGO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsd0dBQXdHLEVBQUU7QUFDMUc7QUFDQSxrQkFBa0I7QUFDbEIsMkNBQTJDLE1BQU0sU0FBUyxNQUFNO0FBQ2hFO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseU5BQXlOO0FBQy9PLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixhQUFhO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixlQUFlO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtSUFBbUksc0NBQXNDO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixjQUFjO0FBQ2Q7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ1JBQWdSLHNEQUFzRDtBQUN0VTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVUscUNBQXFDO0FBQy9DO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQseUVBQXlFO0FBQ3pFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysd0VBQXdFO0FBQ3hFLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVUsdUNBQXVDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQSxnRkFBZ0YscUNBQXFDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyw2QkFBNkI7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esc1BBQXNQLEtBQUssd0NBQXdDLEtBQUs7QUFDeFMsa0NBQWtDO0FBQ2xDO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0Esa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5QkFBeUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELG9CQUFvQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0pBQW9KLHFDQUFxQztBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGdEQUFnRCxtQ0FBbUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx3QkFBd0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxnREFBZ0Qsb0NBQW9DO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxpRkFBaUYsMEJBQTBCO0FBQzNHO0FBQ0E7QUFDQSx1R0FBdUcsa0NBQWtDO0FBQ3pJO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTyxrQ0FBa0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsNkVBQTZFLDJCQUEyQjtBQUN4RztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLHNCQUFzQiw0Q0FBNEM7QUFDbEU7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0Esa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixxQ0FBcUM7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csb0NBQW9DO0FBQ3hJO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsRUFBRTtBQUNGLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQSwwQ0FBMEM7QUFDMUMsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRXVCIiwic291cmNlcyI6WyIvVXNlcnMvZWxlbWVuL3NvbGlkaXR5L3NvbGlkaXR5LW5leHQtanMtdGVtcGxhdGUvZnJvbnRlbmQvbm9kZV9tb2R1bGVzLy5wbnBtL2ZhbWlseUAwLjEuM19yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xX3ZpZW1AMi4zNy42X2J1ZmZlcnV0aWxANC4wLjlfdF9mNTMzMjM5MWE2N2E2ZmE0ZWE4NGM2MTE1Y2FkZmU5Ny9ub2RlX21vZHVsZXMvZmFtaWx5L2xpYi9pbmRleC1ERF9rbmREcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcblx0bS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0ZSAmJiB0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhKGsgaW4gbikpIHtcblx0XHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgcG9zdFJvYm90JDEgPSB7ZXhwb3J0czoge319O1xuXG52YXIgcG9zdFJvYm90ID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0IWZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDtcblx0fShcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZWxmID8gc2VsZiA6IGNvbW1vbmpzR2xvYmFsLCAoZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24obW9kdWxlcykge1xuXHQgICAgICAgIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cdCAgICAgICAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQgICAgICAgICAgICBpZiAoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXHQgICAgICAgICAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG5cdCAgICAgICAgICAgICAgICBpOiBtb2R1bGVJZCxcblx0ICAgICAgICAgICAgICAgIGw6ICExLFxuXHQgICAgICAgICAgICAgICAgZXhwb3J0czoge31cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdCAgICAgICAgICAgIG1vZHVsZS5sID0gITA7XG5cdCAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0ICAgICAgICB9XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuXHQgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcblx0ICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuXHQgICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG5cdCAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHQgICAgICAgICAgICAgICAgdmFsdWU6IFwiTW9kdWxlXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgICAgICAgICAgICAgICAgdmFsdWU6ICEwXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcblx0ICAgICAgICAgICAgMSAmIG1vZGUgJiYgKHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSkpO1xuXHQgICAgICAgICAgICBpZiAoOCAmIG1vZGUpIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKDQgJiBtb2RlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgdmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCBcImRlZmF1bHRcIiwge1xuXHQgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGlmICgyICYgbW9kZSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiB2YWx1ZSkgZm9yICh2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcblx0ICAgICAgICAgICAgfS5iaW5kKG51bGwsIGtleSkpO1xuXHQgICAgICAgICAgICByZXR1cm4gbnM7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0ICAgICAgICAgICAgdmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5kZWZhdWx0O1xuXHQgICAgICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCBcImFcIiwgZ2V0dGVyKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldHRlcjtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHQgICAgICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuXHQgICAgfShbIGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQcm9taXNlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUWVBFU1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzcmNfdHlwZXNfVFlQRVNfMDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUHJveHlXaW5kb3dcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gd2luZG93X1Byb3h5V2luZG93O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXR1cFwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXR1cDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVzdHJveVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkZXN0cm95O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXJpYWxpemVNZXNzYWdlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHVwX3NlcmlhbGl6ZU1lc3NhZ2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlc2VyaWFsaXplTWVzc2FnZVwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXR1cF9kZXNlcmlhbGl6ZU1lc3NhZ2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNyZWF0ZVByb3h5V2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5V2luZG93O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0b1Byb3h5V2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHVwX3RvUHJveHlXaW5kb3c7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9uXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG9uX29uO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJvbmNlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG9uX29uY2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlbmRcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VuZF9zZW5kO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtYXJrV2luZG93S25vd25cIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbWFya1dpbmRvd0tub3duO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjbGVhblVwV2luZG93XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNsZWFuVXBXaW5kb3c7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJyaWRnZVwiLCAoZnVuY3Rpb24oKSB7fSkpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGlzUmVnZXgoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFJlZ0V4cF1cIiA9PT0ge30udG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIElFX1dJTl9BQ0NFU1NfRVJST1IgPSBcIkNhbGwgd2FzIHJlamVjdGVkIGJ5IGNhbGxlZS5cXHJcXG5cIjtcblx0ICAgICAgICBmdW5jdGlvbiBnZXRBY3R1YWxQcm90b2NvbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW4ubG9jYXRpb24ucHJvdG9jb2w7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFByb3RvY29sKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgaWYgKHdpbi5tb2NrRG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSB3aW4ubW9ja0RvbWFpbi5zcGxpdChcIi8vXCIpWzBdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHByb3RvY29sKSByZXR1cm4gcHJvdG9jb2w7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGdldEFjdHVhbFByb3RvY29sKHdpbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzQWJvdXRQcm90b2NvbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHJldHVybiBcImFib3V0OlwiID09PSBnZXRQcm90b2NvbCh3aW4pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRQYXJlbnQod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICBpZiAod2luKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbi5wYXJlbnQgJiYgd2luLnBhcmVudCAhPT0gd2luKSByZXR1cm4gd2luLnBhcmVudDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRPcGVuZXIod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICBpZiAod2luICYmICFnZXRQYXJlbnQod2luKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB3aW4ub3BlbmVyO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGNhblJlYWRGcm9tV2luZG93KHdpbikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0QWN0dWFsRG9tYWluKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gd2luLmxvY2F0aW9uO1xuXHQgICAgICAgICAgICBpZiAoIWxvY2F0aW9uKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IGxvY2F0aW9uXCIpO1xuXHQgICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBnZXRBY3R1YWxQcm90b2NvbCh3aW4pO1xuXHQgICAgICAgICAgICBpZiAoIXByb3RvY29sKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IHByb3RvY29sXCIpO1xuXHQgICAgICAgICAgICBpZiAoXCJmaWxlOlwiID09PSBwcm90b2NvbCkgcmV0dXJuIFwiZmlsZTovL1wiO1xuXHQgICAgICAgICAgICBpZiAoXCJhYm91dDpcIiA9PT0gcHJvdG9jb2wpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQod2luKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgJiYgY2FuUmVhZEZyb21XaW5kb3coKSA/IGdldEFjdHVhbERvbWFpbihwYXJlbnQpIDogXCJhYm91dDovL1wiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBob3N0ID0gbG9jYXRpb24uaG9zdDtcblx0ICAgICAgICAgICAgaWYgKCFob3N0KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IGhvc3RcIik7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm90b2NvbCArIFwiLy9cIiArIGhvc3Q7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldERvbWFpbih3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXRBY3R1YWxEb21haW4od2luKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGRvbWFpbiAmJiB3aW4ubW9ja0RvbWFpbiAmJiAwID09PSB3aW4ubW9ja0RvbWFpbi5pbmRleE9mKFwibW9jazpcIikgPyB3aW4ubW9ja0RvbWFpbiA6IGRvbWFpbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNTYW1lRG9tYWluKHdpbikge1xuXHQgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAod2luID09PSB3aW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbiwgXCJsb2NhdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiAhMSA9PT0gZGVzYy5lbnVtZXJhYmxlKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc0Fib3V0UHJvdG9jb2wod2luKSAmJiBjYW5SZWFkRnJvbVdpbmRvdygpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1vY2s6XCIgPT09IGdldFByb3RvY29sKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGdldEFjdHVhbERvbWFpbih3aW4pID09PSBnZXRBY3R1YWxEb21haW4od2luZG93KSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB9KHdpbikpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzQWJvdXRQcm90b2NvbCh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIGlmIChnZXREb21haW4od2luZG93KSA9PT0gZ2V0RG9tYWluKHdpbikpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGFzc2VydFNhbWVEb21haW4od2luKSB7XG5cdCAgICAgICAgICAgIGlmICghaXNTYW1lRG9tYWluKHdpbikpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHdpbmRvdyB0byBiZSBzYW1lIGRvbWFpblwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNBbmNlc3RvclBhcmVudChwYXJlbnQsIGNoaWxkKSB7XG5cdCAgICAgICAgICAgIGlmICghcGFyZW50IHx8ICFjaGlsZCkgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRQYXJlbnQgPSBnZXRQYXJlbnQoY2hpbGQpO1xuXHQgICAgICAgICAgICByZXR1cm4gY2hpbGRQYXJlbnQgPyBjaGlsZFBhcmVudCA9PT0gcGFyZW50IDogLTEgIT09IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKDt3aW4ucGFyZW50ICE9PSB3aW47ICkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3aW4ucGFyZW50KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luID0gd2luLnBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICB9KGNoaWxkKS5pbmRleE9mKHBhcmVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYW1lcyh3aW4pIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgZnJhbWVzO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZnJhbWVzID0gd2luLmZyYW1lcztcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBmcmFtZXMgPSB3aW47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGxlbjtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGxlbiA9IGZyYW1lcy5sZW5ndGg7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgaWYgKDAgPT09IGxlbikgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgaWYgKGxlbikge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGZyYW1lc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDEwMDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gZnJhbWVzW19pXTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoIV9mcmFtZSkgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKF9mcmFtZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGlmcmFtZVdpbmRvd3MgPSBbXTtcblx0ICAgICAgICB2YXIgaWZyYW1lRnJhbWVzID0gW107XG5cdCAgICAgICAgZnVuY3Rpb24gaXNXaW5kb3dDbG9zZWQod2luLCBhbGxvd01vY2spIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBhbGxvd01vY2sgJiYgKGFsbG93TW9jayA9ICEwKTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICExO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCF3aW4pIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4uY2xvc2VkKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICFlcnIgfHwgZXJyLm1lc3NhZ2UgIT09IElFX1dJTl9BQ0NFU1NfRVJST1I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGFsbG93TW9jayAmJiBpc1NhbWVEb21haW4od2luKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW4ubW9ja2Nsb3NlZCkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXdpbi5wYXJlbnQgfHwgIXdpbi50b3ApIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB2YXIgaWZyYW1lSW5kZXggPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25baV0gPT09IGl0ZW0pIHJldHVybiBpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICB9KGlmcmFtZVdpbmRvd3MsIHdpbik7XG5cdCAgICAgICAgICAgIGlmICgtMSAhPT0gaWZyYW1lSW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGlmcmFtZUZyYW1lc1tpZnJhbWVJbmRleF07XG5cdCAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgZnVuY3Rpb24oZnJhbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWZyYW1lLmNvbnRlbnRXaW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWZyYW1lLnBhcmVudE5vZGUpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gZnJhbWUub3duZXJEb2N1bWVudDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZG9jICYmIGRvYy5kb2N1bWVudEVsZW1lbnQgJiYgIWRvYy5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZnJhbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBmcmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7cGFyZW50LnBhcmVudE5vZGUgJiYgcGFyZW50LnBhcmVudE5vZGUgIT09IHBhcmVudDsgKSBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQuaG9zdCB8fCAhZG9jLmRvY3VtZW50RWxlbWVudC5jb250YWlucyhwYXJlbnQuaG9zdCkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgfShmcmFtZSkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEFuY2VzdG9yKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGdldE9wZW5lcih3aW4gPSB3aW4gfHwgd2luZG93KSB8fCBnZXRQYXJlbnQod2luKSB8fCB2b2lkIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG1hdGNoRG9tYWluKHBhdHRlcm4sIG9yaWdpbikge1xuXHQgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcGF0dGVybikge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIG9yaWdpbikgcmV0dXJuIFwiKlwiID09PSBwYXR0ZXJuIHx8IG9yaWdpbiA9PT0gcGF0dGVybjtcblx0ICAgICAgICAgICAgICAgIGlmIChpc1JlZ2V4KG9yaWdpbikpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gaXNSZWdleChwYXR0ZXJuKSA/IGlzUmVnZXgob3JpZ2luKSA/IHBhdHRlcm4udG9TdHJpbmcoKSA9PT0gb3JpZ2luLnRvU3RyaW5nKCkgOiAhQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIEJvb2xlYW4ob3JpZ2luLm1hdGNoKHBhdHRlcm4pKSA6ICEhQXJyYXkuaXNBcnJheShwYXR0ZXJuKSAmJiAoQXJyYXkuaXNBcnJheShvcmlnaW4pID8gSlNPTi5zdHJpbmdpZnkocGF0dGVybikgPT09IEpTT04uc3RyaW5naWZ5KG9yaWdpbikgOiAhaXNSZWdleChvcmlnaW4pICYmIHBhdHRlcm4uc29tZSgoZnVuY3Rpb24oc3VicGF0dGVybikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoRG9tYWluKHN1YnBhdHRlcm4sIG9yaWdpbik7XG5cdCAgICAgICAgICAgIH0pKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gd2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiA9PT0ge30udG9TdHJpbmcuY2FsbChvYmopKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luZG93LldpbmRvdyAmJiBvYmogaW5zdGFuY2VvZiB3aW5kb3cuV2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5zZWxmID09PSBvYmopIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnBhcmVudCA9PT0gb2JqKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai50b3AgPT09IG9iaikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBcIl9fdW5saWtlbHlfdmFsdWVfX1wiID09PSBvYmouX19jcm9zc19kb21haW5fdXRpbHNfd2luZG93X2NoZWNrX18pIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChcInBvc3RNZXNzYWdlXCIgaW4gb2JqICYmIFwic2VsZlwiIGluIG9iaiAmJiBcImxvY2F0aW9uXCIgaW4gb2JqKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFtZUZvcldpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSByZXR1cm4gYXNzZXJ0U2FtZURvbWFpbih3aW4pLmZyYW1lRWxlbWVudDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kyMSA9IDAsIF9kb2N1bWVudCRxdWVyeVNlbGVjdDIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaWZyYW1lXCIpOyBfaTIxIDwgX2RvY3VtZW50JHF1ZXJ5U2VsZWN0Mi5sZW5ndGg7IF9pMjErKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX2RvY3VtZW50JHF1ZXJ5U2VsZWN0MltfaTIxXTtcblx0ICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBmcmFtZS5jb250ZW50V2luZG93ICYmIGZyYW1lLmNvbnRlbnRXaW5kb3cgPT09IHdpbikgcmV0dXJuIGZyYW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGNsb3NlV2luZG93KHdpbikge1xuXHQgICAgICAgICAgICBpZiAoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGdldFBhcmVudCh3aW4pKTtcblx0ICAgICAgICAgICAgfSh3aW4pKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBnZXRGcmFtZUZvcldpbmRvdyh3aW4pO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZyYW1lICYmIGZyYW1lLnBhcmVudEVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmcmFtZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGZyYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHdpbi5jbG9zZSgpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHV0aWxzX2lzUHJvbWlzZShpdGVtKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBQcm9taXNlICYmIGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygd2luZG93LldpbmRvdyAmJiBpdGVtIGluc3RhbmNlb2Ygd2luZG93LldpbmRvdykgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbmRvdy5jb25zdHJ1Y3RvciAmJiBpdGVtIGluc3RhbmNlb2Ygd2luZG93LmNvbnN0cnVjdG9yKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICBpZiAoX3RvU3RyaW5nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfdG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiA9PT0gbmFtZSB8fCBcIltvYmplY3QgZ2xvYmFsXVwiID09PSBuYW1lIHx8IFwiW29iamVjdCBET01XaW5kb3ddXCIgPT09IG5hbWUpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZW0udGhlbikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBkaXNwYXRjaGVkRXJyb3JzID0gW107XG5cdCAgICAgICAgdmFyIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzID0gW107XG5cdCAgICAgICAgdmFyIGFjdGl2ZUNvdW50ID0gMDtcblx0ICAgICAgICB2YXIgZmx1c2hQcm9taXNlO1xuXHQgICAgICAgIGZ1bmN0aW9uIGZsdXNoQWN0aXZlKCkge1xuXHQgICAgICAgICAgICBpZiAoIWFjdGl2ZUNvdW50ICYmIGZsdXNoUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmbHVzaFByb21pc2U7XG5cdCAgICAgICAgICAgICAgICBmbHVzaFByb21pc2UgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RhcnRBY3RpdmUoKSB7XG5cdCAgICAgICAgICAgIGFjdGl2ZUNvdW50ICs9IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGVuZEFjdGl2ZSgpIHtcblx0ICAgICAgICAgICAgYWN0aXZlQ291bnQgLT0gMTtcblx0ICAgICAgICAgICAgZmx1c2hBY3RpdmUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHByb21pc2VfWmFsZ29Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIFphbGdvUHJvbWlzZShoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9ICExO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RlZCA9ICExO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSAhMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9lcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSAhMTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSAhMTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaXNBc3luYyA9ICExO1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luYykgX3RoaXMucmVzb2x2ZShyZXMpOyBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQgPSByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luYykgX3RoaXMucmVqZWN0KGVycik7IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdGVkID0gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yID0gZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlzQXN5bmMgPSAhMDtcblx0ICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA/IHRoaXMucmVzb2x2ZShfcmVzdWx0KSA6IHJlamVjdGVkICYmIHRoaXMucmVqZWN0KF9lcnJvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIF9wcm90byA9IFphbGdvUHJvbWlzZS5wcm90b3R5cGU7XG5cdCAgICAgICAgICAgIF9wcm90by5yZXNvbHZlID0gZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmICh1dGlsc19pc1Byb21pc2UocmVzdWx0KSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBhbm90aGVyIHByb21pc2VcIik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gITA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5yZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmICh1dGlsc19pc1Byb21pc2UoZXJyb3IpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlamVjdCBwcm9taXNlIHdpdGggYW5vdGhlciBwcm9taXNlXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfZXJyID0gZXJyb3IgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlcnJvci50b1N0cmluZyA/IGVycm9yLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkV4cGVjdGVkIHJlamVjdCB0byBiZSBjYWxsZWQgd2l0aCBFcnJvciwgZ290IFwiICsgX2Vycik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gITA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCB8fCBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpczIuZXJyb3JIYW5kbGVkIHx8IGZ1bmN0aW9uKGVyciwgcHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IGRpc3BhdGNoZWRFcnJvcnMuaW5kZXhPZihlcnIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVkRXJyb3JzLnB1c2goZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzW2pdKGVyciwgcHJvbWlzZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KGVycm9yLCBfdGhpczIpO1xuXHQgICAgICAgICAgICAgICAgfSksIDEpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5hc3luY1JlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5kaXNwYXRjaCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gdGhpcy5yZXNvbHZlZCwgcmVqZWN0ZWQgPSB0aGlzLnJlamVjdGVkLCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGF0Y2hpbmcgJiYgKHJlc29sdmVkIHx8IHJlamVjdGVkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSAhMDtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFydEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGFpbiA9IGZ1bmN0aW9uKGZpcnN0UHJvbWlzZSwgc2Vjb25kUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaGFuZGxlcnMkaSA9IGhhbmRsZXJzW2ldLCBvblN1Y2Nlc3MgPSBfaGFuZGxlcnMkaS5vblN1Y2Nlc3MsIG9uRXJyb3IgPSBfaGFuZGxlcnMkaS5vbkVycm9yLCBwcm9taXNlID0gX2hhbmRsZXJzJGkucHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQyID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0MiA9IG9uU3VjY2VzcyA/IG9uU3VjY2Vzcyh0aGlzLnZhbHVlKSA6IHRoaXMudmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlamVjdGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9uRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdDIgPSBvbkVycm9yKHRoaXMuZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Jlc3VsdDIgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UgJiYgKF9yZXN1bHQyLnJlc29sdmVkIHx8IF9yZXN1bHQyLnJlamVjdGVkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VSZXN1bHQgPSBfcmVzdWx0Mjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXN1bHQucmVzb2x2ZWQgPyBwcm9taXNlLnJlc29sdmUocHJvbWlzZVJlc3VsdC52YWx1ZSkgOiBwcm9taXNlLnJlamVjdChwcm9taXNlUmVzdWx0LmVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXN1bHQuZXJyb3JIYW5kbGVkID0gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB1dGlsc19pc1Byb21pc2UoX3Jlc3VsdDIpID8gX3Jlc3VsdDIgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UgJiYgKF9yZXN1bHQyLnJlc29sdmVkIHx8IF9yZXN1bHQyLnJlamVjdGVkKSA/IF9yZXN1bHQyLnJlc29sdmVkID8gcHJvbWlzZS5yZXNvbHZlKF9yZXN1bHQyLnZhbHVlKSA6IHByb21pc2UucmVqZWN0KF9yZXN1bHQyLmVycm9yKSA6IGNoYWluKF9yZXN1bHQyLCBwcm9taXNlKSA6IHByb21pc2UucmVzb2x2ZShfcmVzdWx0Mik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmxlbmd0aCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9ICExO1xuXHQgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uKG9uU3VjY2Vzcywgb25FcnJvcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9uU3VjY2VzcyAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uU3VjY2VzcyAmJiAhb25TdWNjZXNzLmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UudGhlbiBleHBlY3RlZCBhIGZ1bmN0aW9uIGZvciBzdWNjZXNzIGhhbmRsZXJcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAob25FcnJvciAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uRXJyb3IgJiYgIW9uRXJyb3IuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS50aGVuIGV4cGVjdGVkIGEgZnVuY3Rpb24gZm9yIGVycm9yIGhhbmRsZXJcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBvblN1Y2Nlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5jYXRjaCA9IGZ1bmN0aW9uKG9uRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCBvbkVycm9yKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmZpbmFsbHkgPSBmdW5jdGlvbihvbkZpbmFsbHkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChvbkZpbmFsbHkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvbkZpbmFsbHkgJiYgIW9uRmluYWxseS5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLmZpbmFsbHkgZXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UudHJ5KG9uRmluYWxseSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnRyeShvbkZpbmFsbHkpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udGltZW91dCA9IGZ1bmN0aW9uKHRpbWUsIGVycikge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMzLnJlc29sdmVkIHx8IF90aGlzMy5yZWplY3RlZCB8fCBfdGhpczMucmVqZWN0KGVyciB8fCBuZXcgRXJyb3IoXCJQcm9taXNlIHRpbWVkIG91dCBhZnRlciBcIiArIHRpbWUgKyBcIm1zXCIpKTtcblx0ICAgICAgICAgICAgICAgIH0pLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udG9Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgUHJvbWlzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvdWxkIG5vdCBmaW5kIFByb21pc2VcIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8ubGF6eSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UgPyB2YWx1ZSA6IHV0aWxzX2lzUHJvbWlzZSh2YWx1ZSkgPyBuZXcgWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHQgICAgICAgICAgICAgICAgfSkpIDogKG5ldyBaYWxnb1Byb21pc2UpLnJlc29sdmUodmFsdWUpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAobmV3IFphbGdvUHJvbWlzZSkucmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmFzeW5jUmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAobmV3IFphbGdvUHJvbWlzZSkuYXN5bmNSZWplY3QoZXJyb3IpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuYWxsID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFphbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHByb21pc2VzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW10uc2xpY2UoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghY291bnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbihpLCBmaXJzdFByb21pc2UsIHNlY29uZFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RQcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAwID09IChjb3VudCAtPSAxKSAmJiBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9tID0gcHJvbWlzZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb20gaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb20ucmVzb2x2ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBwcm9tLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgLT0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdXRpbHNfaXNQcm9taXNlKHByb20pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBwcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhaW4oaSwgWmFsZ29Qcm9taXNlLnJlc29sdmUocHJvbSksIHByb21pc2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgMCA9PT0gY291bnQgJiYgcHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5oYXNoID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgICAgICAgICAgICAgIHZhciBhd2FpdFByb21pc2VzID0gW107XG5cdCAgICAgICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9taXNlc1trZXldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1dGlsc19pc1Byb21pc2UodmFsdWUpID8gYXdhaXRQcm9taXNlcy5wdXNoKHZhbHVlLnRoZW4oKGZ1bmN0aW9uKHJlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKSkgOiByZXN1bHRba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvbWlzZXMpIF9sb29wKGtleSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLmFsbChhd2FpdFByb21pc2VzKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UubWFwID0gZnVuY3Rpb24oaXRlbXMsIG1ldGhvZCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5hbGwoaXRlbXMubWFwKG1ldGhvZCkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMuc3BsaWNlKHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLmluZGV4T2YoaGFuZGxlciksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0oaGFuZGxlcik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS50cnkgPSBmdW5jdGlvbihtZXRob2QsIGNvbnRleHQsIGFyZ3MpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChtZXRob2QgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBtZXRob2QgJiYgIW1ldGhvZC5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRyeSBleHBlY3RlZCBhIGZ1bmN0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0QWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzIHx8IFtdKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuZGVsYXkgPSBmdW5jdGlvbihfZGVsYXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBfZGVsYXkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuaXNQcm9taXNlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSkgfHwgdXRpbHNfaXNQcm9taXNlKHZhbHVlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oWmFsZ28pIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZsdXNoUHJvbWlzZSA9IGZsdXNoUHJvbWlzZSB8fCBuZXcgWmFsZ287XG5cdCAgICAgICAgICAgICAgICAgICAgZmx1c2hBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH0oWmFsZ29Qcm9taXNlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZTtcblx0ICAgICAgICB9KCk7XG5cdCAgICAgICAgZnVuY3Rpb24gdXRpbF9zYWZlSW5kZXhPZihjb2xsZWN0aW9uLCBpdGVtKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09PSBpdGVtKSByZXR1cm4gaTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB3ZWFrbWFwX0Nyb3NzRG9tYWluU2FmZVdlYWtNYXAgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gQ3Jvc3NEb21haW5TYWZlV2Vha01hcCgpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMud2Vha21hcCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMua2V5cyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gXCJfX3dlYWttYXBfXCIgKyAoMWU5ICogTWF0aC5yYW5kb20oKSA+Pj4gMCkgKyBcIl9fXCI7XG5cdCAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIFdlYWtNYXApIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBPYmplY3QuZnJlZXplKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RXZWFrTWFwID0gbmV3IFdlYWtNYXA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0S2V5ID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGVzdEtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RXZWFrTWFwLnNldCh0ZXN0S2V5LCBcIl9fdGVzdHZhbHVlX19cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIl9fdGVzdHZhbHVlX19cIiA9PT0gdGVzdFdlYWtNYXAuZ2V0KHRlc3RLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSgpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMud2Vha21hcCA9IG5ldyBXZWFrTWFwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5rZXlzID0gW107XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcHJvdG8gPSBDcm9zc0RvbWFpblNhZmVXZWFrTWFwLnByb3RvdHlwZTtcblx0ICAgICAgICAgICAgX3Byb3RvLl9jbGVhbnVwQ2xvc2VkV2luZG93cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGtleXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93KHZhbHVlKSAmJiBpc1dpbmRvd0Nsb3NlZCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLmRlbGV0ZSh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmlzU2FmZVRvUmVhZFdyaXRlID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gIWlzV2luZG93KGtleSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHdlYWttYXAuc2V0KGtleSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W25hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA9IHZhbHVlIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KGtleSwgbmFtZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHV0aWxfc2FmZUluZGV4T2Yoa2V5cywga2V5KTtcblx0ICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gaW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwLmhhcyhrZXkpKSByZXR1cm4gd2Vha21hcC5nZXQoa2V5KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gOiB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdXRpbF9zYWZlSW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoLTEgIT09IGluZGV4KSByZXR1cm4gdGhpcy52YWx1ZXNbaW5kZXhdO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZGVsZXRlID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHdlYWttYXAuZGVsZXRlKGtleSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ICYmIChlbnRyeVswXSA9IGVudHJ5WzFdID0gdm9pZCAwKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHV0aWxfc2FmZUluZGV4T2Yoa2V5cywga2V5KTtcblx0ICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcC5oYXMoa2V5KSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEoIWVudHJ5IHx8IGVudHJ5WzBdICE9PSBrZXkpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAtMSAhPT0gdXRpbF9zYWZlSW5kZXhPZih0aGlzLmtleXMsIGtleSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRPclNldCA9IGZ1bmN0aW9uKGtleSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcblx0ICAgICAgICB9KCk7XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmbi5uYW1lIHx8IGZuLl9fbmFtZV9fIHx8IGZuLmRpc3BsYXlOYW1lIHx8IFwiYW5vbnltb3VzXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNldEZ1bmN0aW9uTmFtZShmbiwgbmFtZSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGZuLm5hbWU7XG5cdCAgICAgICAgICAgICAgICBmbi5uYW1lID0gbmFtZTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICBmbi5fX25hbWVfXyA9IGZuLmRpc3BsYXlOYW1lID0gbmFtZTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiB1bmlxdWVJRCgpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5cdCAgICAgICAgICAgIHJldHVybiBcInVpZF9cIiArIFwieHh4eHh4eHh4eFwiLnJlcGxhY2UoLy4vZywgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcblx0ICAgICAgICAgICAgfSkpICsgXCJfXCIgKyBmdW5jdGlvbihzdHIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGJ0b2EpIHJldHVybiBidG9hKGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoLyUoWzAtOUEtRl17Mn0pL2csIChmdW5jdGlvbihtLCBwMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHAxLCAxNikpO1xuXHQgICAgICAgICAgICAgICAgfSkpKS5yZXBsYWNlKC9bPV0vZywgXCJcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQnVmZmVyKSByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcInV0ZjhcIikudG9TdHJpbmcoXCJiYXNlNjRcIikucmVwbGFjZSgvWz1dL2csIFwiXCIpO1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIHdpbmRvdy5idG9hIG9yIEJ1ZmZlclwiKTtcblx0ICAgICAgICAgICAgfSgobmV3IERhdGUpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMTEsIDE5KS5yZXBsYWNlKFwiVFwiLCBcIi5cIikpLnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgb2JqZWN0SURzO1xuXHQgICAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUFyZ3MoYXJncykge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtdLnNsaWNlLmNhbGwoYXJncyksIChmdW5jdGlvbihzdWJrZXksIHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHZhbCA/IFwibWVtb2l6ZVtcIiArIGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMgPSBvYmplY3RJRHMgfHwgbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gb2JqIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIG9iaiAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9iaikgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvYmplY3RcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1aWQgPSBvYmplY3RJRHMuZ2V0KG9iaik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdWlkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQgPSB0eXBlb2Ygb2JqICsgXCI6XCIgKyB1bmlxdWVJRCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SURzLnNldChvYmosIHVpZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVpZDtcblx0ICAgICAgICAgICAgICAgICAgICB9KHZhbCkgKyBcIl1cIiA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiB2YWwgaW5zdGFuY2VvZiB3aW5kb3cuRWxlbWVudCB8fCBudWxsICE9PSB2YWwgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsICYmIDEgPT09IHZhbC5ub2RlVHlwZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiB2YWwuc3R5bGUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsLm93bmVyRG9jdW1lbnQgPyB7fSA6IHZhbDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudHMgbm90IHNlcmlhbGl6YWJsZSAtLSBjYW4gbm90IGJlIHVzZWQgdG8gbWVtb2l6ZVwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRFbXB0eU9iamVjdCgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbWVtb2l6ZUdsb2JhbEluZGV4ID0gMDtcblx0ICAgICAgICB2YXIgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tID0gMDtcblx0ICAgICAgICBmdW5jdGlvbiBtZW1vaXplKG1ldGhvZCwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IG9wdGlvbnMgJiYgKG9wdGlvbnMgPSB7fSk7XG5cdCAgICAgICAgICAgIHZhciBfb3B0aW9ucyR0aGlzTmFtZXNwYWMgPSBvcHRpb25zLnRoaXNOYW1lc3BhY2UsIHRoaXNOYW1lc3BhY2UgPSB2b2lkIDAgIT09IF9vcHRpb25zJHRoaXNOYW1lc3BhYyAmJiBfb3B0aW9ucyR0aGlzTmFtZXNwYWMsIGNhY2hlVGltZSA9IG9wdGlvbnMudGltZTtcblx0ICAgICAgICAgICAgdmFyIHNpbXBsZUNhY2hlO1xuXHQgICAgICAgICAgICB2YXIgdGhpc0NhY2hlO1xuXHQgICAgICAgICAgICB2YXIgbWVtb2l6ZUluZGV4ID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuXHQgICAgICAgICAgICBtZW1vaXplR2xvYmFsSW5kZXggKz0gMTtcblx0ICAgICAgICAgICAgdmFyIG1lbW9pemVkRnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgICAgICAgICAgICAgIGlmIChtZW1vaXplSW5kZXggPCBtZW1vaXplR2xvYmFsSW5kZXhWYWxpZEZyb20pIHtcblx0ICAgICAgICAgICAgICAgICAgICBzaW1wbGVDYWNoZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc0NhY2hlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICBtZW1vaXplSW5kZXggPSBtZW1vaXplR2xvYmFsSW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4ICs9IDE7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY2FjaGU7XG5cdCAgICAgICAgICAgICAgICBjYWNoZSA9IHRoaXNOYW1lc3BhY2UgPyAodGhpc0NhY2hlID0gdGhpc0NhY2hlIHx8IG5ldyB3ZWFrbWFwX0Nyb3NzRG9tYWluU2FmZVdlYWtNYXApLmdldE9yU2V0KHRoaXMsIGdldEVtcHR5T2JqZWN0KSA6IHNpbXBsZUNhY2hlID0gc2ltcGxlQ2FjaGUgfHwge307XG5cdCAgICAgICAgICAgICAgICB2YXIgY2FjaGVLZXk7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5ID0gc2VyaWFsaXplQXJncyhhcmdzKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgY2FjaGVSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FjaGVSZXN1bHQgJiYgY2FjaGVUaW1lICYmIERhdGUubm93KCkgLSBjYWNoZVJlc3VsdC50aW1lIDwgY2FjaGVUaW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2NhY2hlS2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYWNoZVJlc3VsdCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FjaGVSZXN1bHQpIHJldHVybiBjYWNoZVJlc3VsdC52YWx1ZTtcblx0ICAgICAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBtZW1vaXplZEZ1bmN0aW9uLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBzaW1wbGVDYWNoZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB0aGlzQ2FjaGUgPSBudWxsO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0RnVuY3Rpb25OYW1lKG1lbW9pemVkRnVuY3Rpb24sIChvcHRpb25zLm5hbWUgfHwgZ2V0RnVuY3Rpb25OYW1lKG1ldGhvZCkpICsgXCI6Om1lbW9pemVkXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtZW1vaXplLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIG1lbW9pemVHbG9iYWxJbmRleFZhbGlkRnJvbSA9IG1lbW9pemVHbG9iYWxJbmRleDtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIG1lbW9pemVQcm9taXNlKG1ldGhvZCkge1xuXHQgICAgICAgICAgICB2YXIgY2FjaGUgPSB7fTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cywgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5ID0gc2VyaWFsaXplQXJncyhhcmdzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gY2FjaGVba2V5XTtcblx0ICAgICAgICAgICAgICAgIGNhY2hlW2tleV0gPSBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoX3RoaXMsIF9hcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgfSkpLmZpbmFsbHkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24ucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGNhY2hlID0ge307XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBzZXRGdW5jdGlvbk5hbWUobWVtb2l6ZWRQcm9taXNlRnVuY3Rpb24sIGdldEZ1bmN0aW9uTmFtZShtZXRob2QpICsgXCI6OnByb21pc2VNZW1vaXplZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3JjX3V0aWxfbm9vcCgpIHt9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyLCBsZXZlbCkge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGxldmVsICYmIChsZXZlbCA9IDEpO1xuXHQgICAgICAgICAgICBpZiAobGV2ZWwgPj0gMykgcmV0dXJuIFwic3RyaW5naWZ5RXJyb3Igc3RhY2sgb3ZlcmZsb3dcIjtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghZXJyKSByZXR1cm4gXCI8dW5rbm93biBlcnJvcjogXCIgKyB7fS50b1N0cmluZy5jYWxsKGVycikgKyBcIj5cIjtcblx0ICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlcnIpIHJldHVybiBlcnI7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnIgJiYgZXJyLnN0YWNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyICYmIGVyci5tZXNzYWdlO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjayAmJiBtZXNzYWdlKSByZXR1cm4gLTEgIT09IHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPyBzdGFjayA6IG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrKSByZXR1cm4gc3RhY2s7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHJldHVybiBtZXNzYWdlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGVyciAmJiBlcnIudG9TdHJpbmcgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlcnIudG9TdHJpbmcgPyBlcnIudG9TdHJpbmcoKSA6IHt9LnRvU3RyaW5nLmNhbGwoZXJyKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAobmV3RXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvciB3aGlsZSBzdHJpbmdpZnlpbmcgZXJyb3I6IFwiICsgc3RyaW5naWZ5RXJyb3IobmV3RXJyLCBsZXZlbCArIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBpdGVtID8gaXRlbSA6IGl0ZW0gJiYgaXRlbS50b1N0cmluZyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZW0udG9TdHJpbmcgPyBpdGVtLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtZW1vaXplKChmdW5jdGlvbihvYmopIHtcblx0ICAgICAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMpIHJldHVybiBPYmplY3QudmFsdWVzKG9iaik7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgb2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgcmVzdWx0LnB1c2gob2JqW2tleV0pO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBmdW5jdGlvbiB1dGlsX2lzUmVnZXgoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFJlZ0V4cF1cIiA9PT0ge30udG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gdXRpbF9nZXRPclNldChvYmosIGtleSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuIG9ialtrZXldO1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gZ2V0dGVyKCk7XG5cdCAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuXHQgICAgICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cdCAgICAgICAgICAgIGlmICghYm9keSkgdGhyb3cgbmV3IEVycm9yKFwiQm9keSBlbGVtZW50IG5vdCBmb3VuZFwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRSZWFkeSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZG9jdW1lbnQuYm9keSkgJiYgXCJjb21wbGV0ZVwiID09PSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc0RvY3VtZW50SW50ZXJhY3RpdmUoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGRvY3VtZW50LmJvZHkpICYmIFwiaW50ZXJhY3RpdmVcIiA9PT0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbWVtb2l6ZSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpc0RvY3VtZW50UmVhZHkoKSB8fCBpc0RvY3VtZW50SW50ZXJhY3RpdmUoKSkgcmV0dXJuIHJlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudFJlYWR5KCkgfHwgaXNEb2N1bWVudEludGVyYWN0aXZlKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSksIDEwKTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICB2YXIgY3VycmVudFNjcmlwdCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGRvY3VtZW50ID8gZG9jdW1lbnQuY3VycmVudFNjcmlwdCA6IG51bGw7XG5cdCAgICAgICAgdmFyIGdldEN1cnJlbnRTY3JpcHQgPSBtZW1vaXplKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRTY3JpcHQpIHJldHVybiBjdXJyZW50U2NyaXB0O1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudFNjcmlwdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyci5zdGFjayB8fCBcIlwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFja0RldGFpbHMgPSAvLiphdCBbXihdKlxcKCguKik6KC4rKTooLispXFwpJC9naS5leGVjKHN0YWNrKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0TG9jYXRpb24gPSBzdGFja0RldGFpbHMgJiYgc3RhY2tEZXRhaWxzWzFdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2NyaXB0TG9jYXRpb24pIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIyID0gMCwgX0FycmF5JHByb3RvdHlwZSRzbGljMiA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIikpLnJldmVyc2UoKTsgX2kyMiA8IF9BcnJheSRwcm90b3R5cGUkc2xpYzIubGVuZ3RoOyBfaTIyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcmlwdCA9IF9BcnJheSRwcm90b3R5cGUkc2xpYzJbX2kyMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JpcHQuc3JjICYmIHNjcmlwdC5zcmMgPT09IHNjcmlwdExvY2F0aW9uKSByZXR1cm4gc2NyaXB0O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfSgpKSByZXR1cm4gY3VycmVudFNjcmlwdDtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXRlcm1pbmUgY3VycmVudCBzY3JpcHRcIik7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIHZhciBjdXJyZW50VUlEID0gdW5pcXVlSUQoKTtcblx0ICAgICAgICBtZW1vaXplKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHNjcmlwdDtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHNjcmlwdCA9IGdldEN1cnJlbnRTY3JpcHQoKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFVJRDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgdWlkID0gc2NyaXB0LmdldEF0dHJpYnV0ZShcImRhdGEtdWlkXCIpO1xuXHQgICAgICAgICAgICBpZiAodWlkICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHVpZCkgcmV0dXJuIHVpZDtcblx0ICAgICAgICAgICAgaWYgKCh1aWQgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS11aWQtYXV0b1wiKSkgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdWlkKSByZXR1cm4gdWlkO1xuXHQgICAgICAgICAgICBpZiAoc2NyaXB0LnNyYykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGhhc2hlZFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSBzdHJbaV0uY2hhckNvZGVBdCgwKSAqIGk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0cltpICsgMV0gJiYgKHRvdGFsICs9IHN0cltpICsgMV0uY2hhckNvZGVBdCgwKSAqIChpIC0gMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBNYXRoLmFicyh0b3RhbCkgJSAyNik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgICAgICAgICAgfShKU09OLnN0cmluZ2lmeSh7XG5cdCAgICAgICAgICAgICAgICAgICAgc3JjOiBzY3JpcHQuc3JjLFxuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFzZXQ6IHNjcmlwdC5kYXRhc2V0XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB1aWQgPSBcInVpZF9cIiArIGhhc2hlZFN0cmluZy5zbGljZShoYXNoZWRTdHJpbmcubGVuZ3RoIC0gMzApO1xuXHQgICAgICAgICAgICB9IGVsc2UgdWlkID0gdW5pcXVlSUQoKTtcblx0ICAgICAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZShcImRhdGEtdWlkLWF1dG9cIiwgdWlkKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHVpZDtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgZnVuY3Rpb24gZ2xvYmFsX2dldEdsb2JhbCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHZhciBnbG9iYWxLZXkgPSBcIl9fcG9zdF9yb2JvdF8xMF8wXzQ2X19cIjtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbiAhPT0gd2luZG93ID8gd2luW2dsb2JhbEtleV0gOiB3aW5bZ2xvYmFsS2V5XSA9IHdpbltnbG9iYWxLZXldIHx8IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZ2V0T2JqID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIGdsb2JhbFN0b3JlKGtleSwgZGVmU3RvcmUpIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBrZXkgJiYgKGtleSA9IFwic3RvcmVcIik7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVmU3RvcmUgJiYgKGRlZlN0b3JlID0gZ2V0T2JqKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoZ2xvYmFsX2dldEdsb2JhbCgpLCBrZXksIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IGRlZlN0b3JlKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24oc3RvcmVLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmhhc093blByb3BlcnR5KHN0b3JlS2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oc3RvcmVLZXksIGRlZlZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuaGFzT3duUHJvcGVydHkoc3RvcmVLZXkpID8gc3RvcmVbc3RvcmVLZXldIDogZGVmVmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihzdG9yZUtleSwgdmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW3N0b3JlS2V5XSA9IHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGRlbDogZnVuY3Rpb24oc3RvcmVLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0b3JlW3N0b3JlS2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldE9yU2V0OiBmdW5jdGlvbihzdG9yZUtleSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsX2dldE9yU2V0KHN0b3JlLCBzdG9yZUtleSwgZ2V0dGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSBkZWZTdG9yZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhzdG9yZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgV2lsZENhcmQgPSBmdW5jdGlvbigpIHt9O1xuXHQgICAgICAgIGZ1bmN0aW9uIGdldFdpbGRjYXJkKCkge1xuXHQgICAgICAgICAgICB2YXIgZ2xvYmFsID0gZ2xvYmFsX2dldEdsb2JhbCgpO1xuXHQgICAgICAgICAgICBnbG9iYWwuV0lORE9XX1dJTERDQVJEID0gZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCB8fCBuZXcgV2lsZENhcmQ7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWwuV0lORE9XX1dJTERDQVJEO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiB3aW5kb3dTdG9yZShrZXksIGRlZlN0b3JlKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0ga2V5ICYmIChrZXkgPSBcInN0b3JlXCIpO1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGRlZlN0b3JlICYmIChkZWZTdG9yZSA9IGdldE9iaik7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcIndpbmRvd1N0b3JlXCIpLmdldE9yU2V0KGtleSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpblN0b3JlID0gbmV3IHdlYWttYXBfQ3Jvc3NEb21haW5TYWZlV2Vha01hcDtcblx0ICAgICAgICAgICAgICAgIHZhciBnZXRTdG9yZSA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5TdG9yZS5nZXRPclNldCh3aW4sIGRlZlN0b3JlKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhczogZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRTdG9yZSh3aW4pLmhhc093blByb3BlcnR5KGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKHdpbiwgZGVmVmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IGdldFN0b3JlKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShrZXkpID8gc3RvcmVba2V5XSA6IGRlZlZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24od2luLCB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RvcmUod2luKVtrZXldID0gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsOiBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdldFN0b3JlKHdpbilba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldE9yU2V0OiBmdW5jdGlvbih3aW4sIGdldHRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF9nZXRPclNldChnZXRTdG9yZSh3aW4pLCBrZXksIGdldHRlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRJbnN0YW5jZUlEKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJpbnN0YW5jZVwiKS5nZXRPclNldChcImluc3RhbmNlSURcIiwgdW5pcXVlSUQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiByZXNvbHZlSGVsbG9Qcm9taXNlKHdpbiwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgZG9tYWluID0gX3JlZi5kb21haW47XG5cdCAgICAgICAgICAgIHZhciBoZWxsb1Byb21pc2VzID0gd2luZG93U3RvcmUoXCJoZWxsb1Byb21pc2VzXCIpO1xuXHQgICAgICAgICAgICB2YXIgZXhpc3RpbmdQcm9taXNlID0gaGVsbG9Qcm9taXNlcy5nZXQod2luKTtcblx0ICAgICAgICAgICAgZXhpc3RpbmdQcm9taXNlICYmIGV4aXN0aW5nUHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB2YXIgbmV3UHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUoe1xuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGhlbGxvUHJvbWlzZXMuc2V0KHdpbiwgbmV3UHJvbWlzZSk7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXdQcm9taXNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzYXlIZWxsbyh3aW4sIF9yZWY0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoMCwgX3JlZjQuc2VuZCkod2luLCBcInBvc3Ryb2JvdF9oZWxsb1wiLCB7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBnZXRJbnN0YW5jZUlEKClcblx0ICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBcIipcIixcblx0ICAgICAgICAgICAgICAgIHRpbWVvdXQ6IC0xXG5cdCAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gX3JlZjUub3JpZ2luLCBpbnN0YW5jZUlEID0gX3JlZjUuZGF0YS5pbnN0YW5jZUlEO1xuXHQgICAgICAgICAgICAgICAgcmVzb2x2ZUhlbGxvUHJvbWlzZSh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpblxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSUQ6IGluc3RhbmNlSURcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0V2luZG93SW5zdGFuY2VJRCh3aW4sIF9yZWY2KSB7XG5cdCAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjYuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwid2luZG93SW5zdGFuY2VJRFByb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNheUhlbGxvKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY3KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY3Lmluc3RhbmNlSUQ7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gbWFya1dpbmRvd0tub3duKHdpbikge1xuXHQgICAgICAgICAgICB3aW5kb3dTdG9yZShcImtub3duV2luZG93c1wiKS5zZXQod2luLCAhMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzU2VyaWFsaXplZFR5cGUoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgaXRlbSAmJiBudWxsICE9PSBpdGVtICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGl0ZW0uX190eXBlX187XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGRldGVybWluZVR5cGUodmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHZhbCA/IFwidW5kZWZpbmVkXCIgOiBudWxsID09PSB2YWwgPyBcIm51bGxcIiA6IEFycmF5LmlzQXJyYXkodmFsKSA/IFwiYXJyYXlcIiA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gXCJmdW5jdGlvblwiIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsID8gdmFsIGluc3RhbmNlb2YgRXJyb3IgPyBcImVycm9yXCIgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHZhbC50aGVuID8gXCJwcm9taXNlXCIgOiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKHZhbCkgPyBcInJlZ2V4XCIgOiBcIltvYmplY3QgRGF0ZV1cIiA9PT0ge30udG9TdHJpbmcuY2FsbCh2YWwpID8gXCJkYXRlXCIgOiBcIm9iamVjdFwiIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsID8gXCJzdHJpbmdcIiA6IFwibnVtYmVyXCIgPT0gdHlwZW9mIHZhbCA/IFwibnVtYmVyXCIgOiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgdmFsID8gXCJib29sZWFuXCIgOiB2b2lkIDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVR5cGUodHlwZSwgdmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBfX3R5cGVfXzogdHlwZSxcblx0ICAgICAgICAgICAgICAgIF9fdmFsX186IHZhbFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgX1NFUklBTElaRVI7XG5cdCAgICAgICAgdmFyIFNFUklBTElaRVIgPSAoKF9TRVJJQUxJWkVSID0ge30pLmZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7fSwgX1NFUklBTElaRVIuZXJyb3IgPSBmdW5jdGlvbihfcmVmKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwiZXJyb3JcIiwge1xuXHQgICAgICAgICAgICAgICAgbWVzc2FnZTogX3JlZi5tZXNzYWdlLFxuXHQgICAgICAgICAgICAgICAgc3RhY2s6IF9yZWYuc3RhY2ssXG5cdCAgICAgICAgICAgICAgICBjb2RlOiBfcmVmLmNvZGUsXG5cdCAgICAgICAgICAgICAgICBkYXRhOiBfcmVmLmRhdGFcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIucHJvbWlzZSA9IGZ1bmN0aW9uKCkge30sIF9TRVJJQUxJWkVSLnJlZ2V4ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlKFwicmVnZXhcIiwgdmFsLnNvdXJjZSk7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIuZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImRhdGVcIiwgdmFsLnRvSlNPTigpKTtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5hcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLm9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLnN0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLm51bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLmJvb2xlYW4gPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5udWxsID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVJbdm9pZCAwXSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcInVuZGVmaW5lZFwiLCB2YWwpO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSKTtcblx0ICAgICAgICB2YXIgZGVmYXVsdFNlcmlhbGl6ZXJzID0ge307XG5cdCAgICAgICAgdmFyIF9ERVNFUklBTElaRVI7XG5cdCAgICAgICAgdmFyIERFU0VSSUFMSVpFUiA9ICgoX0RFU0VSSUFMSVpFUiA9IHt9KS5mdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBzZXJpYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZDsgbm90aGluZyB0byBkZXNlcmlhbGl6ZVwiKTtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmVycm9yID0gZnVuY3Rpb24oX3JlZjIpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YWNrID0gX3JlZjIuc3RhY2ssIGNvZGUgPSBfcmVmMi5jb2RlLCBkYXRhID0gX3JlZjIuZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKF9yZWYyLm1lc3NhZ2UpO1xuXHQgICAgICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcblx0ICAgICAgICAgICAgZGF0YSAmJiAoZXJyb3IuZGF0YSA9IGRhdGEpO1xuXHQgICAgICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrICsgXCJcXG5cXG5cIiArIGVycm9yLnN0YWNrO1xuXHQgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5wcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb21pc2Ugc2VyaWFsaXphdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQ7IG5vdGhpbmcgdG8gZGVzZXJpYWxpemVcIik7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5yZWdleCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh2YWwpO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsKTtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmFycmF5ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLnN0cmluZyA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIubnVtYmVyID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5ib29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5udWxsID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUlt2b2lkIDBdID0gZnVuY3Rpb24oKSB7fSwgX0RFU0VSSUFMSVpFUik7XG5cdCAgICAgICAgdmFyIGRlZmF1bHREZXNlcmlhbGl6ZXJzID0ge307XG5cdCAgICAgICAgbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKChmdW5jdGlvbihyZXNvbHZlKSB7XG5cdCAgICAgICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmJvZHkpIHJldHVybiByZXNvbHZlKHdpbmRvdy5kb2N1bWVudC5ib2R5KTtcblx0ICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHdpbmRvdy5kb2N1bWVudC5ib2R5KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSksIDEwKTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgZnVuY3Rpb24gY2xlYW51cFByb3h5V2luZG93cygpIHtcblx0ICAgICAgICAgICAgdmFyIGlkVG9Qcm94eVdpbmRvdyA9IGdsb2JhbFN0b3JlKFwiaWRUb1Byb3h5V2luZG93XCIpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfaWRUb1Byb3h5V2luZG93JGtleXMyID0gaWRUb1Byb3h5V2luZG93LmtleXMoKTsgX2kyIDwgX2lkVG9Qcm94eVdpbmRvdyRrZXlzMi5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaWQgPSBfaWRUb1Byb3h5V2luZG93JGtleXMyW19pMl07XG5cdCAgICAgICAgICAgICAgICBpZFRvUHJveHlXaW5kb3cuZ2V0KGlkKS5zaG91bGRDbGVhbigpICYmIGlkVG9Qcm94eVdpbmRvdy5kZWwoaWQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFNlcmlhbGl6ZWRXaW5kb3cod2luUHJvbWlzZSwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYuc2VuZCwgX3JlZiRpZCA9IF9yZWYuaWQsIGlkID0gdm9pZCAwID09PSBfcmVmJGlkID8gdW5pcXVlSUQoKSA6IF9yZWYkaWQ7XG5cdCAgICAgICAgICAgIHZhciB3aW5kb3dOYW1lUHJvbWlzZSA9IHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNTYW1lRG9tYWluKHdpbikpIHJldHVybiBhc3NlcnRTYW1lRG9tYWluKHdpbikubmFtZTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB2YXIgd2luZG93VHlwZVByb21pc2UgPSB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbmRvdykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbmRvdykpIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBpcyBjbG9zZWQsIGNhbiBub3QgZGV0ZXJtaW5lIHR5cGVcIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T3BlbmVyKHdpbmRvdykgPyBcInBvcHVwXCIgOiBcImlmcmFtZVwiO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHdpbmRvd05hbWVQcm9taXNlLmNhdGNoKHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgICAgICB3aW5kb3dUeXBlUHJvbWlzZS5jYXRjaChzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICAgICAgdmFyIGdldE5hbWUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghaXNXaW5kb3dDbG9zZWQod2luKSkgcmV0dXJuIGlzU2FtZURvbWFpbih3aW4pID8gYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWUgOiB3aW5kb3dOYW1lUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIGlkOiBpZCxcblx0ICAgICAgICAgICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dUeXBlUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBnZXRJbnN0YW5jZUlEOiBtZW1vaXplUHJvbWlzZSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRXaW5kb3dJbnN0YW5jZUlEKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSksXG5cdCAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbihjbG9zZVdpbmRvdyk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgZ2V0TmFtZTogZ2V0TmFtZSxcblx0ICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luLmZvY3VzKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGlzQ2xvc2VkOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzV2luZG93Q2xvc2VkKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHNldExvY2F0aW9uOiBmdW5jdGlvbihocmVmLCBvcHRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBvcHRzICYmIChvcHRzID0ge30pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfb3B0cyRtZXRob2QgPSBvcHRzLm1ldGhvZCwgbWV0aG9kID0gdm9pZCAwID09PSBfb3B0cyRtZXRob2QgPyBcImdldFwiIDogX29wdHMkbWV0aG9kLCBib2R5ID0gb3B0cy5ib2R5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gaHJlZi5pbmRleE9mKFwiL1wiKSkgaHJlZiA9IFwiXCIgKyBkb21haW4gKyBocmVmOyBlbHNlIGlmICghaHJlZi5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vKSAmJiAwICE9PSBocmVmLmluZGV4T2YoZG9tYWluKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdXJsIHRvIGJlIGh0dHAgb3IgaHR0cHMgdXJsLCBvciBhYnNvbHV0ZSBwYXRoLCBnb3QgXCIgKyBKU09OLnN0cmluZ2lmeShocmVmKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInBvc3RcIiA9PT0gbWV0aG9kKSByZXR1cm4gZ2V0TmFtZSgpLnRoZW4oKGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBwb3N0IHRvIHdpbmRvdyB3aXRob3V0IHRhcmdldCBuYW1lXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKF9yZWYzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IF9yZWYzLnVybCwgdGFyZ2V0ID0gX3JlZjMudGFyZ2V0LCBib2R5ID0gX3JlZjMuYm9keSwgX3JlZjMkbWV0aG9kID0gX3JlZjMubWV0aG9kLCBtZXRob2QgPSB2b2lkIDAgPT09IF9yZWYzJG1ldGhvZCA/IFwicG9zdFwiIDogX3JlZjMkbWV0aG9kO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgdGFyZ2V0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZShcIm1ldGhvZFwiLCBtZXRob2QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwiYWN0aW9uXCIsIHVybCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkpIGZvciAodmFyIF9pMjQgPSAwLCBfT2JqZWN0JGtleXM0ID0gT2JqZWN0LmtleXMoYm9keSk7IF9pMjQgPCBfT2JqZWN0JGtleXM0Lmxlbmd0aDsgX2kyNCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYm9keSRrZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXM0W19pMjRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwga2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgbnVsbCA9PSAoX2JvZHkka2V5ID0gYm9keVtrZXldKSA/IHZvaWQgMCA6IF9ib2R5JGtleS50b1N0cmluZygpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChpbnB1dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJvZHkoKS5hcHBlbmRDaGlsZChmb3JtKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJvZHkoKS5yZW1vdmVDaGlsZChmb3JtKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogaHJlZixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZ2V0XCIgIT09IG1ldGhvZCkgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgbWV0aG9kOiBcIiArIG1ldGhvZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWVEb21haW4od2luKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4ubG9jYXRpb24gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB3aW4ubG9jYXRpb24ucmVwbGFjZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW4ubG9jYXRpb24gPSBocmVmO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBzZXROYW1lOiBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYW1lRG9tYWluID0gaXNTYW1lRG9tYWluKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGdldEZyYW1lRm9yV2luZG93KHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2FtZURvbWFpbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZXQgbmFtZSBmb3IgY3Jvc3MtZG9tYWluIHdpbmRvdzogXCIgKyBuYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWUgPSBuYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZSAmJiBmcmFtZS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dOYW1lUHJvbWlzZSA9IHByb21pc2VfWmFsZ29Qcm9taXNlLnJlc29sdmUobmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgd2luZG93X1Byb3h5V2luZG93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIFByb3h5V2luZG93KF9yZWYyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYyLnNlbmQsIHdpbiA9IF9yZWYyLndpbiwgc2VyaWFsaXplZFdpbmRvdyA9IF9yZWYyLnNlcmlhbGl6ZWRXaW5kb3c7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlkID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pc1Byb3h5V2luZG93ID0gITA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvdyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VuZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZFdpbmRvdyA9IHNlcmlhbGl6ZWRXaW5kb3cgfHwgZ2V0U2VyaWFsaXplZFdpbmRvdyh0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwiaWRUb1Byb3h5V2luZG93XCIpLnNldCh0aGlzLmdldElEKCksIHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgd2luICYmIHRoaXMuc2V0V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcHJvdG8gPSBQcm94eVdpbmRvdy5wcm90b3R5cGU7XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRJRCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5pZDtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldFR5cGUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZ2V0VHlwZSgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uaXNQb3B1cCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnRoZW4oKGZ1bmN0aW9uKHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwb3B1cFwiID09PSB0eXBlO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2V0TG9jYXRpb24gPSBmdW5jdGlvbihocmVmLCBvcHRzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5zZXRMb2NhdGlvbihocmVmLCBvcHRzKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXROYW1lID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldE5hbWUoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNldE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuc2V0TmFtZShuYW1lKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5jbG9zZSgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczM7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgaXNQb3B1cFByb21pc2UgPSB0aGlzLmlzUG9wdXAoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBnZXROYW1lUHJvbWlzZSA9IHRoaXMuZ2V0TmFtZSgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlb3BlblByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICBpc1BvcHVwOiBpc1BvcHVwUHJvbWlzZSxcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZXROYW1lUHJvbWlzZVxuXHQgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgX3JlZjMuaXNQb3B1cCAmJiBuYW1lICYmIHdpbmRvdy5vcGVuKFwiXCIsIG5hbWUsIFwibm9vcGVuZXJcIik7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgZm9jdXNQcm9taXNlID0gdGhpcy5zZXJpYWxpemVkV2luZG93LmZvY3VzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuYWxsKFsgcmVvcGVuUHJvbWlzZSwgZm9jdXNQcm9taXNlIF0pLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczQ7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5pc0Nsb3NlZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5pc0Nsb3NlZCgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0V2luZG93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaW5kb3c7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXRXaW5kb3cgPSBmdW5jdGlvbih3aW4sIF9yZWY0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY0LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvdyA9IHdpbjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZS5yZXNvbHZlKHRoaXMuYWN0dWFsV2luZG93KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZFdpbmRvdyA9IGdldFNlcmlhbGl6ZWRXaW5kb3codGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZCxcblx0ICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5nZXRJRCgpXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHdpbmRvd1N0b3JlKFwid2luVG9Qcm94eVdpbmRvd1wiKS5zZXQod2luLCB0aGlzKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmF3YWl0V2luZG93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8ubWF0Y2hXaW5kb3cgPSBmdW5jdGlvbih3aW4sIF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjUuc2VuZDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczUuYWN0dWFsV2luZG93ID8gd2luID09PSBfdGhpczUuYWN0dWFsV2luZG93IDogcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5SW5zdGFuY2VJRDogX3RoaXM1LmdldEluc3RhbmNlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAga25vd25XaW5kb3dJbnN0YW5jZUlEOiBnZXRXaW5kb3dJbnN0YW5jZUlEKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IF9yZWY2LnByb3h5SW5zdGFuY2VJRCA9PT0gX3JlZjYua25vd25XaW5kb3dJbnN0YW5jZUlEO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCAmJiBfdGhpczUuc2V0V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnVud3JhcCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsV2luZG93IHx8IHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRJbnN0YW5jZUlEID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldEluc3RhbmNlSUQoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNob3VsZENsZWFuID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmFjdHVhbFdpbmRvdyAmJiBpc1dpbmRvd0Nsb3NlZCh0aGlzLmFjdHVhbFdpbmRvdykpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy51bndyYXAgPSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbikgPyB3aW4udW53cmFwKCkgOiB3aW47XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHdpbiwgX3JlZjcpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjcuc2VuZDtcblx0ICAgICAgICAgICAgICAgIGNsZWFudXBQcm94eVdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pLnNlcmlhbGl6ZSgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRXaW5kb3csIF9yZWY4KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY4LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJpZFRvUHJveHlXaW5kb3dcIikuZ2V0KHNlcmlhbGl6ZWRXaW5kb3cuaWQpIHx8IG5ldyBQcm94eVdpbmRvdyh7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZFdpbmRvdzogc2VyaWFsaXplZFdpbmRvdyxcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqICYmICFpc1dpbmRvdyhvYmopICYmIG9iai5pc1Byb3h5V2luZG93KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyA9IGZ1bmN0aW9uKHdpbiwgX3JlZjkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjkuc2VuZDtcblx0ICAgICAgICAgICAgICAgIGNsZWFudXBQcm94eVdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIGlmIChQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbikpIHJldHVybiB3aW47XG5cdCAgICAgICAgICAgICAgICB2YXIgYWN0dWFsV2luZG93ID0gd2luO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwid2luVG9Qcm94eVdpbmRvd1wiKS5nZXQoYWN0dWFsV2luZG93KSB8fCBuZXcgUHJveHlXaW5kb3coe1xuXHQgICAgICAgICAgICAgICAgICAgIHdpbjogYWN0dWFsV2luZG93LFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gUHJveHlXaW5kb3c7XG5cdCAgICAgICAgfSgpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGFkZE1ldGhvZChpZCwgdmFsLCBuYW1lLCBzb3VyY2UsIGRvbWFpbikge1xuXHQgICAgICAgICAgICB2YXIgbWV0aG9kU3RvcmUgPSB3aW5kb3dTdG9yZShcIm1ldGhvZFN0b3JlXCIpO1xuXHQgICAgICAgICAgICB2YXIgcHJveHlXaW5kb3dNZXRob2RzID0gZ2xvYmFsU3RvcmUoXCJwcm94eVdpbmRvd01ldGhvZHNcIik7XG5cdCAgICAgICAgICAgIGlmICh3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyhzb3VyY2UpKSBwcm94eVdpbmRvd01ldGhvZHMuc2V0KGlkLCB7XG5cdCAgICAgICAgICAgICAgICB2YWw6IHZhbCxcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG5cdCAgICAgICAgICAgIH0pOyBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHByb3h5V2luZG93TWV0aG9kcy5kZWwoaWQpO1xuXHQgICAgICAgICAgICAgICAgbWV0aG9kU3RvcmUuZ2V0T3JTZXQoc291cmNlLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICAgICAgfSkpW2lkXSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbDogdmFsLFxuXHQgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGxvb2t1cE1ldGhvZChzb3VyY2UsIGlkKSB7XG5cdCAgICAgICAgICAgIHZhciBtZXRob2RTdG9yZSA9IHdpbmRvd1N0b3JlKFwibWV0aG9kU3RvcmVcIik7XG5cdCAgICAgICAgICAgIHZhciBwcm94eVdpbmRvd01ldGhvZHMgPSBnbG9iYWxTdG9yZShcInByb3h5V2luZG93TWV0aG9kc1wiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG1ldGhvZFN0b3JlLmdldE9yU2V0KHNvdXJjZSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICB9KSlbaWRdIHx8IHByb3h5V2luZG93TWV0aG9kcy5nZXQoaWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBmdW5jdGlvbl9zZXJpYWxpemVGdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCB2YWwsIGtleSwgX3JlZjMpIHtcblx0ICAgICAgICAgICAgb24gPSAoX3JlZiA9IHtcblx0ICAgICAgICAgICAgICAgIG9uOiBfcmVmMy5vbixcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IF9yZWYzLnNlbmRcblx0ICAgICAgICAgICAgfSkub24sIHNlbmQgPSBfcmVmLnNlbmQsIGdsb2JhbFN0b3JlKFwiYnVpbHRpbkxpc3RlbmVyc1wiKS5nZXRPclNldChcImZ1bmN0aW9uQ2FsbHNcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG9uKFwicG9zdHJvYm90X21ldGhvZFwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBcIipcIlxuXHQgICAgICAgICAgICAgICAgfSwgKGZ1bmN0aW9uKF9yZWYyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IF9yZWYyLnNvdXJjZSwgb3JpZ2luID0gX3JlZjIub3JpZ2luLCBkYXRhID0gX3JlZjIuZGF0YTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBkYXRhLmlkLCBuYW1lID0gZGF0YS5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXRoID0gbG9va3VwTWV0aG9kKHNvdXJjZSwgaWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbWV0aCkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgbWV0aG9kICdcIiArIG5hbWUgKyBcIicgd2l0aCBpZDogXCIgKyBkYXRhLmlkICsgXCIgaW4gXCIgKyBnZXREb21haW4od2luZG93KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZFNvdXJjZSA9IG1ldGguc291cmNlLCBkb21haW4gPSBtZXRoLmRvbWFpbiwgdmFsID0gbWV0aC52YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4oZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2QgJ1wiICsgZGF0YS5uYW1lICsgXCInIGRvbWFpbiBcIiArIEpTT04uc3RyaW5naWZ5KHV0aWxfaXNSZWdleChtZXRoLmRvbWFpbikgPyBtZXRoLmRvbWFpbi5zb3VyY2UgOiBtZXRoLmRvbWFpbikgKyBcIiBkb2VzIG5vdCBtYXRjaCBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIGdldERvbWFpbih3aW5kb3cpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KG1ldGhvZFNvdXJjZSkpIHJldHVybiBtZXRob2RTb3VyY2UubWF0Y2hXaW5kb3coc291cmNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKG1hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2QgY2FsbCAnXCIgKyBkYXRhLm5hbWUgKyBcIicgZmFpbGVkIC0gcHJveHkgd2luZG93IGRvZXMgbm90IG1hdGNoIHNvdXJjZSBpbiBcIiArIGdldERvbWFpbih3aW5kb3cpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5hcHBseSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRhdGEuYXJncyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsLm9uRXJyb3IpIHJldHVybiB2YWwub25FcnJvcihlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuc3RhY2sgJiYgKGVyci5zdGFjayA9IFwiUmVtb3RlIGNhbGwgdG8gXCIgKyBuYW1lICsgXCIoXCIgKyBmdW5jdGlvbihhcmdzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBhcmdzICYmIChhcmdzID0gW10pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXRlbSA9IGFyZ3MsIFtdLnNsaWNlLmNhbGwoaXRlbSkpLm1hcCgoZnVuY3Rpb24oYXJnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBhcmcgPyBcIidcIiArIGFyZyArIFwiJ1wiIDogdm9pZCAwID09PSBhcmcgPyBcInVuZGVmaW5lZFwiIDogbnVsbCA9PT0gYXJnID8gXCJudWxsXCIgOiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgYXJnID8gYXJnLnRvU3RyaW5nKCkgOiBBcnJheS5pc0FycmF5KGFyZykgPyBcIlsgLi4uIF1cIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGFyZyA/IFwieyAuLi4gfVwiIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBhcmcgPyBcIigpID0+IHsgLi4uIH1cIiA6IFwiPFwiICsgdHlwZW9mIGFyZyArIFwiPlwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5qb2luKFwiLCBcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGRhdGEuYXJncykgKyBcIikgZmFpbGVkXFxuXFxuXCIgKyBlcnIuc3RhY2spO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHZhciBfcmVmLCBvbiwgc2VuZDtcblx0ICAgICAgICAgICAgdmFyIGlkID0gdmFsLl9faWRfXyB8fCB1bmlxdWVJRCgpO1xuXHQgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IHdpbmRvd19Qcm94eVdpbmRvdy51bndyYXAoZGVzdGluYXRpb24pO1xuXHQgICAgICAgICAgICB2YXIgbmFtZSA9IHZhbC5fX25hbWVfXyB8fCB2YWwubmFtZSB8fCBrZXk7XG5cdCAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIG5hbWUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBuYW1lLmluZGV4T2YgJiYgMCA9PT0gbmFtZS5pbmRleE9mKFwiYW5vbnltb3VzOjpcIikgJiYgKG5hbWUgPSBuYW1lLnJlcGxhY2UoXCJhbm9ueW1vdXM6OlwiLCBrZXkgKyBcIjo6XCIpKTtcblx0ICAgICAgICAgICAgaWYgKHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KGRlc3RpbmF0aW9uKSkge1xuXHQgICAgICAgICAgICAgICAgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIGRlc3RpbmF0aW9uLCBkb21haW4pO1xuXHQgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgd2luLCBkb21haW4pO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9IGVsc2UgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIGRlc3RpbmF0aW9uLCBkb21haW4pO1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImNyb3NzX2RvbWFpbl9mdW5jdGlvblwiLCB7XG5cdCAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVNZXNzYWdlKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaiwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgX3NlcmlhbGl6ZTtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZi5vbiwgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgc2VyaWFsaXplcnMpIHtcblx0ICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gc2VyaWFsaXplcnMgJiYgKHNlcmlhbGl6ZXJzID0gZGVmYXVsdFNlcmlhbGl6ZXJzKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShvYmosIChmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpc1trZXldO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRUeXBlKHRoaXMpKSByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZGV0ZXJtaW5lVHlwZSh2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdHlwZSkgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplciA9IHNlcmlhbGl6ZXJzW3R5cGVdIHx8IFNFUklBTElaRVJbdHlwZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPyBzZXJpYWxpemVyKHZhbCwga2V5KSA6IHZhbDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHJlc3VsdCA/IFwidW5kZWZpbmVkXCIgOiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH0ob2JqLCAoKF9zZXJpYWxpemUgPSB7fSkucHJvbWlzZSA9IGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIF9yZWYpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImNyb3NzX2RvbWFpbl96YWxnb19wcm9taXNlXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhlbjogZnVuY3Rpb25fc2VyaWFsaXplRnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBrZXksIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBfcmVmLm9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogX3JlZi5zZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCBfc2VyaWFsaXplLmZ1bmN0aW9uID0gZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbl9zZXJpYWxpemVGdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCB2YWwsIGtleSwge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZS5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpc1dpbmRvdyh2YWwpIHx8IHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHZhbCkgPyBzZXJpYWxpemVUeXBlKFwiY3Jvc3NfZG9tYWluX3dpbmRvd1wiLCB3aW5kb3dfUHJveHlXaW5kb3cuc2VyaWFsaXplKHZhbCwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pKSA6IHZhbDtcblx0ICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIF9yZWYyKSB7XG5cdCAgICAgICAgICAgIHZhciBfZGVzZXJpYWxpemU7XG5cdCAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjIuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgZGVzZXJpYWxpemVycykge1xuXHQgICAgICAgICAgICAgICAgdm9pZCAwID09PSBkZXNlcmlhbGl6ZXJzICYmIChkZXNlcmlhbGl6ZXJzID0gZGVmYXVsdERlc2VyaWFsaXplcnMpO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHN0cikgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLCAoZnVuY3Rpb24oa2V5LCB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh0aGlzKSkgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFR5cGUodmFsKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gdmFsLl9fdHlwZV9fO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbC5fX3ZhbF9fO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBkZXRlcm1pbmVUeXBlKHZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGUpIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVzZXJpYWxpemVyID0gZGVzZXJpYWxpemVyc1t0eXBlXSB8fCBERVNFUklBTElaRVJbdHlwZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplciA/IGRlc2VyaWFsaXplcih2YWx1ZSwga2V5KSA6IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KG1lc3NhZ2UsICgoX2Rlc2VyaWFsaXplID0ge30pLmNyb3NzX2RvbWFpbl96YWxnb19wcm9taXNlID0gZnVuY3Rpb24oc2VyaWFsaXplZFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIG9yaWdpbiwgX3JlZjIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKF9yZWYyLnRoZW4pO1xuXHQgICAgICAgICAgICAgICAgfSgwLCAwLCBzZXJpYWxpemVkUHJvbWlzZSk7XG5cdCAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZS5jcm9zc19kb21haW5fZnVuY3Rpb24gPSBmdW5jdGlvbihzZXJpYWxpemVkRnVuY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIG9yaWdpbiwgX3JlZjQsIF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gX3JlZjQuaWQsIG5hbWUgPSBfcmVmNC5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjUuc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0RGVzZXJpYWxpemVkRnVuY3Rpb24gPSBmdW5jdGlvbihvcHRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0cyAmJiAob3B0cyA9IHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyhzb3VyY2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5hd2FpdFdpbmRvdygpLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRoID0gbG9va3VwTWV0aG9kKHdpbiwgaWQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRoICYmIG1ldGgudmFsICE9PSBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcikgcmV0dXJuIG1ldGgudmFsLmFwcGx5KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB3aW5kb3csXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2FyZ3MgPSBbXS5zbGljZS5jYWxsKF9hcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRzLmZpcmVBbmRGb3JnZXQgPyBzZW5kKHdpbiwgXCJwb3N0cm9ib3RfbWV0aG9kXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBfYXJnc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICEwXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBzZW5kKHdpbiwgXCJwb3N0cm9ib3RfbWV0aG9kXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBfYXJnc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICExXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMuZGF0YS5yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuX19uYW1lX18gPSBuYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX29yaWdpbl9fID0gb3JpZ2luO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX3NvdXJjZV9fID0gc291cmNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX2lkX18gPSBpZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIub3JpZ2luID0gb3JpZ2luO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIgPSBnZXREZXNlcmlhbGl6ZWRGdW5jdGlvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLmZpcmVBbmRGb3JnZXQgPSBnZXREZXNlcmlhbGl6ZWRGdW5jdGlvbih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICEwXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyO1xuXHQgICAgICAgICAgICAgICAgfShzb3VyY2UsIG9yaWdpbiwgc2VyaWFsaXplZEZ1bmN0aW9uLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZS5jcm9zc19kb21haW5fd2luZG93ID0gZnVuY3Rpb24oc2VyaWFsaXplZFdpbmRvdykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy5kZXNlcmlhbGl6ZShzZXJpYWxpemVkV2luZG93LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgU0VORF9NRVNTQUdFX1NUUkFURUdJRVMgPSB7fTtcblx0ICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFUy5wb3N0cm9ib3RfcG9zdF9tZXNzYWdlID0gZnVuY3Rpb24od2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKSB7XG5cdCAgICAgICAgICAgIDAgPT09IGRvbWFpbi5pbmRleE9mKFwiZmlsZTpcIikgJiYgKGRvbWFpbiA9IFwiKlwiKTtcblx0ICAgICAgICAgICAgd2luLnBvc3RNZXNzYWdlKHNlcmlhbGl6ZWRNZXNzYWdlLCBkb21haW4pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZnVuY3Rpb24gc2VuZF9zZW5kTWVzc2FnZSh3aW4sIGRvbWFpbiwgbWVzc2FnZSwgX3JlZjIpIHtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZjIub24sIHNlbmQgPSBfcmVmMi5zZW5kO1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBkb21haW5CdWZmZXIgPSB3aW5kb3dTdG9yZSgpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbkJ1ZmZlci5idWZmZXIgPSBkb21haW5CdWZmZXIuYnVmZmVyIHx8IFtdO1xuXHQgICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgZG9tYWluQnVmZmVyLmZsdXNoID0gZG9tYWluQnVmZmVyLmZsdXNoIHx8IHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbikpIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBpcyBjbG9zZWRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRNZXNzYWdlID0gc2VyaWFsaXplTWVzc2FnZSh3aW4sIGRvbWFpbiwgKChfcmVmID0ge30pLl9fcG9zdF9yb2JvdF8xMF8wXzQ2X18gPSBkb21haW5CdWZmZXIuYnVmZmVyIHx8IFtdLCBcblx0ICAgICAgICAgICAgICAgICAgICBfcmVmKSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluQnVmZmVyLmJ1ZmZlcjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RyYXRlZ2llcyA9IE9iamVjdC5rZXlzKFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc3RyYXRlZ2llcy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJhdGVneU5hbWUgPSBzdHJhdGVnaWVzW19pMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFU1tzdHJhdGVneU5hbWVdKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gc3RyYXRlZ2llcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcihcIkFsbCBwb3N0LXJvYm90IG1lc3NhZ2luZyBzdHJhdGVnaWVzIGZhaWxlZDpcXG5cXG5cIiArIGVycm9ycy5tYXAoKGZ1bmN0aW9uKGVyciwgaSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSArIFwiLiBcIiArIHN0cmluZ2lmeUVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpLmpvaW4oXCJcXG5cXG5cIikpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkJ1ZmZlci5mbHVzaC50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgZG9tYWluQnVmZmVyLmZsdXNoO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KSkudGhlbihzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0UmVzcG9uc2VMaXN0ZW5lcihoYXNoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpLmdldChoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcihoYXNoKSB7XG5cdCAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIikuZGVsKGhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkKGhhc2gpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwiZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzXCIpLmhhcyhoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0UmVxdWVzdExpc3RlbmVyKF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsIHdpbiA9IF9yZWYud2luLCBkb21haW4gPSBfcmVmLmRvbWFpbjtcblx0ICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lcnMgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RMaXN0ZW5lcnNcIik7XG5cdCAgICAgICAgICAgIFwiKlwiID09PSB3aW4gJiYgKHdpbiA9IG51bGwpO1xuXHQgICAgICAgICAgICBcIipcIiA9PT0gZG9tYWluICYmIChkb21haW4gPSBudWxsKTtcblx0ICAgICAgICAgICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIHJlcXVpcmVkIHRvIGdldCByZXF1ZXN0IGxpc3RlbmVyXCIpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfcmVmMyA9IFsgd2luLCBnZXRXaWxkY2FyZCgpIF07IF9pNCA8IF9yZWYzLmxlbmd0aDsgX2k0KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5RdWFsaWZpZXIgPSBfcmVmM1tfaTRdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpblF1YWxpZmllcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lTGlzdGVuZXJzID0gcmVxdWVzdExpc3RlbmVycy5nZXQod2luUXVhbGlmaWVyKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobmFtZUxpc3RlbmVycykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluTGlzdGVuZXJzID0gbmFtZUxpc3RlbmVyc1tuYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVycykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzW2RvbWFpbl0pIHJldHVybiBkb21haW5MaXN0ZW5lcnNbZG9tYWluXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluTGlzdGVuZXJzLl9fZG9tYWluX3JlZ2V4X18pIGZvciAodmFyIF9pNiA9IDAsIF9kb21haW5MaXN0ZW5lcnMkX19ETzIgPSBkb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXzsgX2k2IDwgX2RvbWFpbkxpc3RlbmVycyRfX0RPMi5sZW5ndGg7IF9pNisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZG9tYWluTGlzdGVuZXJzJF9fRE8zID0gX2RvbWFpbkxpc3RlbmVycyRfX0RPMltfaTZdLCBsaXN0ZW5lciA9IF9kb21haW5MaXN0ZW5lcnMkX19ETzMubGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaERvbWFpbihfZG9tYWluTGlzdGVuZXJzJF9fRE8zLnJlZ2V4LCBkb21haW4pKSByZXR1cm4gbGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVyc1tcIipcIl0pIHJldHVybiBkb21haW5MaXN0ZW5lcnNbXCIqXCJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3Qoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZi5vbiwgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lLFxuXHQgICAgICAgICAgICAgICAgd2luOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpblxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdmFyIGxvZ05hbWUgPSBcInBvc3Ryb2JvdF9tZXRob2RcIiA9PT0gbWVzc2FnZS5uYW1lICYmIG1lc3NhZ2UuZGF0YSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBtZXNzYWdlLmRhdGEubmFtZSA/IG1lc3NhZ2UuZGF0YS5uYW1lICsgXCIoKVwiIDogbWVzc2FnZS5uYW1lO1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzZW5kUmVzcG9uc2UoYWNrLCBkYXRhLCBlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmZpcmVBbmRGb3JnZXQgJiYgIWlzV2luZG93Q2xvc2VkKHNvdXJjZSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdW5pcXVlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKHdpbmRvdyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3Jlc3BvbnNlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBtZXNzYWdlLmhhc2gsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2s6IGFjayxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3Jcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZCByZXNwb25zZSBtZXNzYWdlIGZhaWxlZCBmb3IgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiXFxuXFxuXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLmFsbChbIHByb21pc2VfWmFsZ29Qcm9taXNlLmZsdXNoKCkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuZmlyZUFuZEZvcmdldCAmJiAhaXNXaW5kb3dDbG9zZWQoc291cmNlKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZF9zZW5kTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZDogdW5pcXVlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBnZXREb21haW4od2luZG93KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb3N0cm9ib3RfbWVzc2FnZV9hY2tcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogbWVzc2FnZS5oYXNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWVcblx0ICAgICAgICAgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZCBhY2sgbWVzc2FnZSBmYWlsZWQgZm9yIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIlxcblxcblwiICsgc3RyaW5naWZ5RXJyb3IoZXJyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pKSwgcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKFwiTm8gaGFuZGxlciBmb3VuZCBmb3IgcG9zdCBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmhhbmRsZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFJlc3BvbnNlKFwic3VjY2Vzc1wiLCBkYXRhKTtcblx0ICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZShcImVycm9yXCIsIG51bGwsIGVycm9yKTtcblx0ICAgICAgICAgICAgfSkpIF0pLnRoZW4oc3JjX3V0aWxfbm9vcCkuY2F0Y2goKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVFcnJvcikgcmV0dXJuIG9wdGlvbnMuaGFuZGxlRXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBoYW5kbGVBY2soc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgaWYgKCFpc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkKG1lc3NhZ2UuaGFzaCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0UmVzcG9uc2VMaXN0ZW5lcihtZXNzYWdlLmhhc2gpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgYWNrIGZvciBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaERvbWFpbihvcHRpb25zLmRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQWNrIG9yaWdpbiBcIiArIG9yaWdpbiArIFwiIGRvZXMgbm90IG1hdGNoIGRvbWFpbiBcIiArIG9wdGlvbnMuZG9tYWluLnRvU3RyaW5nKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgIT09IG9wdGlvbnMud2luKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2sgc291cmNlIGRvZXMgbm90IG1hdGNoIHJlZ2lzdGVyZWQgd2luZG93XCIpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5hY2sgPSAhMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkge1xuXHQgICAgICAgICAgICBpZiAoIWlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQobWVzc2FnZS5oYXNoKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZSByZXNwb25zZSBmb3IgbWVzc2FnZTogXCIgKyBtZXNzYWdlLm5hbWUgKyBcIiBmcm9tIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKG9wdGlvbnMuZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyAocGF0dGVybiA9IG9wdGlvbnMuZG9tYWluLCBcblx0ICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGF0dGVybikgPyBcIihcIiArIHBhdHRlcm4uam9pbihcIiB8IFwiKSArIFwiKVwiIDogaXNSZWdleChwYXR0ZXJuKSA/IFwiUmVnRXhwKFwiICsgcGF0dGVybi50b1N0cmluZygpICsgXCIpXCIgOiBwYXR0ZXJuLnRvU3RyaW5nKCkpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuO1xuXHQgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gb3B0aW9ucy53aW4pIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHNvdXJjZSBkb2VzIG5vdCBtYXRjaCByZWdpc3RlcmVkIHdpbmRvd1wiKTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZVJlc3BvbnNlTGlzdGVuZXIobWVzc2FnZS5oYXNoKTtcblx0ICAgICAgICAgICAgICAgIFwiZXJyb3JcIiA9PT0gbWVzc2FnZS5hY2sgPyBvcHRpb25zLnByb21pc2UucmVqZWN0KG1lc3NhZ2UuZXJyb3IpIDogXCJzdWNjZXNzXCIgPT09IG1lc3NhZ2UuYWNrICYmIG9wdGlvbnMucHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlLmRhdGFcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2UoZXZlbnQsIF9yZWYyKSB7XG5cdCAgICAgICAgICAgIHZhciBvbiA9IF9yZWYyLm9uLCBzZW5kID0gX3JlZjIuc2VuZDtcblx0ICAgICAgICAgICAgdmFyIHJlY2VpdmVkTWVzc2FnZXMgPSBnbG9iYWxTdG9yZShcInJlY2VpdmVkTWVzc2FnZXNcIik7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdyB8fCB3aW5kb3cuY2xvc2VkIHx8ICFldmVudC5zb3VyY2UpIHJldHVybjtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSwgb3JpZ2luID0gZXZlbnQub3JpZ2luO1xuXHQgICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBmdW5jdGlvbihtZXNzYWdlLCBzb3VyY2UsIG9yaWdpbiwgX3JlZikge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZi5vbiwgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJzZWRNZXNzYWdlO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJzZWRNZXNzYWdlID0gZGVzZXJpYWxpemVNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgcGFyc2VkTWVzc2FnZSAmJiBudWxsICE9PSBwYXJzZWRNZXNzYWdlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlTWVzc2FnZXMgPSBwYXJzZWRNZXNzYWdlLl9fcG9zdF9yb2JvdF8xMF8wXzQ2X187XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VNZXNzYWdlcykpIHJldHVybiBwYXJzZU1lc3NhZ2VzO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KGV2ZW50LmRhdGEsIHNvdXJjZSwgb3JpZ2luLCB7XG5cdCAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBpZiAobWVzc2FnZXMpIHtcblx0ICAgICAgICAgICAgICAgIG1hcmtXaW5kb3dLbm93bihzb3VyY2UpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbWVzc2FnZXMubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZXNbX2kyXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRNZXNzYWdlcy5oYXMobWVzc2FnZS5pZCkpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICByZWNlaXZlZE1lc3NhZ2VzLnNldChtZXNzYWdlLmlkLCAhMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHNvdXJjZSkgJiYgIW1lc3NhZ2UuZmlyZUFuZEZvcmdldCkgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIDAgPT09IG1lc3NhZ2Uub3JpZ2luLmluZGV4T2YoXCJmaWxlOlwiKSAmJiAob3JpZ2luID0gXCJmaWxlOi8vXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zdHJvYm90X21lc3NhZ2VfcmVxdWVzdFwiID09PSBtZXNzYWdlLnR5cGUgPyBoYW5kbGVSZXF1ZXN0KHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogXCJwb3N0cm9ib3RfbWVzc2FnZV9yZXNwb25zZVwiID09PSBtZXNzYWdlLnR5cGUgPyBoYW5kbGVSZXNwb25zZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkgOiBcInBvc3Ryb2JvdF9tZXNzYWdlX2Fja1wiID09PSBtZXNzYWdlLnR5cGUgJiYgaGFuZGxlQWNrKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gb25fb24obmFtZSwgb3B0aW9ucywgaGFuZGxlcikge1xuXHQgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5hbWVcIik7XG5cdCAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkpIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBvcHRpb25zO1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghaGFuZGxlcikgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaGFuZGxlclwiKTtcblx0ICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZFJlcXVlc3RMaXN0ZW5lcihfcmVmNCwgbGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjQubmFtZSwgd2luQ2FuZGlkYXRlID0gX3JlZjQud2luLCBkb21haW4gPSBfcmVmNC5kb21haW47XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVycyA9IHdpbmRvd1N0b3JlKFwicmVxdWVzdExpc3RlbmVyc1wiKTtcblx0ICAgICAgICAgICAgICAgIGlmICghbmFtZSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIHJlcXVpcmVkIHRvIGFkZCByZXF1ZXN0IGxpc3RlbmVyXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbkNhbmRpZGF0ZSAmJiBcIipcIiAhPT0gd2luQ2FuZGlkYXRlICYmIHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbkNhbmRpZGF0ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVyUHJvbWlzZSA9IHdpbkNhbmRpZGF0ZS5hd2FpdFdpbmRvdygpLnRoZW4oKGZ1bmN0aW9uKGFjdHVhbFdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkUmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW46IGFjdHVhbFdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RMaXN0ZW5lclByb21pc2UudGhlbigoZnVuY3Rpb24ocmVxdWVzdExpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RMaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luID0gd2luQ2FuZGlkYXRlO1xuXHQgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkod2luKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnNDb2xsZWN0aW9uID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX3dpbjIgPSB3aW47IF9pOCA8IF93aW4yLmxlbmd0aDsgX2k4KyspIGxpc3RlbmVyc0NvbGxlY3Rpb24ucHVzaChhZGRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luOiBfd2luMltfaThdXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIpKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBsaXN0ZW5lcnNDb2xsZWN0aW9uLmxlbmd0aDsgX2kxMCsrKSBsaXN0ZW5lcnNDb2xsZWN0aW9uW19pMTBdLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRvbWFpbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX2xpc3RlbmVyc0NvbGxlY3Rpb24gPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTEyID0gMCwgX2RvbWFpbjIgPSBkb21haW47IF9pMTIgPCBfZG9tYWluMi5sZW5ndGg7IF9pMTIrKykgX2xpc3RlbmVyc0NvbGxlY3Rpb24ucHVzaChhZGRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBfZG9tYWluMltfaTEyXVxuXHQgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTQgPSAwOyBfaTE0IDwgX2xpc3RlbmVyc0NvbGxlY3Rpb24ubGVuZ3RoOyBfaTE0KyspIF9saXN0ZW5lcnNDb2xsZWN0aW9uW19pMTRdLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0xpc3RlbmVyID0gZ2V0UmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHdpbiAmJiBcIipcIiAhPT0gd2luIHx8ICh3aW4gPSBnZXRXaWxkY2FyZCgpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdHJEb21haW4gPSAoZG9tYWluID0gZG9tYWluIHx8IFwiKlwiKS50b1N0cmluZygpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nTGlzdGVuZXIpIHRocm93IHdpbiAmJiBkb21haW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBvbiBkb21haW4gXCIgKyBkb21haW4udG9TdHJpbmcoKSArIFwiIGZvciBcIiArICh3aW4gPT09IGdldFdpbGRjYXJkKCkgPyBcIndpbGRjYXJkXCIgOiBcInNwZWNpZmllZFwiKSArIFwiIHdpbmRvd1wiKSA6IHdpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIGZvciBcIiArICh3aW4gPT09IGdldFdpbGRjYXJkKCkgPyBcIndpbGRjYXJkXCIgOiBcInNwZWNpZmllZFwiKSArIFwiIHdpbmRvd1wiKSA6IGRvbWFpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIG9uIGRvbWFpbiBcIiArIGRvbWFpbi50b1N0cmluZygpKSA6IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZUxpc3RlbmVycyA9IHJlcXVlc3RMaXN0ZW5lcnMuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVEb21haW5MaXN0ZW5lcnMgPSB1dGlsX2dldE9yU2V0KHdpbk5hbWVMaXN0ZW5lcnMsIG5hbWUsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgdXRpbF9pc1JlZ2V4KGRvbWFpbikgPyAod2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzID0gdXRpbF9nZXRPclNldCh3aW5OYW1lRG9tYWluTGlzdGVuZXJzLCBcIl9fZG9tYWluX3JlZ2V4X19cIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICAgICAgICAgIH0pKSkucHVzaCh3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICByZWdleDogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuXHQgICAgICAgICAgICAgICAgfSkgOiB3aW5OYW1lRG9tYWluTGlzdGVuZXJzW3N0ckRvbWFpbl0gPSBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdpbk5hbWVEb21haW5MaXN0ZW5lcnNbc3RyRG9tYWluXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnMuc3BsaWNlKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycy5pbmRleE9mKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyLCAxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnMubGVuZ3RoIHx8IGRlbGV0ZSB3aW5OYW1lRG9tYWluTGlzdGVuZXJzLl9fZG9tYWluX3JlZ2V4X187XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMod2luTmFtZURvbWFpbkxpc3RlbmVycykubGVuZ3RoIHx8IGRlbGV0ZSB3aW5OYW1lTGlzdGVuZXJzW25hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW4gJiYgIU9iamVjdC5rZXlzKHdpbk5hbWVMaXN0ZW5lcnMpLmxlbmd0aCAmJiByZXF1ZXN0TGlzdGVuZXJzLmRlbCh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgIHdpbjogb3B0aW9ucy53aW5kb3csXG5cdCAgICAgICAgICAgICAgICBkb21haW46IG9wdGlvbnMuZG9tYWluIHx8IFwiKlwiXG5cdCAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIgfHwgb3B0aW9ucy5oYW5kbGVyLFxuXHQgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3I6IG9wdGlvbnMuZXJyb3JIYW5kbGVyIHx8IGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RMaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gb25fb25jZShuYW1lLCBvcHRpb25zLCBoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkpIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBvcHRpb25zO1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG5cdCAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGxpc3RlbmVyID0gb25fb24obmFtZSwgb3B0aW9ucywgKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShldmVudCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikgcmV0dXJuIGhhbmRsZXIoZXZlbnQpO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHByb21pc2UuY2FuY2VsID0gbGlzdGVuZXIuY2FuY2VsO1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNlbmRfc2VuZCA9IGZ1bmN0aW9uIHNlbmQod2luT3JQcm94eVdpbiwgbmFtZSwgZGF0YSwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgZG9tYWluTWF0Y2hlciA9IChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkuZG9tYWluIHx8IFwiKlwiO1xuXHQgICAgICAgICAgICB2YXIgcmVzcG9uc2VUaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IC0xO1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRUaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDVlMztcblx0ICAgICAgICAgICAgdmFyIGZpcmVBbmRGb3JnZXQgPSBvcHRpb25zLmZpcmVBbmRGb3JnZXQgfHwgITE7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyh3aW5PclByb3h5V2luLCB7XG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgIH0pLmF3YWl0V2luZG93KCkudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24obmFtZSwgd2luLCBkb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBuYW1lXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGRvbWFpbiAmJiAhQXJyYXkuaXNBcnJheShkb21haW4pICYmICF1dGlsX2lzUmVnZXgoZG9tYWluKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3Qgc2VuZCBcIiArIG5hbWUgKyBcIi4gRXhwZWN0ZWQgZG9tYWluIFwiICsgSlNPTi5zdHJpbmdpZnkoZG9tYWluKSArIFwiIHRvIGJlIGEgc3RyaW5nLCBhcnJheSwgb3IgcmVnZXhcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHNlbmQgXCIgKyBuYW1lICsgXCIuIFRhcmdldCB3aW5kb3cgaXMgY2xvc2VkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0obmFtZSwgd2luLCBkb21haW5NYXRjaGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0dWFsUGFyZW50ID0gZ2V0QW5jZXN0b3IoY2hpbGQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0dWFsUGFyZW50KSByZXR1cm4gYWN0dWFsUGFyZW50ID09PSBwYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luLnRvcCkgcmV0dXJuIHdpbi50b3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0UGFyZW50KHdpbikgPT09IHdpbikgcmV0dXJuIHdpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQW5jZXN0b3JQYXJlbnQod2luZG93LCB3aW4pICYmIHdpbmRvdy50b3ApIHJldHVybiB3aW5kb3cudG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbmNlc3RvclBhcmVudCh3aW4sIHdpbmRvdykgJiYgd2luZG93LnRvcCkgcmV0dXJuIHdpbmRvdy50b3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTcgPSAwLCBfZ2V0QWxsQ2hpbGRGcmFtZXM0ID0gZnVuY3Rpb24gZ2V0QWxsQ2hpbGRGcmFtZXMod2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9nZXRGcmFtZXMyID0gZ2V0RnJhbWVzKHdpbik7IF9pMyA8IF9nZXRGcmFtZXMyLmxlbmd0aDsgX2kzKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX2dldEZyYW1lczJbX2kzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwLCBfZ2V0QWxsQ2hpbGRGcmFtZXMyID0gZ2V0QWxsQ2hpbGRGcmFtZXMoZnJhbWUpOyBfaTUgPCBfZ2V0QWxsQ2hpbGRGcmFtZXMyLmxlbmd0aDsgX2k1KyspIHJlc3VsdC5wdXNoKF9nZXRBbGxDaGlsZEZyYW1lczJbX2k1XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbik7IF9pNyA8IF9nZXRBbGxDaGlsZEZyYW1lczQubGVuZ3RoOyBfaTcrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9nZXRBbGxDaGlsZEZyYW1lczRbX2k3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUudG9wKSByZXR1cm4gZnJhbWUudG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0UGFyZW50KGZyYW1lKSA9PT0gZnJhbWUpIHJldHVybiBmcmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfShjaGlsZCkgPT09IGNoaWxkKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTUgPSAwLCBfZ2V0RnJhbWVzOCA9IGdldEZyYW1lcyhwYXJlbnQpOyBfaTE1IDwgX2dldEZyYW1lczgubGVuZ3RoOyBfaTE1KyspIGlmIChfZ2V0RnJhbWVzOFtfaTE1XSA9PT0gY2hpbGQpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgICAgIH0od2luZG93LCB3aW4pKSByZXR1cm4gZnVuY3Rpb24od2luLCB0aW1lb3V0LCBuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdGltZW91dCAmJiAodGltZW91dCA9IDVlMyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gbmFtZSAmJiAobmFtZSA9IFwiV2luZG93XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwiaGVsbG9Qcm9taXNlc1wiKS5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC0xICE9PSB0aW1lb3V0ICYmIChwcm9taXNlID0gcHJvbWlzZS50aW1lb3V0KHRpbWVvdXQsIG5ldyBFcnJvcihuYW1lICsgXCIgZGlkIG5vdCBsb2FkIGFmdGVyIFwiICsgdGltZW91dCArIFwibXNcIikpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW4sIGNoaWxkVGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oX3RlbXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24od2luLCB0YXJnZXREb21haW4sIGFjdHVhbERvbWFpbiwgX3JlZikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGFyZ2V0RG9tYWluID8gdGFyZ2V0RG9tYWluIDogcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsRG9tYWluIHx8IHNheUhlbGxvKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmRvbWFpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24obm9ybWFsaXplZERvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4odGFyZ2V0RG9tYWluLCB0YXJnZXREb21haW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJEb21haW4gXCIgKyBzdHJpbmdpZnkodGFyZ2V0RG9tYWluKSArIFwiIGRvZXMgbm90IG1hdGNoIFwiICsgc3RyaW5naWZ5KHRhcmdldERvbWFpbikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRG9tYWluO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW4sIGRvbWFpbk1hdGNoZXIsICh2b2lkIDAgPT09IF90ZW1wID8ge30gOiBfdGVtcCkuZG9tYWluLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbih0YXJnZXREb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdGFyZ2V0RG9tYWluO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsb2dOYW1lID0gXCJwb3N0cm9ib3RfbWV0aG9kXCIgPT09IG5hbWUgJiYgZGF0YSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkYXRhLm5hbWUgPyBkYXRhLm5hbWUgKyBcIigpXCIgOiBuYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gbmFtZSArIFwiX1wiICsgdW5pcXVlSUQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcmVBbmRGb3JnZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGlzdGVuZXIgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luOiB3aW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGhhc2gsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpLnNldChoYXNoLCBsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0oaGFzaCwgcmVzcG9uc2VMaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFQcm9taXNlcyA9IHdpbmRvd1N0b3JlKFwicmVxdWVzdFByb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcVByb21pc2VzLnB1c2gocHJvbWlzZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2F0Y2goKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGhhc2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImVycm9yZWRSZXNwb25zZUxpc3RlbmVyc1wiKS5zZXQoaGFzaCwgITApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfShoYXNoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVJlc3BvbnNlTGlzdGVuZXIoaGFzaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsQWNrVGltZW91dCA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwia25vd25XaW5kb3dzXCIpLmdldCh3aW4sICExKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW4pID8gMWU0IDogMmUzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxSZXNUaW1lb3V0ID0gcmVzcG9uc2VUaW1lb3V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWNrVGltZW91dCA9IHRvdGFsQWNrVGltZW91dDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc1RpbWVvdXQgPSB0b3RhbFJlc1RpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IGZ1bmN0aW9uKG1ldGhvZCwgdGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24gbG9vcCgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSByZXR1cm4gcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV2luZG93IGNsb3NlZCBmb3IgXCIgKyBuYW1lICsgXCIgYmVmb3JlIFwiICsgKHJlc3BvbnNlTGlzdGVuZXIuYWNrID8gXCJyZXNwb25zZVwiIDogXCJhY2tcIikpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUxpc3RlbmVyLmNhbmNlbGxlZCkgcmV0dXJuIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlJlc3BvbnNlIGxpc3RlbmVyIHdhcyBjYW5jZWxsZWQgZm9yIFwiICsgbmFtZSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNrVGltZW91dCA9IE1hdGgubWF4KGFja1RpbWVvdXQgLSA1MDAsIDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLTEgIT09IHJlc1RpbWVvdXQgJiYgKHJlc1RpbWVvdXQgPSBNYXRoLm1heChyZXNUaW1lb3V0IC0gNTAwLCAwKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUxpc3RlbmVyLmFjayB8fCAwICE9PSBhY2tUaW1lb3V0ID8gMCA9PT0gcmVzVGltZW91dCAmJiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmb3IgcG9zdE1lc3NhZ2UgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiIGluIFwiICsgdG90YWxSZXNUaW1lb3V0ICsgXCJtc1wiKSkgOiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyBhY2sgZm9yIHBvc3RNZXNzYWdlIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIiBpbiBcIiArIHRvdGFsQWNrVGltZW91dCArIFwibXNcIikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgNTAwKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5maW5hbGx5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxUHJvbWlzZXMuc3BsaWNlKHJlcVByb21pc2VzLmluZGV4T2YocHJvbWlzZSwgMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmRNZXNzYWdlKHdpbiwgZG9tYWluLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB1bmlxdWVJRCgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbih3aW5kb3cpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3JlcXVlc3RcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogZmlyZUFuZEZvcmdldFxuXHQgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJlQW5kRm9yZ2V0ID8gcHJvbWlzZS5yZXNvbHZlKCkgOiBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgcmVxdWVzdCBtZXNzYWdlIGZhaWxlZCBmb3IgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiXFxuXFxuXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIHNldHVwX3NlcmlhbGl6ZU1lc3NhZ2UoZGVzdGluYXRpb24sIGRvbWFpbiwgb2JqKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVNZXNzYWdlKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaiwge1xuXHQgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXR1cF9kZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSwge1xuXHQgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBjcmVhdGVQcm94eVdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3dfUHJveHlXaW5kb3coe1xuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kLFxuXHQgICAgICAgICAgICAgICAgd2luOiB3aW5cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNldHVwX3RvUHJveHlXaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyh3aW4sIHtcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0dXAoKSB7XG5cdCAgICAgICAgICAgIGlmICghZ2xvYmFsX2dldEdsb2JhbCgpLmluaXRpYWxpemVkKSB7XG5cdCAgICAgICAgICAgICAgICBnbG9iYWxfZ2V0R2xvYmFsKCkuaW5pdGlhbGl6ZWQgPSAhMDtcblx0ICAgICAgICAgICAgICAgIG9uID0gKF9yZWYzID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgICAgIH0pLm9uLCBzZW5kID0gX3JlZjMuc2VuZCwgKGdsb2JhbCA9IGdsb2JhbF9nZXRHbG9iYWwoKSkucmVjZWl2ZU1lc3NhZ2UgPSBnbG9iYWwucmVjZWl2ZU1lc3NhZ2UgfHwgZnVuY3Rpb24obWVzc2FnZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlX3JlY2VpdmVNZXNzYWdlKG1lc3NhZ2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZjUub24sIHNlbmQgPSBfcmVmNS5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKCkuZ2V0T3JTZXQoXCJwb3N0TWVzc2FnZUxpc3RlbmVyXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgZXZlbnQsIGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0od2luZG93LCAwLCAoZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihldmVudCwgX3JlZjQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmNC5vbiwgc2VuZCA9IF9yZWY0LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCBldmVudC5zb3VyY2VFbGVtZW50O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gZXZlbnQub3JpZ2luIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC5vcmlnaW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJudWxsXCIgPT09IG9yaWdpbiAmJiAob3JpZ2luID0gXCJmaWxlOi8vXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9yaWdpbikgdGhyb3cgbmV3IEVycm9yKFwiUG9zdCBtZXNzYWdlIGRpZCBub3QgaGF2ZSBvcmlnaW4gZG9tYWluXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZV9yZWNlaXZlTWVzc2FnZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oZXZlbnQsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICFmdW5jdGlvbihfcmVmOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWY4Lm9uLCBzZW5kID0gX3JlZjguc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImJ1aWx0aW5MaXN0ZW5lcnNcIikuZ2V0T3JTZXQoXCJoZWxsb0xpc3RlbmVyXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gb24oXCJwb3N0cm9ib3RfaGVsbG9cIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBcIipcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCAoZnVuY3Rpb24oX3JlZjMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVIZWxsb1Byb21pc2UoX3JlZjMuc291cmNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBfcmVmMy5vcmlnaW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBnZXRJbnN0YW5jZUlEKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGdldEFuY2VzdG9yKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJiBzYXlIZWxsbyhwYXJlbnQsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGZ1bmN0aW9uKGVycikge30pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0oe1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbl9vbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcmVmMywgb24sIHNlbmQsIGdsb2JhbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0ICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGlzdGVuZXJzID0gZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9yZXNwb25zZUxpc3RlbmVycyRrZTIgPSByZXNwb25zZUxpc3RlbmVycy5rZXlzKCk7IF9pMiA8IF9yZXNwb25zZUxpc3RlbmVycyRrZTIubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gX3Jlc3BvbnNlTGlzdGVuZXJzJGtlMltfaTJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHJlc3BvbnNlTGlzdGVuZXJzLmdldChoYXNoKTtcblx0ICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciAmJiAobGlzdGVuZXIuY2FuY2VsbGVkID0gITApO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTGlzdGVuZXJzLmRlbChoYXNoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAobGlzdGVuZXIgPSBnbG9iYWxTdG9yZSgpLmdldChcInBvc3RNZXNzYWdlTGlzdGVuZXJcIikpICYmIGxpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG5cdCAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuX19wb3N0X3JvYm90XzEwXzBfNDZfXztcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNyY190eXBlc19UWVBFU18wID0gITA7XG5cdCAgICAgICAgZnVuY3Rpb24gY2xlYW5VcFdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3JlcXVlc3RQcm9taXNlcyRnZXQyID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0UHJvbWlzZXNcIikuZ2V0KHdpbiwgW10pOyBfaTIgPCBfcmVxdWVzdFByb21pc2VzJGdldDIubGVuZ3RoOyBfaTIrKykgX3JlcXVlc3RQcm9taXNlcyRnZXQyW19pMl0ucmVqZWN0KG5ldyBFcnJvcihcIldpbmRvdyBcIiArIChpc1dpbmRvd0Nsb3NlZCh3aW4pID8gXCJjbG9zZWRcIiA6IFwiY2xlYW5lZCB1cFwiKSArIFwiIGJlZm9yZSByZXNwb25zZVwiKSkuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNldHVwKCk7XG5cdCAgICB9IF0pO1xuXHR9KSk7IFxufSAocG9zdFJvYm90KSk7XG5cbnZhciBwb3N0Um9ib3RFeHBvcnRzJDEgPSBwb3N0Um9ib3QuZXhwb3J0cztcblxuLyogQGZsb3cgKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUpIHtcblx0Ly8gJEZsb3dGaXhNZVxuXHRtb2R1bGUuZXhwb3J0cyA9IHBvc3RSb2JvdEV4cG9ydHMkMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tY29tbW9uanNcblxuXHQvLyAkRmxvd0ZpeE1lXG5cdG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0czsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tY29tbW9uanMgXG59IChwb3N0Um9ib3QkMSkpO1xuXG52YXIgcG9zdFJvYm90RXhwb3J0cyA9IHBvc3RSb2JvdCQxLmV4cG9ydHM7XG52YXIgaW5kZXggPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMocG9zdFJvYm90RXhwb3J0cyk7XG5cbnZhciBpbmRleCQxID0gLyojX19QVVJFX18qL19tZXJnZU5hbWVzcGFjZXMoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGRlZmF1bHQ6IGluZGV4XG59LCBbcG9zdFJvYm90RXhwb3J0c10pO1xuXG5leHBvcnQgeyBpbmRleCQxIGFzIGkgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/family@0.1.3_react-dom@18.3.1_react@18.3.1__react@18.3.1_viem@2.37.6_bufferutil@4.0.9_t_f5332391a67a6fa4ea84c6115cadfe97/node_modules/family/lib/index-DD_kndDs.js\n"));

/***/ })

}]);